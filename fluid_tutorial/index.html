<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" type="text/css" href="physsim.css">
    <title>Fluid Simulation</title>
  </head>
  <body>
    <div class="sidenav">
      <a href="#home">Top</a><br><br>
      <a href="#Acknowledgments">Acknowledgments</a><br><br>
      <a href="#Background">Background</a><br><br>
      <a href="#What_to_Install">What to Install</a><br><br>
      <a href="#Why_Physics">Why Physics?</a><br><br>
      <a href="#Viewing_Geometry_Using_OpenGL">Viewing Geometry Using OpenGL</a><br>
      <ul>
        <li><a href="#Hello_Sphere">Hello, Sphere!</a></li>
        <li><a href="#Hello_Shaded_Sphere">Hello, Shaded Sphere!</a></li>
        <li><a href="#Positioning_the_Sphere">Positioning the Sphere</a></li>
        <li><a href="#How_OpenGL_Maps_from_3D_to_2D">How OpenGL Maps from 3D to 2D</a></li>
      </ul><br>
      <a href="#A_Massless_Sizeless_Particle">A Massless, Sizeless Particle</a><br>
      <ul>
        <li><a href="#Mathematical_Model_of_a_Massless_Sizeless_Particle">Mathematical Model of a Massless, Sizeless Particle</a></li>
        <li><a href="#Simulating_a_Massless_Sizeless_Particle">Simulating a Massless, Sizeless Particle</a></li>
        <li><a href="#Model_of_Massless_Sizeless_Particle_In_Velocity_Field">Mathematical Model of a Massless, Sizeless Particle in a Velocity Field</a></li>
        <li><a href="#Simulating_Massless_Sizeless_Particle_in_Velocity_Field">Simulating a Massless, Sizeless Particle in a Velocity Field</a></li>
      </ul><br>
      <a href="#A_Particle_with_Mass">A Particle with Mass</a><br>
      <ul>
        <li><a href="#Mathematical_Model_of_Particle_with_Mass">Mathematical Model of a Particle with Mass</a></li>
        <li><a href="#Simulating_Particle_with_Mass">Simulating a Particle with Mass</a></li>
        <li><a href="#Mathematical_Model_of_Particles_with_Mass_Size_and_Multiple_Forces">Mathematical Model of Particles with Mass, Size, and Multiple Forces</a></li>
        <li><a href="#Simulating_Colliding_Particles_with_Mass_and_Size">Simulating Colliding Particles with Mass and Size</a></li>
      </ul><br>
      <a href="#Fluid_Mechanics">Fluid Mechanics</a><br>
      <ul>
        <li><a href="#Fluid_Particles">Fluid Particles</a></li>
        <li><a href="#Newtons_Momentum_Equation">Newton's Momentum Equation</a></li>
        <li><a href="#Gravitational_Force">Gravitational Force</a></li>
        <li><a href="#Pressure_Gradient_Force">Pressure Gradient Force</a></li>
        <li><a href="#Viscous_Force">Viscous Force</a></li>
        <li><a href="#Newtons_Second_Law_for_a_Fluid_Particle">Newton's Second Law for a Fluid Particle</a></li>
        <li><a href="#Unsteadiness_and_Advection">Unsteadiness &amp; Advection</a></li>
        <li><a href="#Final_Form_of_Navier_Stokes_Momentum_Equation">Final Form of the Navier-Stokes Momentum Equation</a></li>
        <li><a href="#Mass_Conservation_and_Incompressibility">Mass Conservation &amp; Incompressibility</a></li>
        <li><a href="#Splitting">Splitting</a></li>
      </ul><br>
      <a href="#The_Staggered_Grid">The Staggered Grid</a><br>
      <ul>
        <li><a href="#Staggered_Grid_Structure">Staggered Grid Structure</a></li>
        <li><a href="#Storing_Staggered_Grid_Data">Storing Staggered Grid Data</a></li>
        <li><a href="#Staggered_Grid_Data_Structure">The Staggered Grid Data Structure</a></li>
        <li><a href="#Grids_vs_Particles_for_Fluid_Simulation">Grids vs. Particles for Fluid Simulation</a></li>
      </ul><br>
      <a href="#Mapping_from_Particles_to_Grid">Mapping from Particles to the Grid</a><br>
      <ul>
        <li><a href="#Barycentric_Weights_of_a_Particle">Barycentric Weights of a Particle</a></li>
        <li><a href="#Splatting_Particle_Velocities_onto_Grid_in_2D">Splatting Particle Velocities onto the Grid in 2D</a></li>
        <li><a href="#Splatting_Particle_Velocities_onto_Grid_in_3D">Splatting Particle Velocities onto the Grid in 3D</a></li>
        <li><a href=="#Normalizing_Splatted_Velocities">Normalizing Splatted Velocities</a></li>
        <li><a href="#Handling_Boundary_and_Cell_Labels">Handling the Boundary and Cell Labels</a></li>
        <li><a href="#Implementing_3D_Splatting_of_Particle_Velocities">Implementing 3D Splatting of Particle Velocities</a></li>
      </ul><br>
      <a href="#Advecting_Particle_Velocities">Advecting Particle Velocities</a><br>
      <ul>
        <li><a href="#Advection_in_1D">Advection in 1D</a></li>
        <li><a href="#Advection_in_2D">Advection in 2D</a></li>
        <li><a href="#Advection_in_3D">Advection in 3D</a></li>
        <li><a href="#Implementing_3D_Advection">Implementing 3D Advection</a></li>
      </ul><br>
      <a href="#Applying_Body_Forces">Applying Body Forces</a><br><br>
      <a href="#Pressure_Projection">Pressure Projection</a><br>
      <ul>
        <li><a href="#Velocity_Update_via_Discrete_Pressure_Gradient">Velocity Update via the Discrete Pressure Gradient</a></li>
        <li><a href="#Discrete_Divergence_of_Velocity_Field">Discrete Divergence of the Velocity Field</a></li>
        <li><a href="#Conjugate_Gradient_Algorithm">Conjugate Gradient Algorithm</a></li>
        <li><a href="#Implementing_Pressure_Projection">Implementing Pressure Projection</a></li>
      </ul><br>
      <a href="#Mapping_from_Grid_to_Particles">Mapping from the Grid to the Particles</a><br><br>
      <a href="#Visualizing_Fluid_Animation">Visualizing the Fluid Animation</a><br><br>
      <a href="#The_End_Result">The End Result</a><br>
      <br>
      <br>
      <br>
      <br>
      <br>
    </div>
    <div class="thetext">
      <p><img src="BasicFluidAnimation.gif" class="centeropengl"></img></p>
      <p style="font-size: 10px;">Video made using the FLIP solver and visualizer in the <a target="_blank" href="https://cal.cs.umbc.edu/Courses/PhysicsBasedAnimation/">SIGGRAPH physics-based animation course</a> on which this tutorial is based.</p>
      <h1 id="home">Physics-Based Simulation &amp; Animation of Fluids</h1>
      <p class="author">By Chand T. John, Ph.D.</p>
      <p>Do you ever wonder how special effects using fluids like water are animated for movies? In this tutorial, we'll show you how to simulate fluids using the popular Particle-in-Cell / Fluid-Implicit-Particle (PIC/FLIP) method. In this tutorial, we will:
      <ul>
        <li>write all the code, from scratch, for a physics-based fluid simulation,</li>
        <li>derive our code implementation from a widely used mathematical model of fluid physics,</li>
        <li>install minimal, widely available free software,</li>
        <li>not skip any steps, and</li>
        <li>follow professional code style and testing practices.</li>
      </ul>
      </p>
      <p>The mathematical model of fluid physics driving this tutorial are the Navier-Stokes equations, which we'll personify with this image, without explanation, for now. We'll dive into the details of these equations when introducing fluid mechanics below.</p>
      <p><img src="TitleImage.jpg" class="centeropengl" style="border-style: none;"></img></p>
      <h1 id="Acknowledgments">Acknowledgments</h1>
      <p>This tutorial expands on the fluid simulation portion of the excellent <a target="_blank" href="https://cal.cs.umbc.edu/Courses/PhysicsBasedAnimation/">SIGGRAPH course on physics-based animation</a> created by Dr. Adam Bargteil and Dr. Tamar Shinar. This tutorial also references the excellent <a target="_blank" href="https://www.cs.ubc.ca/~rbridson/fluidsimulation/">educational materials on fluid simulation</a> put together by Dr. Robert Bridson and Dr. Matthias M&uuml;ller-Fischer as well as Dr. Bridson's <a target="_blank" href="https://www.amazon.com/Simulation-Computer-Graphics-Robert-Bridson/dp/1482232839">book on fluid simulation</a>. These resources are tremendously useful for making physics-based simulation and animation accessible to a wide audience and I merely hope to add some details and illustrations on top of these awesome contributions by others. We will cite all of these materials frequently throughout this tutorial! I highly recommend going through these materials if you are at all curious about physics-based simulation for computer graphics.</p>
      <h1 id="Background">Background</h1>
      <p>This tutorial is designed assuming a year or two of experience in or exposure to:
      <ul>
        <li>Computer programming in C++</li>
        <li>Using a command-line terminal on a computer running Linux, e.g., the Ubuntu operating system</li>
        <li>Newtonian mechanics, e.g., <i>F</i> = <i>ma</i>, momentum, position, velocity, acceleration</li>
        <li>Calculus: differential, integral, and vector calculus</li>
      </ul></p>
      <p>Some exposure to computer graphics helps but is certainly not required. If you're a second- or third-year computer science college student, you have more than enough background! If you haven't gone to college, haven't studied computer science, don't remember much math or physics, or this list just feels overwhelming in general, that's okay! Feel free to follow along and look up and/or skip lots of things! You don't have to understand everything, by any means, to gain something from this tutorial. Other than access to a computer (yes, this can be a challenge) and at least an occasional Internet connection, everything else this tutorial requires is freely available!</p>
      <h1 id="What_to_Install">What to Install</h1>
      <p>This tutorial will use the C++ programming language. We will use the Open Graphics Library (OpenGL) and the associated OpenGL Utility Toolkit (GLUT) to display graphics on the computer screen. This is freely available software widely used for displaying graphics on computer screens.</p>
      <p>From this point onward, I'll assume you're using a computer running Ubuntu 16.04 or 18.04. I'll also assume your computer account has permission to install new software on that computer, or if not, that someone else can do it for you. If you're running another operating system, such as Windows or macOS, you should be able to follow along but with some small changes to commands and the code.</p>
      <p>Open a Terminal (CTRL+ALT+T on Ubuntu). Type this command and press Enter:</p>
      <div class="outer">
        <div class="inner">
          <pre>g++ --version</pre>
        </div>
      </div>
      <p>You should see some text showing the version of <code>g++</code>, the program we'll use to compile our code, that is installed on your computer. If not, look up how to install it. For our purposes, which version of the compiler you install should matter much.</p>
      <p>Next, in a Terminal (the same one as before is fine!), type this command and then press Enter to run it:</p>
      <div class="outer">
        <div class="inner">
          <pre>sudo apt install freeglut3-dev</pre>
        </div>
      </div>
      <p>If you're asked to, enter your password and press Enter. Once the computer finishes installing OpenGL and GLUT, figure out <i>where</i> it was installed. I found this out by typing something like <code>ls /usr/lib/x86_64-linux-gnu/libgl*</code> and pressing the [TAB] key twice, causing the Terminal to list a whole bunch of files with names starting with <code>libgl</code>something including <code>libglut.</code>something. So, my OpenGL and GLUT libraries were installed in <code>/usr/lib/x86_64-linux-gnu/</code>. Feel free to search online for how to find where OpenGL and GLUT were installed on your computer if you're not sure.</p>
      <p>This is not required but I highly recommend installing <code>clang-format</code>, a program used by many software developers in industry to format their code in a consistent style. We'll use this program to format our code in Google's style. To install it, run this command in a Terminal and press Enter:</p>
      <div class="outer">
        <div class="inner">
          <pre>sudo apt install clang-format-10</pre>
        </div>
      </div>
      <p>It's okay to use another version of this program; I just happen to be using version 10 at the moment.</p>
      <p>Now, create a directory (folder) somewhere on your computer where you want to store all the code you write as part of this tutorial. You can and will make multiple subdirectories in there as the tutorial proceeds, but it's good to have one parent directory that holds everything. <code>cd</code> to that parent directory in a Terminal window. Then type this command and press Enter:</p>
      <div class="outer">
        <div class="inner">
          <pre>clang-format-10 -style=Google -dump-config &gt; .clang-format</pre>
        </div>
      </div>
      <p>This creates a "hidden" file (meaning you can see it by running the <code>ls -a</code> command, but not the plain <code>ls</code> command) in this directory that contains your default settings consistent with the Google style for the <code>clang-format</code> program. Here is my <a target="_blank" href="https://github.com/unusualinsights/phys_sim_examples/blob/main/.clang-format">.clang-format file</a>. If for some reason you want to keep your code in multiple disparate places on your computer, you can just re-run this command in each of those directories.</p>
      <h1 id="Why_Physics">Why Physics?</h1>
      <p>Why do we use physics and math to derive code that simulates a fluid? It's actually quite hard to animate fluid motion in a way that looks believable enough for movie viewers. It's also become more feasible as computers have become more powerful, to simulate accurate physics rather than try to fake it.</p>
      <p>To make physics into something we can compute, though, we must use math. In physics, the terms "mechanics" or "dynamics" typically refer to the mathematical relationships between motion (kinematics) and the forces (kinetics) that generate that motion. You'll often hear the terms "fluid mechanics" and "fluid dynamics" used interchangeably. The whole point is to determine how forces lead to motion, mathematically, so that a computer can do that math and simulate that motion for animation. Fluid simulation is also very important in scientific applications, including weather prediction.</p>
      <h1 id="Viewing_Geometry_Using_OpenGL">Viewing Geometry Using OpenGL</h1>
      <p>OpenGL is a general framework that allows us to do graphics programming. To use it to display geometry effectively, we need to set up some initial working code and understand a bit about how OpenGL code manages what we see on the screen.</p>
      <h2 id="Hello_Sphere">Hello, Sphere!</h2>
      <p>Our first program will be a single file containing code in the C++ programming language. When we run this program, if everything is working, a window will pop up on the computer screen displaying a single, red, boring sphere. It's so boring, in fact, that it won't even look three-dimensional: it'll just look like a filled-in red circle.</p>
      <p>Make a directory called <code>basic</code> inside the directory that'll house all your code for this tutorial. Okay, you can put this directory anywhere, but this will just make it less work for you to run <code>clang-format</code> on your code and keep it organized the same way as this tutorial's code. In that directory, create a file called <code>HelloSphere.cpp</code>. You can copy the code from my <a target="_blank" href="https://github.com/unusualinsights/phys_sim_examples/blob/main/basic/HelloSphere.cpp">HelloSphere.cpp</a> file and save it. Or you can just download the file by clicking on this link and then clicking the "Raw" button on that page. I put a lot of comments in the file explaining what the code does. If you want to learn more details about how OpenGL and GLUT work, you can find plenty of documentation via online search.</p>
      <p>In a Terminal, <code>cd</code> to the directory containing this <code>HelloSphere.cpp</code> file. Then run this command:</p>
      <div class="outer">
        <div class="inner">
          <pre>clang-format-10 -style=file -i HelloSphere.cpp</pre>
        </div>
      </div>
      <p>Congratulations! Your C++ code is now formatted according to Google's standards! Well, at least it's formatted to the standards a computer can follow automatically. Now, let's compile your code with this command:</p>
      <div class="outer">
        <div class="inner">
          <pre>g++ HelloSphere.cpp -o HelloSphere -L/usr/lib/x86_64-linux-gnu/ -lGL -lglut -lGLU</pre>
        </div>
      </div>
      <p>If it compiled with no errors or warnings, let's run the program! Run it with this command:</p>
      <div class="outer">
        <div class="inner">
          <pre>./HelloSphere</pre>
        </div>
      </div>
      <p>You should see a window pop up on your screen that looks something like this:</p>
      <p><img src="HelloSphere.png" class="centeropengl"></img></p>
      <p>You can close the window to stop the program.</p>
      <p>Here are a couple sources that I think illustrate nicely how to create simple OpenGL programs from scratch:</p>
      <ul>
        <li><a target="_blank" href="https://stackoverflow.com/questions/23092055/how-to-display-a-sphere-correctly-in-opengl">StackOverflow example on displaying a sphere in OpenGL</a></li>
        <li><a target="_blank" href="https://ogldev.org/www/tutorial01/tutorial01.html">First tutorial from the OpenGL Step by Step series</a></li>
      </ul>
      <p>It's exciting to get our first program working. But the geometry I claimed was 3D just looks like a boring red disc (filled-in circle). How can we make it <i>look</i> 3D?</p>
      <h2 id="Hello_Shaded_Sphere">Hello, Shaded Sphere!</h2>
      <p>The 3D nature of shapes becomes more apparent when we add shading to our scene. In OpenGL, this is done by modeling the effects of light on the color of each vertex of any shape, assuming some material properties of the shape. By turning on a light, we can make our sphere "look" three-dimensional. In the same directory as the previous program (just for convenience, e.g., access to the same <code>.clang-format</code> file), create a new file called <code>HelloSphereShaded.cpp</code>. Here is my version, which you can copy or download: <a target="_blank" href="https://github.com/unusualinsights/phys_sim_examples/blob/main/basic/HelloSphereShaded.cpp">HelloSphereShaded.cpp</a>.</p>
      <p>Compile the program:</p>
      <div class="outer">
        <div class="inner">
          <pre>g++ HelloSphereShaded.cpp -o HelloSphereShaded -L/usr/lib/x86_64-linux-gnu/ -lGL -lglut -lGLU</pre>
        </div>
      </div>
      <p>Run it:</p>
      <div class="outer">
        <div class="inner">
          <pre>./HelloSphereShaded</pre>
        </div>
      </div>
      <p>View the result:</p>
      <p><img src="HelloSphereShaded.png" class="centeropengl"></img></p>
      <p>And there you have it! Now there's some shading, revealing the 3D shape of our sphere!</p>
      <p>To clarify exactly how the 3D coordinates of our shapes map to the 2D locations of shapes we see on the computer screen, let's do some experiments.</p>
      <h2 id="Positioning_the_Sphere">Positioning the Sphere</h2>
      <p>Make a new program called <code>PositionSphere.cpp</code> in the same directory (for convenience, you could put it in another directory if you really want). Here's my code: <a target="_blank" href="https://github.com/unusualinsights/phys_sim_examples/blob/main/basic/PositionSphere.cpp">PositionSphere.cpp</a>.</p>
      <p>Compile this program:</p>
      <div class="outer">
        <div class="inner">
          <pre>g++ PositionSphere.cpp -o PositionSphere -L/usr/lib/x86_64-linux-gnu/ -lGL -lglut -lGLU</pre>
        </div>
      </div>
      <p>Run it:</p>
      <div class="outer">
        <div class="inner">
          <pre>./PositionSphere</pre>
        </div>
      </div>
      <p>The window that pops up should look exactly the same as before! Now let's change the call to <code>putSphereCenteredAt</code> to <code>putSphereCenteredAt(1.0, 0.0, 0.0);</code> and then compile and run the program using the same commands as before. Here's the result:</p>
      <p><img src="PositionSphereX1.png" class="centeropengl"></img></p>
      <p>Hmm. It looks like the sphere is halfway out of our viewing window! Let's push the boundaries a bit further by changing that function call to <code>putSphereCenteredAt(1.2, 0.0, 0.0);</code>, compiling, and running again. Here's the result:</p>
      <p><img src="PositionSphereX1_2.png" class="centeropengl"></img></p>
      <p>The sphere is almost gone--just a little sliver left! Now, you might notice from the code above that the radius of this sphere is 0.25. We have just moved the sphere to the right by 1.2. <i>If</i> the viewing window is showing us <i>x</i>-coordinate values ranging up to <i>x</i> = 1, and <i>if</i> the positive <i>x</i>-axis direction points to the right of our window, then we would expect the sphere to disappear completely when we shift it to the right (positive <i>x</i> direction) by 1.25 or more. Let's try <code>putSphereCenteredAt(1.245, 0.0, 0.0);</code>:</p>
      <p><img src="PositionSphereX1_245.png" class="centeropengl"></img></p>
      <p>Sure enough, we only see a tiny sliver of the sphere remaining in our viewing window! If you're having trouble seeing it, it's just a few red pixels on the right middle end of the image above. Finally, let's try <code>putSphereCenteredAt(1.25, 0.0, 0.0);</code>. Sure enough, the resulting image, which I won't bother to show you here due to its extremely boring pitch black appearance, displays absolutely no part of the sphere. So, it seems like a reasonable guess, that perhaps our viewing window extends up to <i>x</i> = 1 on the right side.</p>
      <p>Similar experiments will reveal that the left end of our viewing window extends to <i>x</i> = -1, the top end goes to <i>y</i> = 1, and the bottom goes to <i>y</i> = -1. To verify this yourself, try putting 1.245 or -1.245 into the <i>x</i> or <i>y</i> coordinates of the <code>putSphereCenteredAt</code> function call one at a time and observe where the little sliver of the sphere appears.</p>
      <p>The <i>z</i>-coordinate is a bit odd in comparison. Let's try the same experiment, first with <code>putSphereCenteredAt(0.0, 0.0, 0.75);</code>:</p>
      <p><img src="PositionSphereZ0_75.png" class="centeropengl"></img></p>
      <p>If you compare this image to the original one from the first time we ran this program with no translation, or equivalently, the picture we got when we ran <code>HelloSphereShaded.cpp</code>, you may notice that the spheres look exactly the same size; the only difference between them seems to be the lighting and shading. This may seem a bit strange since the <i>z</i>-axis is presumably oriented somehow toward/away from us, i.e., perpendicular to the computer screen (since the <i>x</i>- and <i>y</i>-axes are both parallel to the computer screen), yet, unlike real life, bringing the sphere closer to us doesn't seem to be changing its size!</p>
      <p>Let's continue experimenting. Let's now move the sphere to <code>putSphereCenteredAt(0.0, 0.0, 1.0);</code>. If you run this, you'll notice a totally blank, black window again! What happened to the sphere? Why did it disappear? If <i>z</i> is clamped to [-1, 1] like <i>x</i> and <i>y</i> are, should we still see half of the sphere in our viewing window when we move it to be centered at <i>z</i> = 1?</p>
      <p>Let's make one other change to the code, temporarily. Let's comment out these two lines in the <code>drawBackground()</code> function:</p>
      <div class="outer">
        <div class="inner">
          <pre>  // glEnable(GL_CULL_FACE);
  // glCullFace(GL_BACK);</pre>
        </div>
      </div>
      <p>Then, try running the program:</p>
      <p><img src="PositionSphereZ1_0NoCull.png" class="centeropengl"></img></p>
      <p>Now, we seem to see the sphere again--the lighting looks different than what we just saw earlier. Let's not analyze the lighting too much and let's keep moving the sphere further along the <i>z</i>-axis. Let's move it now to <code>putSphereCenteredAt(0.0, 0.0, 1.24);</code>:</p>
      <p><img src="PositionSphereZ1_24NoCull.png" class="centeropengl"></img></p>
      <p>Hmm. Looks like the sphere is starting to disappear! Let's try <code>putSphereCenteredAt(0.0, 0.0, 1.2499);</code>:</p>
      <p><img src="PositionSphereZ1_2499NoCull.png" class="centeropengl"></img></p>
      <p>Just a tiny dot of the sphere left in our viewing window! Change the <i>z</i>-coordinate to 1.25 to verify that the sphere does indeed completely disappear from the viewing window at that location. This suggests pretty strongly that the <i>z</i>-coordinate does indeed extend up to <i>z</i> = 1 on the positive side of the <i>z</i>-axis (since the sphere has radius 0.25, so if it's centered at <i>z</i> = 1.25, the points on its surface will have <i>z</i> values that go as low as 1.25 - 0.25 = 1, which we can't see, and if it's centered at <i>z</i> = 1.2499, its points will go as low as <i>z</i> = 1.2499 - 0.25 = 0.9999, of which we do see a tiny bit). But is the positive <i>z</i> direction pointing toward us, or away from us?</p>
      <p>If you do the exact same experiments but with negative <i>z</i> values (and now you can uncomment those lines of code that mentioned something about culling), you'll notice the exact same pattern. When the sphere is centered at (0.0, 0.0, -1.0), it appears to have exactly the same size as it did at <i>z</i> = 0.75 and at <i>z</i> = 0, but with just a bit of a change in its lighting and shading:</p>
      <p><img src="PositionSphereZ_1_0.png" class="centeropengl"></img></p>
      <p>If you continue the experiment to move the sphere's center to (0.0, 0.0, -1.2499), you'll notice an identical image to when we put the sphere center at (0.0, 0.0, 1.2499), i.e., just a tiny dot in the middle of the screen is visible, and if you move the sphere center to (0.0, 0.0, -1.25), you'll see a totally blank black screen like you did when you moved the sphere center to (0.0, 0.0, 1.25). So, it appears that the negative <i>z</i>-coordinate also extends up to <i>z</i> = -1.</p>
      <h2 id="How_OpenGL_Maps_from_3D_to_2D">How OpenGL Maps from 3D to 2D</h2>
      <p>It still seems bizarre that with all this experimenting, we can't tell whether <i>z</i> increases toward us, or decreases toward us! But at least we did discover that we seem to be able to view any points that are within (-1, 1)<sup>3</sup> &sub; <b>R</b><sup>3</sup>, i.e., a box where -1 &lt; <i>x</i>, <i>y</i>, <i>z</i> &lt; 1. This is called OpenGL's default <b>viewing frustum</b>. We also figured out that <i>x</i> increases to the right and <i>y</i> increases upward. Based on this, it might be a reasonable guess that <i>z</i> by the right-hand rule increases toward us. But how can we know for sure?</p>
      <p>Instead of experimenting indefinitely, let's now get a more detailed understanding of exactly what OpenGL does to go from what appears to be 3D geometry, to a 2D image on our two-dimensional computer screen.</p>
      <p>The <code>glutSolidSphere</code> function always generates a set of triangles that approximate the surface of a sphere that is centered at (0, 0, 0). To "move" a sphere to be centered at a location other than (0, 0, 0), we must adjust the coordinates of the vertices of the triangles approximating the sphere to be located in appropriate places such that the resulting sphere would be centered at the desired location. To handle this shifting, or <b>translation</b>, of the coordinates, our code calls the <code>glTranslated</code> function. But notice some other code around that function call: there is some pushing and popping of a matrix, and something called <code>GL_MODELVIEW</code>. What is all that?</p>
      <p>OpenGL actually transforms the coordinates of any points it draws in the following way. Let (<i>x</i>, <i>y</i>, <i>z</i>) be an arbitrary point, e.g., a vertex on one of the triangles making up the sphere created by a call to <code>glutSolidSphere</code>. OpenGL represents each point in <b>homogenous coordinates</b>, so the point is represented with the coordinates <i>p</i> = (<i>x</i>, <i>y</i>, <i>z</i>, 1). These original coordinates for the point <i>p</i> are said to be in the <b>object coordinate system</b> or <b>local coordinate system</b>. The terms "local" and "object" here are referring to coordinate system whose origin is at the center of the sphere itself, regardless of where we're trying to center it. So, this is the coordinate system that is "local" to the "object," i.e., the sphere we want to draw. OpenGL represents this 4D point as a column vector (4x1 matrix) and then left-multiplies it by a 4x4 <b>model matrix</b>. The resulting 4x1 column vector represents the same point in the <b>world coordinate system</b> of OpenGL. This is the default, universal coordinate system OpenGL uses. All other coordinate systems are defined relative to this coordinate system. Note that this coordinate system isn't explicitly defined anywhere; a universal coordinate system just exists theoretically, and the only way for us to "see" it is to define at least one other coordinate system from which to view the universal/world coordinate system. Next, OpenGL left-multiplies that world-coordinate-system 4x1 column vector by a 4x4 <b>view matrix</b>. The resulting 4x1 column vector represents the point <i>p</i>'s coordinates in what we call the <b>view coordinate system</b>. Next, OpenGL left-multiplies this 4x1 vector by yet another 4x4 matrix called the <b>projection matrix</b>, yielding a 4x1 vector of coordinates for the point <i>p</i> in the <b>clip coordinate system</b>. At this point, OpenGL "clips" or removes all points that lie outside of the viewing frustum. In this case, we're using OpenGL's default viewing frustum where the <i>x</i>, <i>y</i>, and <i>z</i> coordinates must lie within (-1, 1). After clipping, OpenGL <i>normalizes</i> the coordinates of all remaining points so that <i>x</i>, <i>y</i>, and <i>z</i> lie within (-1, 1). By default, the clip coordinates are already in that range as we just said, but OpenGL does allow you to change the clip coordinates to be in a different range. But when OpenGL normalizes the clip coordinates into the <b>normalized device coordinate (NDC) system</b>, the coordinates must all lie within (-1, 1) regardless of what range the clip coordinates cover. Finally, the NDC coordinates are transformed so that -1 &lt; <i>x</i><sub>ndc</sub> &lt; 1 covers 0 &lt; <i>x</i><sub>window</sub> &lt; <i>w</i>, where <i>w</i> is the width of the viewing window specified in the code above, -1 &lt; <i>y</i><sub>ndc</sub> &lt; 1 covers 0 &lt; <i>y</i><sub>window</sub> &lt; <i>h</i>, where <i>h</i> is the height of the viewing window, and -1 &lt; <i>z</i><sub>ndc</sub> &lt; 1 covers 0 &lt; <i>z</i><sub>window</sub> &lt; 1. It is possible to change these ranges in OpenGL, but what we described here is the default behavior of OpenGL.</p>
      <p>Let's denote the model matrix by <i>M</i><sub>model</sub>, the view matrix by <i>M</i><sub>view</sub>, and the projection matrix by <i>M</i><sub>proj</sub>. Then the clip coordinates, <i>p</i><sub>clip</sub>, of the point <i>p</i> in object coordinates is <i>p</i><sub>clip</sub> = <i>M</i><sub>proj</sub> &middot; <i>M</i><sub>view</sub> &middot; <i>M</i><sub>model</sub> &middot; <i>p</i>. Let <i>w</i> = <i>h</i> = 500 pixels, as specified in our code above for the window size.</p>
      <p>In our <code>HelloShadedSphere.cpp</code> and original <code>PositionSphere.cpp</code> programs, when we left the sphere centered at the origin of the world coordinate system, our model matrix, <i>M</i><sub>model</sub>, was the 4x4 identity matrix. Later when we started translating the sphere away from being centered at the origin, that translation amount, (<i>t<sub>x</sub></i>, <i>t<sub>y</sub></i>, <i>t<sub>z</sub></i>) (e.g., once we did <i>t<sub>x</sub></i> = <i>t<sub>y</sub></i> = 0 and <i>t<sub>z</sub></i> = 1.2499), was included in the model matrix. That is:</p>
      <p><img src="ModelMatrix.png" class="center" style="width: 50%; border-style: none;"></img></p>
      <p>The view matrix is what represents the position and orientaton of the "camera" of OpenGL. By default, this is the identity matrix. This effectively makes us view all the objects in our OpenGL scene, by default, by having our camera eye located at (0, 0, +&infin;), while looking in the negative <i>z</i> direction. You'll see other sources saying the camera eye is effectively at the origin, (0, 0, 0), but the projection we describe below actually makes the concept of the eye being anywhere near the scene seem nonsensical. So, by default,</p>
      <p><img src="ViewMatrix.png" class="center" style="width: 50%; border-style: none;"></img>,</p>
      <p>but if you look at our code above, you'll notice that the model matrix and any view matrix are all combined into a single stack of matrices OpenGL calls the <code>GL_MODELVIEW</code> matrix mode. So, OpenGL actually combines, at any point in the code, model and view matrices into a single matrix that gets applied to all object-space vertex coordinates to obtain view coordinates. In our case,</p>
      <p><img src="ModelviewMatrix.png" class="center" style="width: 75%; border-style: none;"></img>.</p>
      <p>By default, in OpenGL, <i>M</i><sub>proj</sub> is the 4x4 identity matrix, which represents what is called an <b>orthographic projection</b>: it's like having a camera located infinitely far away from the origin, which lacks any notion of perspective; everything looks just as close to us as everything else since everything is, basically, infinitely far away from us. It's kind of like how we can't tell which stars in the sky are closer or farther away from us just by looking at them, even though we can judge how close a basketball might be to us if it's 1 meter vs. 10 meters away. With the default orthographic projection in OpenGL, it's like everything is a star that's infinitely far away. OpenGL applies the projection matrix typically on another matrix stack called <code>GL_PROJECTION</code>, which is not mentioned in our code since we just used the default projection matrix. If we wanted to change the camera's behavior, we could do so explicitly on the <code>GL_PROJECTION</code> matrix stack in our code. So:</p>
      <p><img src="OrthographicProjectionMatrix.png" class="center" style="width: 50%; border-style: none;"></img></p>
      <p>Combining all of this, we see that <i>p</i><sub>clip</sub> = <i>M</i><sub>proj</sub> &middot; <i>M</i><sub>view</sub> &middot; <i>M</i><sub>model</sub> &middot; <i>p</i> = (<i>x</i> + <i>t<sub>x</sub></i>, <i>y</i> + <i>t<sub>y</sub></i>, <i>z</i> + <i>t<sub>z</sub></i>), i.e., the result of the projection and modelview matrices, together, is just to translate all object-space coordinates of all points by (<i>t<sub>x</sub></i>, <i>t<sub>y</sub></i>, <i>t<sub>z</sub></i>). After applying all of these transformations, OpenGL will clip any points that are outside of the viewing frustum, like we saw earlier in all the examples where parts of the sphere were cut off from appearing in the viewing window.</p>
      <p>Since our clip coordinates are already normalized by default, <i>p</i><sub>clip</sub> also represents the normalized device coordinates (NDC) of all points: <i>p</i><sub>ndc</sub> = <i>p</i><sub>clip</sub>. Finally, the NDC coordinates are transformed to window coordinates by scaling and shifting the NDC values to get the <i>x</i>-coordinates to be within 0 to <i>w</i>, the <i>y</i>-coordinates to be within 0 to <i>h</i>, and the <i>z</i>-coordinates to be within 0 to 1. This is accomplished by setting <i>x</i><sub>window</sub> = (<i>w</i>/2)(<i>x</i><sub>ndc</sub> + 1) pixels, <i>y</i><sub>window</sub> = (<i>h</i>/2)(<i>y</i><sub>ndc</sub> + 1) pixels, and <i>z</i><sub>window</sub> = (1/2)(<i>z</i><sub>ndc</sub> + 1). You can verify that <i>x</i><sub>ndc</sub> = -1 gets mapped by this transformation to <i>x</i><sub>window</sub> = 0 and <i>x</i><sub>ndc</sub> = 1 gets mapped to <i>x</i><sub>window</sub> = <i>w</i> = 500, so this is how the 3D object coordinates end up getting mapped to 3D window coordinates.</p>
      <p>Finally, what we see on our 2D screen is the result of taking the 3D window coordinates and doing a depth test, as we asked OpenGL to do with in our code with the function call <code>glEnable(GL_DEPTH_TEST);</code>. So, this is how OpenGL makes sure whatever we see on our 2D screen is whatever is closest to us in the 3D scene we defined, much like a real-life camera's 2D image displays what the camera can see in a 3D real-world scene.</p>
      <p>All of these coordinate system shenanigans were to help us understand exactly what we see on the screen, and how what we see in pixels maps to the original 3D coordinates of the objects we constructed. This insight will come in handy as we start moving objects around on the screen during animations of physics-based simulations! Here is a diagram summarizing the overall default transformation from world coordinates to window coordinates in OpenGL:</p>
      <p><img src="WorldToWindow.png" class="center" style="width: 100%; border-style: none;"></img></p>
      <p>For more details and insights on how OpenGL handles coordinate transformations read these sources:
      <ul>
        <li><a target="_blank" href="https://www.khronos.org/opengl/wiki/Viewing_and_Transformations">Official OpenGL documentation on viewing and transformations</a></li>
        <li><a target="_blank" href="https://learnopengl.com/Getting-started/Coordinate-Systems">LearnOpenGL article on coordinate transformations</a></li>
        <li><a target="_blank" href="https://www.songho.ca/opengl/gl_transform.html">Detailed description and derivation of OpenGL transformations</a></li>
        <li><a target="_blank" href="https://stackoverflow.com/questions/37495019/opengl-how-to-make-projection-when-camera-is-within-viewing-frustum">Stack Overflow post and answer on orthographic projections</a></li>
        <li><a target="_blank" href="https://www.cs.uaf.edu/2007/spring/cs481/lecture/01_23_matrices.html">OpenGL matrix modes and order of projection and modelview matrix multiplications</a></li>
      </ul></p>
      <p>Now that we understand, in detail, how our 3D world scene maps to our 2D window, we can proceed to implementing animations of physics-based simulations using OpenGL. Note that with our current setup, the 2D location of the center of a sphere in the window on our computer screen accurately shows the location of the sphere's center in the <i>xy</i>-plane in the world coordinate system, since the orthographic projection does not distort this 2D location in any way.</p>
      <h1 id="A_Massless_Sizeless_Particle">A Massless, Sizeless Particle</h1>
      <p>We'll go through a few steps to describe each physics-based simulation in each tutorial:
      <ol>
        <li>Describe a mathematical model of the physical system we want to simulate.</li>
        <li>Design and implement that mathematical model in a computer program.</li>
        <li>Run the program and view the results.</li>
      </ol></p>
      <h2 id="Mathematical_Model_of_a_Massless_Sizeless_Particle">Mathematical Model of a Massless, Sizeless Particle</h2>
      <p>Like Dr. Adam Bargteil and Dr. Tamar Shinar's <a target="_blank" href="https://cal.cs.umbc.edu/Courses/PhysicsBasedAnimation/">course on physics-based animation</a> from SIGGRAPH 2018 and 2019, we begin by considering a very simple object to simulate: a theoretical particle that is infinitely small and has no mass. You can't see it. You can't feel it. It's almost as if it isn't there at all. Oh, but it is there, if we define it to be: an infinitely small dot, moving around in space, or sitting still in space, that defies all of our senses. In a nutshell, a particle, <b>p</b>, <i>is</i> nothing but a vector function <b>x<sub>p</sub></b>(<i>t</i>) of time <i>t</i> representing the position of the particle at any given time. We can think of a <i>simulation</i> of a massless, sizeless particle as just us sitting there staring at a sequence of (<i>x</i>, <i>y</i>, <i>z</i>) coordinates changing over a period of time, scrolling by on our computer screens before our eyes. Here is a more formal definition.</p>
      <p id="rounded"><b>Definition.</b> Let <b>T</b> be a closed interval in the set of real numbers, <b>R</b>. Each element of <b>T</b> is called a <b>time</b> or <b>instant of time</b>. A <b>particle</b>, <b>p</b>, is a function <b>x<sub>p</sub></b>: <b>T</b> &rarr; <b>R</b><sup>3</sup> that assigns to every time <i>t</i> &isin; <b>T</b> a <b>position</b>, <b>x<sub>p</sub></b>(<i>t</i>) = (<i>x</i>(<i>t</i>), <i>y</i>(<i>t</i>), <i>z</i>(<i>t</i>)), in 3D space, where <i>x</i>, <i>y</i>, <i>z</i>: <b>T</b> &rarr; <b>R</b> are functions representing the coordinates in 3D space of the particle <b>p</b> at each time, <i>t</i>.</p>
      <p>We'll refrain from formally defining what a <i>simulation</i> of a massless, sizeless particle is (even though we will basically do it here, but note the details of this "definition" will change as we deal with different systems in this tutorial), but you can think of it simply as a discrete sampling of the position function <b>x<sub>p</sub></b>(<i>t</i>) at specific instants in time. That is, if we pick a strictly increasing sequence of times <i>t</i><sub>0</sub>, <i>t</i><sub>1</sub>, ..., <i>t</i><sub><i>N</i></sub> from our time interval <b>T</b>, then a simulation stepping through those values of time is just a sequence of positions in 3D space: <b>x<sub>p</sub></b>(<i>t</i><sub>0</sub>) = (<i>x</i>(<i>t</i><sub>0</sub>), <i>y</i>(<i>t</i><sub>0</sub>), <i>z</i>(<i>t</i><sub>0</sub>)), <b>x<sub>p</sub></b>(<i>t</i><sub>1</sub>) = (<i>x</i>(<i>t</i><sub>1</sub>), <i>y</i>(<i>t</i><sub>1</sub>), <i>z</i>(<i>t</i><sub>1</sub>)), ..., <b>x<sub>p</sub></b>(<i>t</i><sub><i>N</i></sub>) = (<i>x</i>(<i>t</i><sub><i>N</i></sub>), <i>y</i>(<i>t</i><sub><i>N</i></sub>), <i>z</i>(<i>t</i><sub><i>N</i></sub>)), representing the position of the particle at each of the time instants in the sequence <i>t</i><sub>0</sub>, <i>t</i><sub>1</sub>, ..., <i>t</i><sub><i>N</i></sub>. For other systems that are not just a single practically-nonexistent particle, a simulation could be defined in the same way, but the <i>state</i> of the system may not just be a sequence of positions. The state could also include velocities and other values. A simulation could thus generally be defined as a sequence of states, where the state would have to be defined explicitly for any given system we simulate.</p>
      <h2 id="Simulating_a_Massless_Sizeless_Particle">Simulating a Massless, Sizeless Particle</h2>
      <p>Despite a massless, sizeless particle essentially being an invisible object, we will represent such a particle conceptually as a sphere with a nonzero radius so we can, well, actually see it as it moves around on the screen. Yes, the sphere is just a visual aid for us to see where the particle is located in space as it moves. The particle itself, according to our theoretical model here, is infinitely small. We don't really need to assume the particle is infinitely small, but I just do it anyway since we haven't yet defined a particle to be anything other than a point moving around in space over time. It'll make more sense to talk about particle-like objects that have some nonzero size when we start looking at objects interacting with other things in the scene.</p>
      <p>Let's start by making a sphere move around the window. The infinitely small point at the center of the sphere will represent a theoretical massless, sizeless particle's position as it moves around the window. Let's make a particle whose <i>x</i> and <i>y</i> coordinates change as a function of time. Let's have the particle's position (i.e., the position of the center of the sphere representing the particle) be at <b>x</b>(<i>t</i>) = (<i>x</i>(<i>t</i>), <i>y</i>(<i>t</i>), 0) where <i>x</i>(<i>t</i>) = 0.5 cos <i>t</i> and <i>y</i>(<i>t</i>) = 0.5 sin <i>t</i>, where <i>t</i> is the amount of time, measured in seconds, that the program has been running. Basically, this will cause the particle to move counterclockwise along a circle of radius 0.5 about the origin of the coordinate system shown above. Here is the code, in a new file called <a target="_blank" href="https://github.com/unusualinsights/phys_sim_examples/blob/main/basic/MovingParticle.cpp"><code>MovingParticle.cpp</code></a>.</p>
      <p>Compile the program:</p>
      <div class="outer">
        <div class="inner">
          <pre>g++ MovingParticle.cpp -o MovingParticle -L/usr/lib/x86_64-linux-gnu/ -lGL -lglut -lGLU</pre>
        </div>
      </div>
      <p>And run it:</p>
      <div class="outer">
        <div class="inner">
          <pre>./MovingParticle</pre>
        </div>
      </div>
      <p>Observe the resulting animation. You will see a red sphere moving around the window in a circle! Here is my animation. Ignore the slight jump in the animation as it loops. My animated gif recording program only allows integer amounts of seconds as the duration of the recording, leading to the jump:</p>
      <p><img src="MovingParticle.gif" class="centeropengl"></img></p>
      <p>We just completed our first simulation! We specified a way for the particle to move as time passes and then implemented a program that animates a sphere following that movement!</p>
      <h2 id="Model_of_Massless_Sizeless_Particle_In_Velocity_Field">Mathematical Model of a Massless, Sizeless Particle in a Velocity Field</h2>
      <p>But okay, this doesn't seem very "physics-based," does it? Let's step slightly further into physics by defining a simple concept.</p>
      <p id="rounded"><b>Definition.</b> If a particle's position function <b>x</b>(<i>t</i>) is differentiable with respect to time on an open interval of <b>R</b> that contains <b>T</b>, then the <b>velocity</b> of the particle is the time-derivative, <b>x</b>'(<i>t</i>), of the position function.</p>
      <p>To step toward something more physically-driven, let's now imagine our particle is actually floating around in the air, pushed around by a very simplistic mathematical model of wind. Specifically, let's imagine the wind is described by a velocity field, meaning there's a specific wind velocity vector given to us for any given point in space, at any given time instant. In this case, let's imagine our wind velocity vector is defined by the function <b>u</b>(<b>x</b>, <i>t</i>) = <b>u</b>(<i>x</i>, <i>y</i>, <i>z</i>, <i>t</i>) = (<i>u</i>(<i>x</i>, <i>y</i>, <i>z</i>, <i>t</i>), <i>v</i>(<i>x</i>, <i>y</i>, <i>z</i>, <i>t</i>), <i>w</i>(<i>x</i>, <i>y</i>, <i>z</i>, <i>t</i>)), where <i>u</i>(<i>x</i>, <i>y</i>, <i>z</i>, <i>t</i>) = -(<i>x</i> - 0.5 cos (<i>t</i><sup>2</sup>) cos <i>t</i>), <i>v</i>(<i>x</i>, <i>y</i>, <i>z</i>, <i>t</i>) = -(<i>y</i> - 0.5 cos (<i>t</i><sup>2</sup>) sin <i>t</i>), and <i>w</i>(<i>x</i>, <i>y</i>, <i>z</i>, <i>t</i>) = 0. Following the lead of the Bargteil and Shinar <a target="_blank" href="https://cal.cs.umbc.edu/Courses/PhysicsBasedAnimation/PhysicsBasedAnimationCourseNotes2019.pdf">course notes</a>, we will have our particle start at a specified initial position <b>x</b>(<i>t</i>) when <i>t</i> = 0, in this case <b>x</b>(0) = (0, 0, 0), and then keep updating the position of the particle by Forward Euler integration: <b>x</b>(<i>t</i> + &Delta;<i>t</i>) = <b>x</b>(<i>t</i>) + &Delta;t &middot; <b>u</b>(<b>x</b>(<i>t</i>), <i>t</i>). That is, the new position of the particle after stepping forward in time by an amount &Delta;<i>t</i> (the time from one call to <code>RenderScene()</code> to the next) will be the particle's current position plus the time increment amount, &Delta;t, times the velocity vector at the particle's current position at the current time. Note that this time stepping scheme is slightly more sophisticated than the simplest Forward Euler integration scheme, since we let the computer calculate &Delta;t each time it calls <code>RenderScene()</code>, and since the computer may take slightly different amounts of time between each call to <code>RenderScene()</code>, &Delta;t could vary when the program is running. And sorry for mentioning the name of a function from the code in the mathematical modeling section of the text here; I just wanted to clarify how the concept of the time step, also known as the time increment, relates to the code we've seen so far.</p>
      <h2 id="Simulating_Massless_Sizeless_Particle_in_Velocity_Field">Simulating a Massless, Sizeless Particle in a Velocity Field</h2>
      <p>Here is the code, in a file I called <a target="_blank" href="https://github.com/unusualinsights/phys_sim_examples/blob/main/basic/VelocityParticle.cpp"><code>VelocityParticle.cpp</code></a>.</p>
      <p>Compile:</p>
      <div class="outer">
        <div class="inner">
          <pre>g++ VelocityParticle.cpp -o VelocityParticle -L/usr/lib/x86_64-linux-gnu/ -lGL -lglut -lGLU</pre>
        </div>
      </div>
      <p>Run:</p>
      <div class="outer">
        <div class="inner">
          <pre>./VelocityParticle</pre>
        </div>
      </div>
      <p>Observe the resulting animation. It's a rather interesting animation since it looks like something "physics-based" is going on, though it's hard to tell exactly what. Rather than a particle "floating" in the wind, the animation looks more like a particle attached to a few rubber bands being pulled in various directions, eventually oscillating faster and faster as it is pulled toward the center of the window. Here is a looping animation of roughly the first 15 seconds of the animation, minus a little bit at the very beginning:</p>
      <p><img src="VelocityParticle.gif" class="centeropengl"></img></p>
      <p>This draws our attention to the fact that it's pretty challenging and unintuitive to try to manually specify velocity fields, even with some cleverly crafted formulas, that actually produce a realistic, physics-based effect that matches our vision for the system we want to model and simulate. As Bargteil and Shinar do in their <a target="_blank" href="https://cal.cs.umbc.edu/Courses/PhysicsBasedAnimation/PhysicsBasedAnimationCourseNotes2019.pdf">course notes</a>, we shall now proceed to the next level of physical realism in our mathematical modeling of a particle.</p>
      <p>Notice how the code above has the keyword <code>static</code> thrown around in a few places. This is not great programming style or structure! It suggests we're hacking our way through an important responsibility: keeping track of the state of our program, namely, the particle's position and the elapsed time. We need to delegate this responsibility to an object that will stay stored in memory between subsequent calls to <code>RenderScene()</code>. Let's make an improved version of this program in a file called <a target="_blank" href="https://github.com/unusualinsights/phys_sim_examples/blob/main/basic/VelocityParticleBetter.cpp"><code>VelocityParticleBetter.cpp</code></a>.</p>
      <p>While we got rid of the use of the <code>static</code> keyword, this code does still have a global <code>ParticleSimulator*</code> variable. To ensure it is used properly, I made a global <code>RenderScene()</code> function that checks that this variable has been initialized. Since GLUT requires that we use some static or global function as the display and idle functions, we have limited simple options for fully encapsulating all of our simulation and rendering into the classes. In this improved solution, we have better defined the jobs the program does by delegating them to different classes: the <code>Particle</code> encapsulates the storing and updating of a particle's position while the <code>ParticleSimulator</code> class does the job of advancing the simulation through time and directing its <code>Particle</code> to update and redraw itself as time elapses.</p>
      <h1 id="A_Particle_with_Mass">A Particle with Mass</h1>
      <p>We will now step into Newtonian mechanics, where we add the concepts of mass, force, and acceleration to create more physically realistic particle simulations.</p>
      <h2 id="Mathematical_Model_of_Particle_with_Mass">Mathematical Model of a Particle with Mass</h2>
			<p id="rounded"><b>Definition.</b> A <b>particle with mass</b> is a particle together with a strictly positive real number, <i>m</i>, called its <b>mass</b>.</p>
			<p>This defintiion may seem meaningless since we didn't really define what "mass" means. In fact, we won't define mass directly other than that it is a positive real number. We will make it useful though, by describing the governing axioms (assumptions or postulates) of Newtonian mechanics: namely, Newton's Laws of Motion. We will start with just Newton's Second Law. Later we'll add the Third Law. The First Law is actually a theorem that follows directly from the Second Law. Before stating Newton's Second Law, we need to define a concept and then make an assumption.</p>
			<p id="rounded"><b>Definition.</b> A nonempty set of vectors in <b>R</b><sup>3</sup> called <b>forces acting on a particle</b> can be summed to produce a <b>net force acting on the particle</b>.</p>
			<p>And now the assumption.</p>
			<p id="rounded"><b>Axiom.</b> The position function of a particle, <b>x</b>(<i>t</i>), is assumed to be twice differentiable with respect to time at all times <i>t</i> in some open interval of <b>R</b> that contains <b>T</b>.</p>
			<p>Now we can define the concept of acceleration.</p>
			<p id="rounded"><b>Definition.</b> The <b>acceleration</b> of a particle is the second time derivative of the particle's position. That is, if <b>x</b>(<i>t</i>) is the position of the particle at time <i>t</i>, then the acceleration of the particle at time <i>t</i> is <b>x</b>''(<i>t</i>).</p>
			<p>Now that we assumed we can calculate an acceleration for any time value we encounter during a simulation, we can safely state Newton's Second Law.</p>
			<p id="rounded"><b>Axiom (Newton's Second Law of Motion).</b> The net force, <b>f</b> &isin; <b>R</b><sup>3</sup>, acting on a particle is equal to the particle's mass, <i>m</i>, times the particle's <b>acceleration</b>. That is, <b>f</b> = <i>m</i><b>x</b>''(<i>t</i>).</p>
			<p>Newton's Second Law is based on a couple of particularly powerful realizations about nature:</p>
			<ul>
				<li>The motion of objects is governed by a concept called "force," and these <i>forces are additive</i> in nature; that is, any set of forces acting on an object, such as its weight and how hard we push it, can just be added together into a <i>net force</i>, which then governs how the object accelerates.</li>
				<li>The constant of proportionality relating the net force acting on an object to the object's acceleration, i.e., the object's mass, is itself a description of <i>how much matter</i> the object contains.</li>
			</ul>
			<p>Newton's Second Law is the magic that makes physics what it is: it gives us the recipe for <i>dynamics</i>: relating forces acting on objects (<i>kinetics</i>) to motion of those objects (<i>kinematics</i>).</p>
			<p>Newton's First Law, while commonly stated as another axiom of Newtonian mechanics, is actually a consequence of the Second Law.</p>
			<p id="rounded"><b>Theorem (Newton's First Law of Motion).</b> A particle with a net force of zero (<b>0</b> &isin; <b>R</b><sup>3</sup>) acting on it maintains a constant velocity at all times.</p>
			<p><b>Proof:</b> Since the net force <b>f</b> acting on the particle is zero, we know by Newton's Second Law that <b>0</b> = <b>f</b> = <i>m</i><b>x</b>''(<i>t</i>). Since we defined the mass of a particle as being strictly positive, <i>m</i><b>x</b>''(<i>t</i>) = <b>0</b> means that <b>x</b>''(<i>t</i>) = <b>0</b> for all times <i>t</i> &isin; <b>T</b>. Taking the antiderivative of this equation with respect to time yields <b>x</b>'(<i>t</i>) = <i>C</i> for some constant <i>C</i> &isin; <b>R</b> that doesn't vary with time, for all <i>t</i> &isin; <b>R</b>. Since <b>x</b>'(<i>t</i>) is the velocity of the particle, we have proved that the particle's velocity stays constant with time. This completes the proof. &#9632;</p>
			<p>Notably, if the initial velocity of a particle experiencing zero net force was zero, the particle will remain at velocity zero. Otherwise it will continue moving at the same constant velocity at all times. This explains a commonly stated version of Newton's First Law, that a particle at rest will remain at rest and a particle in motion will remain in motion at a constant velocity unless acted on by an outside force (which must result in a net nonzero force acting on the particle).</p>
			<h2 id="Simulating_Particle_with_Mass">Simulating a Particle with Mass</h2>
      <p>Here is an implementation of the model described above, in a file I called <a target="_blank" href="https://github.com/unusualinsights/phys_sim_examples/blob/main/basic/MassParticleGravity.cpp"><code>MassParticleGravity.cpp</code></a>.</p>
      <p>The force is a constant gravitational force; it does not change with time or space. Our code has slightly changed its integration scheme from forward Euler to symplectic Euler, as described in Bargteil and Shinar's <a target="_blank" href="https://cal.cs.umbc.edu/Courses/PhysicsBasedAnimation/PhysicsBasedAnimationCourseNotes2019.pdf">course notes</a>, now that we are dealing with two levels of integration: one to go from force and acceleration to velocity and another to go from velocity to position.</p>
      <p>You may find it a little odd that we structured our code to create and return new instances of <code>Vector2D</code> and <code>Point2D</code> from our <code>MakeUpdatedVelocity</code> and <code>MakeUpdatedPosition</code> functions, respectively. Isn't it inefficient to create and return new objects instead of just modifying one existing object directly? Well, it turns out that return value optimization, which we describe later in this tutorial, is a common optimization of code applied by C++ compilers. This eliminates some of the unnecessary copying of values that are simply being moved from a return value to a variable receiving the return value, for example. But, you may wonder, why rely on compiler optimizations? Why not just pass a <code>Particle</code>'s velocity or position as pointers (pass-by-reference is problematic since if the reference refers to something that's not stored in computer memory, the function has no way of verifying that) to the functions to alter their values without any copying? It turns out there are advantages to <i>stateless</i> functions, i.e., functions that, in the function body, do not alter any value outside of the function's scope. We'll describe more on these advantages later. Notice that this stateless function approach also makes the code read more like mathematical equations: one line of code updates the velocity and another line of code uses that velocity to update the position.</p>
      <p>That said, there are scenarios where return value optimization is not applied by C++ compilers. For instance, when <a target="_blank" href="https://sigcpp.github.io/2020/06/08/return-value-optimization#3-named-rvo">returning a named variable</a> or <a target="_blank" href="https://sigcpp.github.io/2020/06/08/return-value-optimization#4-compiler-limitations">returning different named objects from different code paths</a> compilers may or may not apply return value optimization by default, or at all.</p>
      <p>Here is the animation that results from this physics-based simulation of a projectile subject to the Moon's gravitational force:</p>
      <p><img src="MassParticleGravity.gif" class="centeropengl"></img></p>
			<h2 id="Mathematical_Model_of_Particles_with_Mass_Size_and_Multiple_Forces">Mathematical Model of Particles with Mass, Size, and Multiple Forces</h2>
			<p>Much of physics-based simulation follows, or tries to follow conservation laws, which we shall consider axioms of many of our mathematical models going forward. However, some of these conservation laws are actually theorems that themselves follow from <b>Noether's Theorem</b> about symmetries in space and time, but we will not go that deeply into theoretical physics in this tutorial.</p>
			<p id="rounded"><b>Axiom (Law of Conservation of Mass).</b> The total mass of a system is constant.</p>
			<p id="rounded"><b>Axiom (Law of Conservation of Linear Momentum).</b> The total linear momentum of a system is constant.</p>
			<p id="rounded"><b>Axiom (Law Conservation of Energy).</b> The total <b>energy</b> of a system is constant.</p>
			<p>We haven't defined energy here yet. In fact, its exact definition may vary from one system to another. However, conservation of mechanical energy will come in handy when we try to handle colliding particles. By "system" here we mean what is typically called a "closed system" that does not gain or lose any matter or energy. A conservation law we did not state here, since we're not using it just yet, is the law of conservation of angular momentum.</p>
			<p id="rounded"><b>Theorem (Newton's Third Law of Motion).</b> In a system consisting of two particles with mass, when the two particles collide with each other (assuming an instantaneous, elastic collision, i.e., with no loss of energy to deformation of a particle or to heat), the force applied by the first particle on the second particle (the <b>action</b> force) is equal in magnitude and opposite in direction to the force applied by the second particle on the first particle (the <b>reaction</b> force).</p>
			<p><b>Proof:</b> Let the mass of the first particle be <i>m</i><sub>1</sub>, the mass of the second particle be <i>m</i><sub>2</sub>, the velocity of the first particle before the collision be <b>u</b><sub>1</sub>, and the velocity of the second particle before the collision be <b>u</b><sub>2</sub>. Then the total momentum of the system is <i>m</i><sub>1</sub><b>u</b><sub>1</sub> + <i>m</i><sub>2</sub><b>u</b><sub>2</sub>. Let the corresponding velocities of the particles immediately after the collision be <b>u</b>'<sub>1</sub> and <b>u</b>'<sub>2</sub>. Then by the law of conservation of linear momentum, <i>m</i><sub>1</sub><b>u</b><sub>1</sub> + <i>m</i><sub>2</sub><b>u</b><sub>2</sub> = <i>m</i><sub>1</sub><b>u</b>'<sub>1</sub> + <i>m</i><sub>2</sub><b>u</b>'<sub>2</sub>. Then <i>m</i><sub>1</sub>(<b>u</b>'<sub>1</sub> - <b>u</b><sub>1</sub>) = -<i>m</i><sub>2</sub>(<b>u</b>'<sub>2</sub> - <b>u</b><sub>2</sub>). Since we're assuming this is an instantaneous (but differentiable) change in momentum, we can rewrite this equation as just <i>d</i><b>p</b><sub>1</sub>/<i>dt</i> = -<i>d</i><b>p</b><sub>2</sub>/<i>dt</i>, where <b>p</b><sub>1</sub> is the momentum of the first particle as a function of time and <b>p</b><sub>2</sub> is the momentum of the second particle. But by Newton's Second Law, instantaneous change in momentum, <b>p</b>, for any particle with velocity <b>u</b>, acceleration <b>a</b>, and mass <i>m</i>, is <i>d</i><b>p</b>/<i>dt</i> = <i>d</i>(<i>m</i><b>u</b>)/<i>dt</i> = <i>m</i><b>a</b> = <b>f</b>, where <b>f</b> is the force acting on the particle. So, <i>d</i><b>p</b><sub>1</sub>/<i>dt</i> = <b>f</b><sub>1</sub>, where <b>f</b><sub>1</sub> is the action force on the first particle, and <i>d</i><b>p</b><sub>2</sub>/<i>dt</i> = <b>f</b><sub>2</sub>, where <b>f</b><sub>2</sub> is the <i>re</i>action force on the second particle, and the above equation shows <b>f</b><sub>1</sub> = -<b>f</b><sub>2</sub>, i.e., the action and reaction are exact opposite vectors. &#9632;</p>
			<p>We'll use another related fact in our simulation.</p>
			<p id="rounded"><b>Theorem (Impulse-Momentum Theorem).</b> The change in momentum of each particle in a two-particle elastic collision scenario like that described above is equal to the integral of the force applied to the particle during the collision calculated over the time duration of the collision.</p>
			<p><b>Proof:</b> Integrate Newton's Second Law as shown <a target="_blank" href="https://en.wikipedia.org/wiki/Impulse_(physics)#Mathematical_derivation_in_the_case_of_an_object_of_constant_mass">here</a>. &#9632;</p>
			<p>In practice, we'll use this theorem to approximate an average impulse force that results from the change in momentum of a particle due to a collision that we assume will occur over the duration &Delta;<i>t</i> of the simulation for any given time step. So yes, we will assume that the collision is not really instantaneous, but rather occurs during a single time step of our simulation, which is as instantaneous as things ever really get in computer simulations.</p>
			<p>The laws of conservation of linear momentum and energy above (specifically kinetic energy in our example below which lacks gravity and thus potential energy) can be used to derive <a target="_blank" href="https://en.wikipedia.org/wiki/Elastic_collision#Two-dimensional_collision_with_two_moving_objects">formulas</a> for the change in momentum of each particle upon an elastic collision (no loss of energy or momentum) with another particle, which by the impulse force approximation mentioned above, will yield collision forces we can use to simulate a box of particles elastically colliding with each other.</p>
			<h2 id="Simulating_Colliding_Particles_with_Mass_and_Size">Simulating Colliding Particles with Mass and Size</h2>
			<p>Now we shall implement a simulation of multiple particles, without gravity involved, bouncing around inside an imaginary box whose walls are the top, bottom, left, and right walls of our viewing frustum. The particles have a nonzero radius so they behave like balls; the sphere representing each particle is no longer just a visual aid. The particles can also collide, elastically, with each other.</p>
      <p>The implementation structure builds on the previous example, but note that we had to restructure it a bit so that all forces are computed first, entirely outside of the Particle class, and only then do we update all the particle positions. Here is my code in a file called <a target="_blank" href="https://github.com/unusualinsights/phys_sim_examples/blob/main/basic/CollidingParticles.cpp"><code>CollidingParticles.cpp</code></a>.</p>
			<p>Here are the first 15 seconds or so of a version of this simulation I created earlier that starts the simulation time at exactly 0.0 seconds instead of the current time from GLUT:</p>
			<p><img src="CollidingParticles.gif" class="centeropengl"></img></p>
			<p>If you play with the parameters of this simulation like changing the masses or initial velocities or positions of the particles, you may see some weird behaviors, like a particle getting stuck slightly dangling outside the box, or one particle getting "stuck" inside another particle. If you try to damp the collisions a bit, say, by having the impulse force be 0.99 times what we compute now, you'll see other bizarre behaviors, like the wall not applying enough force to keep a particle inside the box! Simulating what should just be a simple series of elastic collisions in essentially a 2D simulation (there is a third dimension, we're just not moving anything or applying any forces in that direction) is not as simple as it may seem to get into a fully realistic state!</p>
			<p>Note the order of certain computations in the code above is important. In each time step, we must first zero out the force accumulators of each particle. Then, compute the forces on particles due to collisions with other particles and/or a wall of the viewing frustum. Once these forces have been applied to each particle, then we update the velocity followed by the position of each particle. In more complex future simulations, the order of certain computations will be important to ensure a more accurate simulation.</p>
      <h1 id="Fluid_Mechanics">Fluid Mechanics</h1>
      <p>All the simulations we implemented above used Newtonian mechanics, which describes the motion of theoretical particles that follow Newton's laws of motion. Newtonian mechanics also models the dynamics of real objects that approximately behave like particles, such as planets orbiting around the Sun. But how would we apply Newtonian mechanics to fluids, which don't really look like particles at all?</p>
      <p>It turns out, fluid mechanics is not that different from Newtonian mechanics! It's just that we have to adapt Newtonian mechanics to form a mathematical model of a fluid's properties. The key idea in Newtonian mechanics is <i>F</i> = <i>ma</i>: that is, the sum of all forces acting on a particle equals the amount of matter in the particle times the particle's acceleration. The <i>exact</i> same idea will apply to fluids!</p>
      <h2 id="Fluid_Particles">Fluid Particles</h2>
      <p>In fluid mechanics, we model fluid mathematically as a collection of "fluid particles," also known as fluid "parcels" or "volume elements." The term "parcel" makes sense when you see diagrams of fluid particles being drawn as boxes (rectangular prisms or cubes) rather than the spheres you often see for Newtonian particles. Like Newtonian particles, fluid particles are also considered to be infinitely small in theory, occupying just as much space (i.e., none) as a zero-dimensional point in <b>R</b><sup>3</sup>. However, we also assume that a fluid particle is large enough to contain enough molecules of fluid that they have properties that would normally only make sense for a finite-sized box of fluid, such as density and pressure. This might seem strange: how can a fluid particle be infinitely small, yet contain a ton of molecules of fluid? It turns out this is just a theoretical idea, but it's been shown to be an accurate enough approximation of actual fluid motion despite its strangeness. This is strangeness is called the <a target="_blank" href="https://en.wikipedia.org/wiki/Fluid_mechanics#Continuum_assumption">continuum assumption</a>, i.e., that even though we know a fluid is made up of discrete molecules, we assume a fluid is actually "continuous" in that functions of space and time like density and pressure are continuous and even differentiable, which would never be possible for any matter made up of purely discrete objects.</p>
      <h2 id="Newtons_Momentum_Equation">Newton's Momentum Equation</h2>
      <p>Fluid mechanics is really just about applying Newton's second law and the law of conservation of mass to fluid particles. Now, in theory we could try to simulate a fluid as just a bunch of Newtonian particles colliding against each other as they float through space. But, this makes it hard and inefficient to really model a fluid's behavior: after all, our computers cannot take the colliding particles simulation we did above and simply extend it to an infinite number of particles; computers only have finite memory and computing resources. Instead, we add some richness to the types of forces acting on fluid particles to upgrade them from just being Newtonian particles that only feel gravitational and collision forces. As we'll soon describe, fluid particles will still feel gravity, like Newtonian particles. Fluid particles will also feel forces due to something called <i>pressure</i> and something else called <i>viscosity</i>.</p>
      <p>A fluid particle will still be subject to Newton's second law: <b>F</b> = <i>m</i><b>a</b>. The sum of forces acting on the particle will equal its mass times its acceleration. The forces acting on fluid particles, fall into two categories: external body forces, like those Newtonian particles feel, and internal forces, which are unique to fluid particles. Also, since momentum is <b>p</b> = <i>m</i><b>v</b>, the time-derivative of momentum is <b>F</b> = <i>d</i><b>p</b>/<i>dt</i> = <i>d</i>/<i>dt</i>[<i>m</i><b>v</b>] = <i>m</i> &middot; <i>d</i><b>v</b>/<i>dt</i> = <i>m</i><b>a</b>. In other words, Newton's second law is just the time-derivative of the definition of momentum, and thus, we can think of Newton's second law as "Newton's momentum equation." You'll see soon why I mentioned this!</p>
      <p>As described in the <a target="_blank" href="https://www.cs.ubc.ca/~rbridson/fluidsimulation/">SIGGRAPH course notes</a> put together by Dr. Robert Bridson and Dr. Matthias M&uuml;ller-Fischer as well as Dr. Bridson's <a target="_blank" href="https://www.amazon.com/Simulation-Computer-Graphics-Robert-Bridson/dp/1482232839">book on fluid simulation</a>, fluid flow is modeled mathematically by two equations: the <a target="_blank" href="https://en.wikipedia.org/wiki/Navier%E2%80%93Stokes_equations">Navier-Stokes momentum equation</a> (which is just Newton's momentum equation or Newton's second law, applied to fluid particles) and the incompressibility condition (which results from the law of conservation of mass, as we'll soon see). Let's build up those equations in steps so we can really understand them.</p>
      <h2 id="Gravitational_Force">Gravitational Force</h2>
      <p>The forces acting on a fluid particle are split into two categories: external and internal. The external forces are often just gravity, but can also include things like the forces resulting from you holding a container of milk and shaking it. For our simulations in this tutorial, the only external force acting on a fluid particle will be gravitational force, which is just the particle's weight: <i>m</i><b>g</b>, where <i>m</i> is the particle's mass and <b>g</b> is acceleration due to gravity.</p>
      <h2 id="Pressure_Gradient_Force">Pressure Gradient Force</h2>
      <p>Okay, now let's focus on the internal forces. Imagine you're standing next to a bucket of water. You dip your hand into the water with your palm wide open and flat, pushing the water with your palm. When you push things like this, we say you're "applying pressure" to it. Instead, if you were to take your hand out of the water and just run your fingertip across the top of the water, swiping its surface, any slight force you feel on your skin from the water is more like a rubbing force, which we call friction, or in the case of fluids, viscosity (gooiness or stickiness), of the water. The difference between applying pressure and feeling viscosity has to do with the direction of force application on the fluid. To think of another example, if you squish an air-filled balloon, you're applying pressure to it, but if you rub the surface of the balloon against something, you're applying friction. In physics, these two orthogonal directions of applying force to materials is called "normal stress" ("normal" meaning "perpendicular" to some theoretical plane tangent to a fluid surface) and "shear stress" from rubbing or scraping parallel to a fluid surface.</p>
      <p>To describe these internal forces from pressure and viscosity, let's first assume we are given some functions of space and time to describe the fluid. Let's assume there is some function <b>u</b>(<i>x</i>, <i>y</i>, <i>z</i>, <i>t</i>) representing the velocity of the fluid at (<i>x</i>, <i>y</i>, <i>z</i>) &isin; <b>R</b><sup>3</sup> at time <i>t</i> &isin; <b>R</b>. <b>u</b> is called a vector field since it assigns a vector to each point in space. Let's assume the function <b>u</b> is at least twice differentiable in space (i.e., we can compute at least a second derivative, if not higher-order derivative, of <b>u</b> with respect to <i>x</i>, <i>y</i>, and <i>z</i>) and at least once differentiable with respect to time. Let's also assume we have a function <i>p</i>(<i>x</i>, <i>y</i>, <i>z</i>, <i>t</i>) assigning a fluid pressure to each point in space at any given time and another function <i>&rho;</i>(<i>x</i>, <i>y</i>, <i>z</i>, <i>t</i>) assigning a fluid density to each point in space at any given time. Let's assume these functions, which are "scalar fields" since they assign a real number to each point in space at any given time, are at least once-differentiable with respect to each spatial and time variable.</p>
      <p>The force a fluid particle feels due to pressure is caused by the infinitesimal <i>difference</i> in pressure around it, also known as the pressure <i>gradient</i>, &nabla;<i>p</i>, which is just the vector of spatial partial derivatives of pressure, (<i>&part;p</i>/<i>&part;x</i>, <i>&part;p</i>/<i>&part;y</i>, <i>&part;p</i>/<i>&part;z</i>). Evaluating each partial derivative at the particle's (<i>x</i>, <i>y</i>, <i>z</i>) position yields an actual 3D vector indicating the direction of most rapid increase in pressure from the particle's viewpoint. &nabla;<i>p</i> is a vector field or function, so it doesn't evaluate to a single 3D vector until you give it a specific point in space at which it shall be evaluated. As described in the <a target="_blank" href="https://www.cs.ubc.ca/~rbridson/fluidsimulation/">SIGGRAPH course notes</a> put together by Dr. Robert Bridson and Dr. Matthias M&uuml;ller-Fischer as well as Dr. Bridson's <a target="_blank" href="https://www.amazon.com/Simulation-Computer-Graphics-Robert-Bridson/dp/1482232839">book on fluid simulation</a>, the force due to a pressure gradient is always directed from high pressure to low pressure, i.e., -&nabla;<i>p</i>. Pressure in physics is defined as force per unit area, and the gradient of pressure has units of pressure per unit distance since each partial derivative is the limit of a pressure divided by a distance, so the pressure gradient has units of force per unit area per unit distance, which is force per unit volume. So, to get a force from the pressure gradient, we must multiply it by a volume in some way. Let's just pretend for now that we have a volume, <i>V</i>, for the fluid particle. Wait, isn't the volume of a particle zero? Well, yes and no, it's infinitesimal, but we'll be getting rid of this term soon, so don't worry. So, the <i>pressure gradient force</i>, the force a fluid particle feels due to fluid pressure differences, is represented by the vector field -<i>V</i>&nabla;<i>p</i>. As we shall see later, the purpose of the pressure gradient force is to help the fluid conserve its mass by conserving its volume in any given region of space. The pressure gradient force models the internal forces particles place on each other by pushing directly on each other, like the normal stress we mentioned earlier. The pressure gradient force is kind of like the human tendency to move away from a crowded area into a more open space.</p>
      <h2 id="Viscous_Force">Viscous Force</h2>
      <p>The other internal fluid force is the force due to viscosity, or viscous force, which is proportional to the <i>Laplacian</i> of the fluid velocity, which is the divergence of the gradient of the fluid velocity, &nabla; &middot; &nabla;<b>u</b>, often written as &nabla;<sup>2</sup><b>u</b>. As explained in the <a target="_blank" href="https://www.cs.ubc.ca/~rbridson/fluidsimulation/">SIGGRAPH course notes</a> put together by Dr. Robert Bridson and Dr. Matthias M&uuml;ller-Fischer as well as Dr. Bridson's <a target="_blank" href="https://www.amazon.com/Simulation-Computer-Graphics-Robert-Bridson/dp/1482232839">book on fluid simulation</a>, the Laplacian of the fluid velocity is a scalar field that measures the average velocity of the particles neighboring a given fluid particle's location. The viscous force term is typically written as <i>V&mu;</i>&nabla;<sup>2</sup><b>u</b>, with <i>V</i> again being the weird concept of particle volume and with <i>&mu;</i> being known as the <i>coefficient of dynamic viscosity</i>. This viscous force measures the force due to friction between fluid particles as they swim past each other, like the shear stress we mentioned earlier. I think of the viscous force term as the "keeping up with the Joneses" term, since viscosity is like the human tendency to keep up with your peers, but not go too much slower or too much faster than them.</p>
      <h2 id="Newtons_Second_Law_for_a_Fluid_Particle">Newton's Second Law for a Fluid Particle</h2>
      <p>So, a fluid particle's mass times its acceleration gives us the sum of the three forces we mentioned above: gravitational force, pressure gradient force, and viscous force! This gives us the equivalent of Newton's second law, or Newton's momentum equation, applied to fluids:</p>
      <p><img src="NavierStokesMomentum1.png" style="border-style: none; max-width: 400px;" class="center"></img></p>
      <p>We call this the <i>Navier-Stokes momentum equation</i>. It says that for any fluid particle in our model, its mass times its acceleration equals its weight, plus its pressure gradient force (the minus sign is because the pressure gradient vector points from low to high pressure, while the pressure gradient force pushes particles from high to low pressure), plus its viscous force. Now, we mentioned that volume is a strange quantity to apply to fluid particles. Let's divide the whole equation by the particle's mass, which we assume is strictly positive (i.e., we're not dividing by zero!), and note that density is <i>&rho;</i> = <i>m</i>/<i>V</i>, and thus <i>V</i>/<i>m</i> is 1/<i>&rho;</i>:</p>
      <p><img src="NavierStokesMomentum2.png" style="border-style: none; max-width: 350px;" class="center"></img></p>
      <p>Let's also replace <i>&mu;</i>/<i>&rho;</i> with a new symbol, known as the <i>coefficient of kinematic viscosity</i>, <i>&nu;</i> (the Greek letter "nu"):
      <p><img src="NavierStokesMomentum3.png" style="border-style: none; max-width: 350px;" class="center"></img></p>
      <h2 id="Unsteadiness_and_Advection">Unsteadiness &amp; Advection</h2>
      <p>Now, it may seem like we're done, but to actually compute fluid flow, we need fluid velocity, not acceleration. Well, that's easy, isn't acceleration just the time-derivative of velocity? Sure, but there's an important detail relating a fluid particle's acceleration to its velocity that we need to handle: the concept of <i>advection</i>. In a nutshell, advection just means "moving" and carrying some quantity with you as you move. The term actually has a more specific meaning in fluid dynamics and vector calculus. <a target="_blank" href="https://www.cs.ubc.ca/~rbridson/fluidsimulation/fluids_notes.pdf">Dr. Bridson and Dr. M&uuml;ller-Fischer's course notes</a> and <a target="_blank" href="http://www2.eng.cam.ac.uk/~mpj1001/MJ_learnfluidsmechanics.html">Dr. Matthew Juniper's fluid dynamics notes</a> both explain this really well. But here's a brief description.</p>
      <p>The temperature at any point in Earth's atmosphere can change for many reasons. On a sunny day, solar radiation from the Sun can get absorbed by the ground and then transferred to the air above it, which then increases the temperature of air at any point in that area. But then, a cold front could plow through, cooling the air at any point in that area. These are two very different mechanisms for changing the temperature at any given point in the atmosphere. The first is an external heat source causing a general increase in the temperature of all air parcels in some area, even if none of the air is moving. The second is <i>the air itself, carrying</i> cooler temperatures with it and pushing the warmer air out of the way. This second mechanism is called <i>advection</i>: it's when cooler air displaces warmer air, changing the temperature at a fixed location in space simply by air moving around. The first mechanism is called unsteadiness--a general change in the temperature field that occurs even if no air ever moved anywhere. Unsteadiness is your shirt changing color due to the lighting around you changing, while you sit perfectly still. Advection is you wearing a bright red shirt and changing the spatial distribution of redness in the world by running around with that bright attire. Unsteadiness is change of a quantity (like temperature or color) at a fixed point in space without motion; advection is change of that quantity at a fixed point in space solely due to motion.</p>
      <p>Well, any field can technically be advected, including the fluid velocity itself! You can imagine that if the water in a lake was sitting perfectly still, a boat's propeller could start spinning and push the water to change its velocity at any specific point around the propeller. This is "unsteadiness" since the fluid velocity at a specific point changed due to some external velocity-changing mechanism (the propeller in this case). On the other hand, if some fluid particles already were moving faster than others, then at a specific point in space, the overall flow of the water would carry faster particles into some areas and slower particles into other areas. This is advection: a change in the water velocity at a given point in space due simply to the fluid's own motion carrying fluid particles of various speeds around, and not because some external agent was accelerating the fluid at that point.</p>
      <p>Mathematically, we can start by just saying, acceleration is the time-derivative of the velocity of the fluid. Since fluid velocity is a function of <i>x</i>, <i>y</i>, <i>z</i>, and <i>t</i>, and since the first three of these variables are also functions of time (i.e., the coordinates of a moving fluid particle), we apply the chain rule to get that the overall derivative of fluid velocity, often referred to as the total or material derivative, <i>D</i><b>u</b>/<i>Dt</i>, is:</p>
      <p><img src="NavierStokesAdvection.png" style="border-style: none;" class="center"></img></p>
      <p>These terms are precisely what we talked about above: the first term, <i>&part;</i><b>u</b>/<i>&part;t</i>, is the <i>unsteadiness</i> term describing local changes to the fluid velocity at any point independent of the fluid's motion and the second term, <b>u</b> &middot; &nabla;<b>u</b>, is the <i>advection</i> term, describing the change of the fluid's velocity at any given point due <i>solely</i> to the fluid's motion i.e., the fluid velocity, i.e., the instantaneous change to the fluid particle's position, (<i>x</i>, <i>y</i>, <i>z</i>).</p>
      <h2 id="Final_Form_of_Navier_Stokes_Momentum_Equation">Final Form of the Navier-Stokes Momentum Equation</h2>
      <p>Replacing <b>a</b> in our most recent version of the Navier-Stokes momentum equation with this unsteadiness term plus advection term gives us the final form of the Navier-Stokes momentum equation we'll use for simulation:</p>
      <p><img src="NavierStokesMomentum4.png" style="border-style: none; max-width: 450px;" class="center"></img></p>
      <p>In computer graphics, it's common to assume zero viscosity, i.e., to remove the viscous force term from the Navier-Stokes momentum equation. That gives us the <i>inviscid</i> approximation to the Navier-Stokes momentum equation, the <i>Euler momentum equation</i>,
      <p><img src="EulerEquation.png" style="border-style: none; max-width: 350px;" class="center"></img></p>
      <p>In this tutorial, we'll stick with this inviscid approximation of the Navier-Stokes momentum equation.</p>
      <h2 id="Mass_Conservation_and_Incompressibility">Mass Conservation &amp; Incompressibility</h2>
      <p>The derivative of the fluid pressure function for a given parcel of fluid (a box-shaped particle) can be approximated to up to its first-order term in its Taylor series as <a target="_blank" href="http://www2.eng.cam.ac.uk/~mpj1001/MJ_learnfluidsmechanics.html">Dr. Matthew Juniper's fluid dynamics notes</a> explain, along with an assumption that fluid mass is conserved within any arbitrary volume of fluid (an application of the law of conservation of mass we stated earlier as a fundamental assumption of physics), to derive an equation called the <i>equation of mass continuity</i>. Alternatively, <a target="_blank" href="https://en.wikipedia.org/wiki/Fluid_dynamics#Conservation_laws">using the Divergence Theorem</a>, the same equation can be derived:
      <p><img src="MassContinuityEquation.png" style="border-style: none;" class="center"></img></p>
      <p>Following the <a target="_blank" href="https://en.wikipedia.org/wiki/Incompressible_flow#Derivation">derivation here</a>, assuming the fluid density function is constant within the infinitesimal volume of a fluid parcel that flows with the fluid, i.e., <i>D&rho;</i>/<i>Dt</i> = 0, we obtain the <i>incompressibility condition</i>:
      <p><img src="Incompressibility.png" style="border-style: none;" class="center"></img></p>
      <p>The Navier-Stokes momentum equation taken together with the incompressibility condition (which itself is just the law of mass conservation with constant material density) are often simply called the <i>Navier-Stokes equations</i>. In our case, since we're neglecting viscosity, the Euler momentum equation (the inviscid Navier-Stokes momentum equation) together with the incompressibility condition are called the <i>Euler equations</i>.</p>
      <h2 id="Splitting">Splitting</h2>
      <p>As described in <a target="_blank" href="https://www.cs.ubc.ca/~rbridson/fluidsimulation/fluids_notes.pdf">Bridson and M&uuml;ller-Fischer's SIGGRAPH 2007 course notes</a> and <a target="_blank" href="https://www.cs.ubc.ca/~rbridson/fluidsimulation/">Robert Bridson's book on fluid simulation</a>, we will use this equation to simulate a fluid by splitting it up into parts and handling each part separately. Overall, our strategy will be to start with an initial fluid velocity field, <b>u</b>(<i>x</i>, <i>y</i>, <i>z</i>, 0), that has zero divergence. We'll then keep computing new velocity fields at successive time steps, <b>u</b>(<i>x</i>, <i>y</i>, <i>z</i>, &Delta;<i>t</i>), <b>u</b>(<i>x</i>, <i>y</i>, <i>z</i>, 2&Delta;<i>t</i>), <b>u</b>(<i>x</i>, <i>y</i>, <i>z</i>, 3&Delta;<i>t</i>), etc. But note that our goal is to make sure all of these velocity fields at each of these time steps have as close to zero divergence as possible.</p>
      <p>To do this, we will follow a procedure similar to that in Section 2.2 of <a target="_blank" href="https://www.cs.ubc.ca/~rbridson/fluidsimulation/fluids_notes.pdf">Bridson and M&uuml;ller-Fischer's SIGGRAPH 2007 course notes</a>, with a few changes, such as keeping a constant time step size, &Delta;<i>t</i>. Here is our procedure:
      <ul>
        <li>Initialize the time <i>t</i> = 0.</li>
        <li>Start with a zero-divergence velocity field <b>u</b>(<i>x</i>, <i>y</i>, <i>z</i>, <i>t</i>).</li>
        <li>For the duration of the simulation:
          <ul>
            <li>Set <b>u</b> = Advect(<b>u</b>(<i>x</i>, <i>y</i>, <i>z</i>, <i>t</i>), &Delta;<i>t</i>).</li>
            <li>Set <b>u</b> += &Delta;<i>t</i><b>g</b>.</li>
            <li>Set <b>u</b> = ProjectPressure(<b>u</b>, &Delta;<i>t</i>) such that <b>u</b> has approximately zero divergence.</li>
            <li>Set <i>t</i> += &Delta;<i>t</i>.</li>
          </ul>
        </li>
      </ul>
      </p>
      <p>These steps are just adding the advection term, gravity term, and pressure gradient term to the unsteadiness term, i.e., the partial derivative of the fluid velocity with respect to time, in the inviscid Euler momentum equation.</p>
      <p>The next several sections will build up a complete implementation of a fluid simulator. First, we'll describe a data structure that stores the scalar and vector fields like pressure, density, and velocity in a digital form as a 3D staggered grid of data values covering a region of space containing our fluid(s) of interest. Then we'll explain how we exchange data from this grid to individual particles that carry position and velocity information with them. We'll then apply the steps above to contribute the effects of advection, gravity, and pressure to the fluid velocity values stored by our particles. We'll then show how we map particle data back to the staggered grid. This process will be repeated in every time step until we reach the end time of our simulation.</p>
			<h1 id="The_Staggered_Grid">The Staggered Grid</h1>
      <p>Fluid simulations involve a data structure called the <i>staggered grid</i> or the <i>marker-and-cell (MAC) grid</i>. The staggered grid separates points where we sample each of the four following values: fluid pressure and the <i>x</i>, <i>y</i>, and <i>z</i> components of fluid velocity. This will help us calculate derivatives of pressure and velocity for physics-based simulations of fluids. See <a target="_blank" href="https://www.cs.ubc.ca/~rbridson/fluidsimulation/">Robert Bridson's excellent book on fluid simulation</a> for details on the staggered grid data structure. An explanation of the staggered or MAC grid is in Section 2.4 of <a target="_blank" href="https://www.cs.ubc.ca/~rbridson/fluidsimulation/fluids_notes.pdf">Bridson and M&uuml;ller-Fischer's SIGGRAPH 2007 course notes</a>.</p>
      <h2 id="Staggered_Grid_Structure">Staggered Grid Structure</h2>
      <p>The staggered grid is a 2D or 3D grid representing the full spatial volume within which we simulate our fluid(s). We will label each grid cell of a 2D staggered grid with a row (along the <i>x</i> direction) index, <i>i</i>, and a column (along the <i>y</i> direction) index, <i>j</i>:</p>
      <p><img src="MacGrid2D.png" style="border-style: none;" class="center"></img></p>
      <p>At the center of each grid cell with indices <i>i</i> and <i>j</i>, we will store a nonnegative fluid pressure value, <i>p</i><sub><i>i</i>, <i>j</i></sub> &isin; <b>R</b>. At the center of each boundary between adjacent grid cells, we will store a component of the fluid velocity that's perpendicular to that boundary. That is, at the center of the boundary between grid cell <i>i</i>, <i>j</i> and grid cell <i>i</i> + 1, <i>j</i>, we store the horizontal component, <i>u</i><sub><i>i</i> + &frac12;, <i>j</i></sub> &isin; <b>R</b>, of the fluid's velocity at that location. At the center of the boundary between grid cell <i>i</i>, <i>j</i> and grid cell <i>i</i>, <i>j</i> + 1, we store the vertical component, <i>v</i><sub><i>i</i>, <i>j</i> + &frac12;</sub> &isin; <b>R</b>, of the fluid's velocity at that location:</p>
      <p><img src="MacGrid2D_Values.png" style="width: 75%; border-style: none;" class="center"></img></p>
      <p>We will label each grid cell of a 3D staggered grid with an index <i>i</i> along the <i>x</i> direction, index <i>j</i> along the <i>y</i> direction, and index <i>k</i> along the <i>z</i> direction:</p>
      <p><img src="MacGrid3D.png" style="border-style: none;" class="center"></img></p>
      <p>Like the 2D staggered grid, the 3D staggered grid will have a fluid pressure value, <i>p</i><sub><i>i</i>, <i>j</i>, <i>k</i></sub>, stored at the center of each grid cell with indices <i>i</i>, <i>j</i>, <i>k</i>. At the center of each boundary face between adjacent grid cells, the 3D grid will also have a component of the fluid velocity perpendicular to that boundary:</p>
      <p><img src="MacGrid3D_Values.png" style="border-style: none;" class="center"></img></p>
      <p>Note that for both the 2D and 3D staggered grids, the velocity components are <i>not</i> components of a single 2D or 3D velocity vector! Instead, we are storing different components of the fluid velocity at entirely different locations in space.</p>
      <h2 id="Storing_Staggered_Grid_Data">Storing Staggered Grid Data</h2>
      <p>We will focus on implementing the 3D staggered grid, although we'll start with a 2D grid description since it's much easier to understand the main concepts and then extend to 3D than to see the concepts for the first time in 3D. As you can see, we need to store a variety of values in some kind of 3D array.  For example, we need to store the fluid pressure for any given grid cell with indices <i>i</i>, <i>j</i>, and <i>k</i>. We also need to store the <i>u</i>, <i>v</i>, and <i>w</i> values, i.e., the <i>x</i>, <i>y</i>, and <i>z</i> components of the fluid velocity at the appropriate grid cell boundaries. We will also need to store non-real-number values, e.g., whether each grid cell contains a solid or fluid or is empty.</p>
      <p>We will begin by creating a class, <code>Array3D</code>, based on the class of the same name in <a target="_blank" href="https://cal.cs.umbc.edu/Courses/PhysicsBasedAnimation/">Bargteil and Shinar's SIGGRAPH course</a>. The <code>Array3D</code> class will be templated so we can use it to store different types of data, e.g., <code>double</code> values for real numbers like pressure and velocity and other data types for labeling grid cells as containing solid or fluid or being empty. But exactly how large should our 3D array be for each type of value? For example, the velocity components are defined at the grid cell boundaries rather than at the cells themselves and we do this weird indexing of them with "&frac12;" thrown in just to make life difficult?! Let's do a quick illustration to make sure we count this properly.</p>
      <p><img src="Array3DSketch.png" style="border-style: none;" class="center"></img></p>
      <p>Assuming we store velocities not only between grid cells but really on all faces of grid cells, i.e., including the boundary of the entire grid, we will actually end up storing differently-sized arrays for different quantities. If we define <i>n<sub>x</sub></i> as the number of columns of our grid, i.e., <i>i</i> &isin; {0, 1, ..., <i>n<sub>x</sub></i> - 1}, and define <i>n<sub>y</sub></i> as the number of rows in the grid, i.e., <i>j</i> &isin; {0, 1, ..., <i>n<sub>y</sub></i> - 1}, then it's easy to see from the diagram above of a 2D grid that the number of horizontal velocity components we store is (<i>n<sub>x</sub></i> + 1)<i>n<sub>y</sub></i> while the number of vertical velocity components we store is <i>n<sub>x</sub></i>(<i>n<sub>y</sub></i> + 1). Meanwhile, the number of pressure values we store would just be one per grid cell, i.e., <i>n<sub>x</sub>n<sub>y</sub></i>. Any array of labels we store for each grid cell would also be of that size, <i>n<sub>x</sub>n<sub>y</sub></i>.</p>
      <p>Extending this to 3D, the <i>i</i> and <i>j</i> indices have the same range as above, and with <i>n<sub>z</sub></i> representing the depth (number of grid cells in the <i>z</i> direction) of the grid, <i>k</i> &isin; {0, 1, ..., <i>n<sub>z</sub></i> - 1}. I hope I have convinced you that the 3D array of pressure values would be a <i>n<sub>x</sub></i> &#10005; <i>n<sub>y</sub></i> &#10005; <i>n<sub>z</sub></i> array. The 3D array of horizontal velocity components would be a (<i>n<sub>x</sub></i> + 1) &#10005; <i>n<sub>y</sub></i> &#10005; <i>n<sub>z</sub></i> array, the vertical components would be a <i>n<sub>x</sub></i> &#10005; (<i>n<sub>y</sub></i> + 1) &#10005; <i>n<sub>z</sub></i> array, and the depth (<i>z</i> direction) components would be a <i>n<sub>x</sub></i> &#10005; <i>n<sub>y</sub></i> &#10005; (<i>n<sub>z</sub></i> + 1) array.</p>
      <p>First, we'll create a basic 3D array class that can take on any reasonable nonnegative integer value (up to the range covered by the type <code>std::size_t</code> in C++) for each of its three dimensions. The <code>Array3D</code> class will be templated so we can store values of any data type inside it. We will start with just a constructor, an accessor ("getter") function that allows us to look up a value at a particular <i>i</i>, <i>j</i>, <i>k</i> index in the array without modifying it, and a mutator ("setter") function that does the same thing as the accessor but allows us to change the value if we want. We'll also add accessor ("getter") functions that return the dimensions, <i>n<sub>x</sub></i>, <i>n<sub>x</sub></i>, and <i>n<sub>x</sub></i> of the array. Note that all of this code will be implemented in a single header file, <a target="_blank" href="https://github.com/unusualinsights/flip_pic_examples/blob/main/incremental0/Array3D.h"><code>Array3D.h</code></a> (as is typical for templated classes, there is no associated <code>.cpp</code> file). I put this into a new subdirectory of our code called <code>incremental0</code>. The next several files of C++ code we create will also go into this same subdirectory. We could dump everything into one directory, but this way we can isolate the different stages of our code development into smaller pieces.</p>
      <p>Note we declared the copy constructor and assignment operator as private without implementing them; this prevents accidental misuse of any default copy constructor or assignment operator by any code outside of this class (e.g., code that instantiates and uses this class), reducing the chance of unintended bugs when using this class. We also require that <code>nx_</code>, <code>ny_</code>, and <code>nz_</code> are constants: they get initialized upon construction of an Array3D object and will never change during the life of the object. The object's data is deleted upon destruction. To test this class and demonstrate how to use it, we create a short file, <a target="_blank" href="https://github.com/unusualinsights/flip_pic_examples/blob/main/incremental0/Array3DTest.cpp"><code>Array3DTest.cpp</code></a>, also in the <code>incremental0</code> directory.</p>
      <p>To compile and run both <code>Array3DTest.cpp</code> and <code>Array3D.h</code>, we issue these two commands while we are in the <code>incremental0</code> directory:</p>
      <div class="outer">
        <div class="inner">
          <pre>g++ Array3DTest.cpp -o Array3DTest<br>./Array3DTest</pre>
        </div>
      </div>
      <p>This results in the following output:</p>
      <div class="outer">
        <div class="inner">
          <pre>Array is 3 x 4 x 5.<br><br>table(0, 0, 0) = 7<br>table(1, 3, 4) = 12</pre>
        </div>
      </div>
      <p>This is what we expected! We created a 3 &#10005; 4 &#10005; 5 array of integers, assigned 7 to the value at index 0, 0, 0, assigned 12 to the value at index 1, 3, 4, and then looked up the values those two indices and retrieved them, verifying that our mutator and accessor functions seem to be doing what we intended. To clean up after running this test program, I recommend:</p>
      <div class="outer">
        <div class="inner">
          <pre>rm Array3DTest</pre>
        </div>
      </div>
      <p>Let's leave the <code>Array3D</code> class implementation aside now that we have a basic functionality in place. We'll revisit how to change or add to this class as needed when we implement a fluid simulation algorithm.</p>
      <p>But how do we represent the velocity component arrays using the Array3D data structure? Array3D only accepts integer indices as inputs to its accessor and mutator functions, yet all the indices we use to refer to the velocity components in the staggered grid have &frac12; in one of the three indices? We use the convention <a target="_blank" href="https://www.cs.ubc.ca/~rbridson/fluidsimulation/">Bridson and M&uuml;ller-Fischer</a> describe (see, for example, Slide 46 of <a target="_blank" href="https://www.cs.ubc.ca/~rbridson/fluidsimulation/BasicFluids.ppt">this presentation</a>). Recall the horizontal components, <i>u</i>, of fluid velocity will be stored in a 3D array with dimensions (<i>n<sub>x</sub></i> + 1) &#10005; <i>n<sub>y</sub></i> &#10005; <i>n<sub>z</sub></i>. The 3D array for <i>u</i> values in the 3D staggered grid can have <code>u(i, j, k)</code> = <i>u</i><sub><i>i</i> - &frac12;, <i>j</i>, <i>k</i></sub>, for all values of <i>i</i> from 0 through (<i>n<sub>x</sub></i> + 1) - 1 = <i>n<sub>x</sub></i> . So, <code>u(0, 0, 0)</code> = <i>u</i><sub>-&frac12;, 0, 0</sub>, <code>u(1, 0, 0)</code> = <i>u</i><sub>&frac12;, 0, 0</sub>, and <code>u(nx, 0, 0)</code> = <i>u</i><sub><i>n<sub>x</sub></i> - &frac12;, 0, 0</sub>. Going from <i>i</i> = 0 through <i>i</i> = <i>n<sub>x</sub></i> adds up to a total of <i>n<sub>x</sub></i> + 1 cells in a row of the grid. Similarly, for all values of <i>j</i> from 0 through <i>n<sub>y</sub></i>, <code>v(i, j, k)</code> = <i>v</i><sub><i>i</i>, <i>j</i> - &frac12;, <i>k</i></sub>. And for all <i>k</i> from 0 through <i>n<sub>z</sub></i>, <code>w(i, j, k)</code> = <i>w</i><sub><i>i</i>, <i>j</i>, <i>k</i> - &frac12;</sub>. In contrast, a 3D array to store fluid pressure values will just have the same dimensions as the grid itself: for <i>i</i> ranging from 0 through <i>n<sub>x</sub></i> - 1, <i>j</i> ranging from 0 through <i>n<sub>y</sub></i> - 1, and <i>k</i> ranging from 0 through <i>n<sub>z</sub></i> - 1, <code>p(i, j, k)</code> = <i>p</i><sub><i>i</i>, <i>j</i>, <i>k</i></sub>.</p>
      <h2 id="Staggered_Grid_Data_Structure">The Staggered Grid Data Structure</h2>
      <p>Now we can put together a basic staggered grid class that contains 3D arrays, as described above, to store pressure values and velocity component values. Here are the header file, <a target="_blank" href="https://github.com/unusualinsights/flip_pic_examples/blob/main/incremental0/StaggeredGrid.h"><code>StaggeredGrid.h</code></a> and the implementation file, <a target="_blank" href="https://github.com/unusualinsights/flip_pic_examples/blob/main/incremental0/StaggeredGrid.cpp"><code>StaggeredGrid.cpp</code></a>. We also create a small test program in another file, <a target="_blank" href="https://github.com/unusualinsights/flip_pic_examples/blob/main/incremental0/StaggeredGridTest.cpp"><code>StaggeredGridTest.cpp</code></a>. All of these files are also in my <code>incremental0</code> directory.</p>
      <p>We compile this with the following command:</p>
      <div class="outer">
        <div class="inner">
          <pre>g++ StaggeredGrid.cpp StaggeredGridTest.cpp</pre>
        </div>
      </div>
      <p>Note that both the class definition file, <code>StaggeredGrid.cpp</code>, and test program file, <code>StaggeredGridTest.cpp</code>, must be compiled together. If you only compile the test program, you will get undefined reference errors because the C++ compiler won't be able to find the implementations of the constructor and destructor that are in <code>StaggeredGrid.cpp</code>. Next, run the resulting program:</p>
      <div class="outer"><div class="inner"><pre>./a.out</pre></div></div>
      <p>The output should look like:</p>
      <p id="code">Created StaggeredGrid:<br>
      - p array is 3 x 4 x 5<br>
      - u array is 4 x 4 x 5<br>
      - v array is 3 x 5 x 5<br>
      - w array is 3 x 4 x 6</p>
      <p>This matches what we expected: the original grid was 3 &#10005; 4 &#10005; 5. The horizontal velocity grid has one more horizontal component than the original grid, so it's 4 &#10005; 4 &#10005; 5. Similarly, the vertical and depth velocity grids also have exactly one dimension with one more slice than the orignal grid.</p>
      <h2 id="Grids_vs_Particles_for_Fluid_Simulation">Grids vs. Particles for Fluid Simulation</h2>
      <p>We haven't fully clarified why we use a staggered grid for fluid simulation other than something about better derivative-taking. This will get clearer as we flesh out the complete algorithm we'll be implementing for fluid simulation. Critical to our approach is using not only this staggered grid, but also particles in the spirit of what we did earlier when simulating Newtonian mechanics using spheres. What is this madness? We use particles and grids? To do what exactly?</p>
      <p>Let's back up a little more before we continue onto more details of our simulation approach. How do you use a computer to simulate the physics of fluids? As we've seen earlier, we can simulate individual particles that feel forces and bounce off of the walls of the viewing frustum and bump into each other. But, it's also common to use grids to simulate fluids--instead of individual particles, you can just keep track of fluid properties like velocity and pressure at specific, fixed points on a grid in space, and not have to track individual particles.</p>
      <p>But there are pros and cons to both particles and grids. As explained, e.g., on Page 5 of <a target="_blank" href="https://www.cs.ubc.ca/~rbridson/fluidsimulation/fluids_notes.pdf">Bridson and M&uuml;ller-Fischer's 2007 SIGGRAPH course notes</a>, the grid-based, or <i>Eulerian</i>, approach to fluid simulation is much better for calculating derivatives with respect to spatial coordinates--it's easier to calculate &Delta;<i>x</i> on a fixed grid (you know where the <i>x</i>s are at all times) than over a cloud of constantly moving particles (the <i>x</i>s keep moving all over the place). On the other hand, simulating a fluid as a bunch of individual particles (the <i>Lagrangian</i> approach) makes some things easier--Newton's laws apply directly to each particle and if each particle has a fixed mass and the number of particles stays constant during a simulation, then mass is automatically conserved.</p>
      <p>Fluid simulation, for the most part, focuses on the Eulerian (grid-based) approach rather than the Lagrangian (particle-based) approach since a fluid is often best modeled as a continuum with variables like velocity and pressure that change over time. Historically, simulating a fluid as thousands or millions or billions of particles was computationally too difficult anyway. But, since there are also some advantages to the particle-based approach, a common approach to fluid simulation these days is to mix the two approaches into a <a target="_blank" href="https://www.dgp.toronto.edu/public_user/stam/reality/Research/pdf/ns.pdf"><i>semi-Lagrangian</i> approach</a>, where you do some calculations on particles, then map values from the particles to the grid, do some calculations on the gird, and then map values from the grid back to the particles, and repeat. These simulation methods that use both particles and grids are generally called "hybrid" methods, since they blend Eulerian (grid) and Lagrangian (particle) viewpoints.</p>
      <p>The specific type of fluid simulation algorithm we'll introduce in this tutorial is called the Fluid Implicit Particle (FLIP) method. FLIP is a class of fluid simulation algorithms that resulted from early research in the mid-20th century on fluid simulation. See <a target="_blank" href="https://www.cs.ubc.ca/~rbridson/fluidsimulation/">Bridson and M&uuml;ller-Fischer's notes</a> and the associated book for more details. A very nice introduction to the trade-offs in FLIP vs. other "hybrid" particle-grid methods is given in a <a target="_blank" href="https://www.cs.ucr.edu/~shinar/papers/2019-mac-apic.pdf">paper by Ding et al. (2019)</a>.</p>
      <h1 id="Mapping_from_Particles_to_Grid">Mapping from Particles to the Grid</h1>
      <p>We'll build up the componenets of the specific implementation of FLIP presented in and provided with <a target="_blank" href="https://cal.cs.umbc.edu/Courses/PhysicsBasedAnimation/">Bargteil and Shinar's 2019 SIGGRAPH course</a> mathematically and visually first. Then we'll build up the actual C++ code to implement a modified version of the specific version of the FLIP method provided with that SIGGRAPH course.</p>
      <p>One part of our FLIP algorithm will involve transforming velocities of particles into velocity components on the staggered grid that we'll use for fluid simulation. Our velocity component 3D arrays in our staggered grid will all be zeroed out first. We'll pretend that each particle isn't really just a zero-dimensional point; rather, each particle will be like an object with some real power and influence over the grid cells around it, and we'll take each particle's velocity and <i>splat</i> (yes, that's a technical term, see <a target="_blank" href="https://developer.nvidia.com/cataclysm-flip-solver-gpu-particles">this page</a> for example) the particle velocity onto neighboring grid cells' velocity components to make our 3D arrays of velocity components then represent a sort of Eulerian "field" of fluid velocities. We'll explain later why we do this, when we do this in each time step of our simulation, later. Here I just want to highlight some minute details of the indexing and mapping process so we don't get confused trying to write the code for this part later.</p>
      <h2 id="Barycentric_Weights_of_a_Particle">Barycentric Weights of a Particle</h2>
      <p>Since a grid has to exist somewhere in space and have some fixed size for its grid cells, let's denote the location of the <i>lower corner</i> of the grid, i.e., the point with the lowest value of <i>x</i>, <i>y</i>, and <i>z</i> in the entire grid, as <i>l<sub>c</sub></i> (yes, that's a lowercase letter "ell" for "lower" and then subscript "c" for "corner"). Let's assume each grid cell is a perfect cube with all side lengths equal to some nonzero real number &Delta;<i>x</i>; yes, even in the <i>y</i> and <i>z</i> directions, not only the <i>x</i> direction.</p>
      <p><img src="GridExtent.png" style="border-style: none;" class="center"></img></p>
      <p>The figure above shows the lower corner, <i>l<sub>c</sub></i>, the upper corner, <i>u<sub>c</sub></i> (the point with the greatest <i>x</i>, <i>y</i>, and <i>z</i> coordinate values in the entire grid), and the grid spacing, &Delta;<i>x</i>. Recall that the number of grid cells in the <i>x</i> dimension is <i>n<sub>x</sub></i>, the number of cells in the <i>y</i> direction is <i>n<sub>y</sub></i>, and the number of cells in the <i>z</i> direction is <i>n<sub>z</sub></i>, so <i>u<sub>c</sub></i> = <i>l<sub>c</sub></i> + (<i>n<sub>x</sub></i> + &Delta;<i>x</i>, <i>n<sub>y</sub></i> + &Delta;<i>y</i>, <i>n<sub>z</sub></i> + &Delta;<i>x</i>).</p>
      <p>Note that <i>l<sub>c</sub></i> and <i>u<sub>c</sub></i> can be literally any two points in <b>R</b><sup>3</sup> as long as <i>u<sub>c</sub></i>'s three coordinates are greater than <i>l<sub>c</sub></i>'s respective three coordinates. But we index our grid cells using integers: <i>i</i>, <i>j</i>, and <i>k</i>. So we'll need a way to translate between the integer cell indices and the actual real-number coordinates of any location of a particle within the grid. Let's start with this question, which we'll need to answer to implement our FLIP algorithm: given an arbitrary particle <i>p</i> located at some point (<i>x</i>, <i>y</i>, <i>z</i>) in this grid, what are the indices, (<i>i</i>, <i>j</i>, <i>k</i>), of the grid cell that contains <i>p</i>, and relative to that grid cell's lower corner, how far into the grid cell in each coordinate direction is the particle's location, relative to the grid cell width?</p>
      <p>To figure that out, it's actually easier if we note that the computation of indices of a grid cell containing a particular point is independent in each coordinate direction. That is, the <i>i</i> index of the cell containing <i>p</i> is only dependent on <i>x</i> (i.e., <i>p</i>'s <i>x</i>-coordinate), <i>j</i> only depends on <i>y</i>, and <i>k</i> only depends on <i>z</i>. So, very briefly, let's just imagine we only had a one-dimensional grid: basically a finite-length interval of the real number line whose leftmost position is <i>l<sub>c</sub></i>'s <i>x</i>-coordinate and whose rightmost position is <i>u<sub>c</sub></i>'s <i>x</i>-coordinate.</p>
      <p><img src="Grid1D.png" style="border-style: none;" class="center"></img></p>
      <p>The figure above illustrates a one-dimensional (1D) grid extending from some real number <i>l<sub>c</sub></i> to another greater real number <i>u<sub>c</sub></i>. There are <i>n<sub>x</sub></i> grid cells, each with width &Delta;<i>x</i>. So <i>u<sub>c</sub></i> = <i>l<sub>c</sub></i> + <i>n<sub>x</sub></i> &middot; &Delta;<i>x</i>. If a point is strictly inside the boundaries of a grid cell, then we consider that cell to be the cell that contains it. If a point is on the boundary of a grid cell, we consider it to be in the grid cell that extends to the right of the point. So, <i>l<sub>c</sub></i> is in cell 0, <i>x</i><sub>1</sub> is in cell <i>i</i> - 1, and <i>x</i><sub>3</sub> is in cell <i>i</i>. <i>x</i><sub>2</sub> is in cell <i>i</i> since the point is on the left boundary of that cell.</p>
      <p>So if the only known values are <i>l<sub>c</sub></i>, &Delta;<i>x</i>, and <i>n<sub>x</sub></i>, then if we are given a particular point <i>x</i>, how can we determine which grid cell contains <i>x</i>? Here is our procedure:
      <ol>
        <li>Subtract the lower bound, <i>l<sub>c</sub></i>, from the point's value, <i>x</i>, to get the 1D vector displacement, <i>x</i>' = <i>x</i> - <i>l<sub>c</sub></i>, of the point relative to the grid's lower corner.</li>
        <li>Determine how many "grid cell displacements" it takes to get to the grid that contains the point <i>x</i> from the lower corner <i>l<sub>c</sub></i>. This is just &lfloor; <i>x</i>' / &Delta;<i>x</i> &rfloor;. That is, the floor of (greatest integer less than or equal to) <i>x</i>' / &Delta;<i>x</i>, or equivalently, the result of dividing the displacement <i>x</i>' by &Delta;<i>x</i> and throwing away the remainder. This is, in fact, just the index <i>i</i> of the grid containing <i>x</i>. So, <i>i</i> = &lfloor; <i>x</i>' / &Delta;<i>x</i> &rfloor;. Plug in some known values to verify. For example, if <i>x</i> = <i>l<sub>c</sub></i>, then <i>x</i>' / &Delta;<i>x</i> = (<i>x</i> - <i>l<sub>c</sub></i>) / &Delta;<i>x</i> = (<i>l<sub>c</sub></i> - <i>l<sub>c</sub></i>) / &Delta;<i>x</i> = 0, the floor of which is 0, the correct index of the cell containing <i>l<sub>c</sub></i>. If <i>x</i> = <i>l<sub>c</sub></i> + &Delta;<i>x</i>/2, then <i>i</i> = <i>x</i>' / &Delta;<i>x</i> = (<i>x</i> - <i>l<sub>c</sub></i>) / &Delta;<i>x</i> = (&Delta;<i>x</i> / 2) / &Delta;<i>x</i> = &frac12;, the floor of which is also 0, the correct index of the cell containing the point. You can plug in values of <i>x</i> like <i>l<sub>c</sub></i> + &Delta;<i>x</i>, <i>l<sub>c</sub></i> + 3&Delta;<i>x</i>/2, and so on, to convince yourself that this calculation works for all possible values of <i>x</i> within our 1D grid. For now we'll ignore the fact that <i>u<sub>c</sub></i> would, by this scheme, end up in some nonexistent grid cell with index <i>n<sub>x</sub></i>.</li>
      </ol>
      </p>
      <p>Once we've determined which grid cell contains <i>x</i>, the second part of our question was, how do we characterize how far into that grid cell <i>x</i> is, relative to the width of a grid cell? Note that the left end of the grid cell with index <i>i</i> is just <i>l<sub>c</sub></i> + <i>i</i> &middot; &Delta;<i>x</i>. The displacement from that point to the right end of the grid cell is just another &Delta;<i>x</i> to the right. Okay. So if we were exactly at the midpoint of grid cell <i>i</i>, then we'd be at the point <i>x</i> = <i>l<sub>c</sub></i> + <i>i</i> &middot; &Delta;<i>x</i> + &Delta;<i>x</i> / 2. If we were only one-fourth of the way into grid cell <i>i</i> from the cell's left boundary, we'd be at the point <i>x</i> = <i>l<sub>c</sub></i> + <i>i</i> &middot; &Delta;<i>x</i> + &Delta;<i>x</i> / 4. If we were three-fourths of the way into the grid cell, we'd be at <i>x</i> = <i>l<sub>c</sub></i> + <i>i</i> &middot; &Delta;<i>x</i> + 3 &Delta;<i>x</i> / 4. So, the overall pattern, then, is that if we are a fraction <i>w</i><sub>0</sub> into grid cell <i>i</i>, then we are at <i>x</i> = <i>l<sub>c</sub></i> + <i>i</i> &middot; &Delta;<i>x</i> + <i>w</i><sub>0</sub> &middot; &Delta;<i>x</i>. We call <i>w</i><sub>0</sub> = (<i>x</i> - <i>l<sub>c</sub></i> - <i>i</i> &middot; &Delta;<i>x</i>) / &Delta;<i>x</i> the <i>barycentric weight</i>, or just the <i>weight</i> for short, of the point <i>x</i> in the grid cell <i>i</i>. This is illustrated in the figure below.</p>
      <p><img src="Grid1DWeight.png" style="border-style: none;" class="center"></img></p>
      <p>I know that probably seemed unnecessarily wordy, but it's important to get the details right, avoiding off-by-one errors, etc., and it's easier to make sure we're doing that right in one dimension than in multiple dimensions. We can actually think of what we just did as a transformation from Cartesian coordinates, <i>x</i>, to an index and barycentric coordinate pair, (<i>i</i>, <i>w</i><sub>0</sub>) = (&lfloor;<i>x</i> - <i>l<sub>c</sub></i>&rfloor; / &Delta;<i>x</i>, (<i>x</i> - <i>l<sub>c</sub></i> - <i>i</i> &middot; &Delta;<i>x</i>) / &Delta;<i>x</i>) = (&lfloor;<i>x</i>'&rfloor; / &Delta;<i>x</i>, (<i>x</i>' - <i>i</i> &Delta;<i>x</i>) / &Delta;<i>x</i>) = (&lfloor;<i>x</i>'&rfloor; / &Delta;<i>x</i>, <i>x</i>' / &Delta;<i>x</i> - <i>i</i>). Now, let's extend this quickly to two dimensions.</p>
      <p>Let's now extend this to two dimensions. Knowing that all the math works out identically for <i>x</i> and <i>y</i> coordinates, we can derive our transformation from Cartesian coordinates of a particle's 2D position, (<i>x</i>, <i>y</i>), to its cell indices (<i>i</i>, <i>j</i>), and barycentric weights, (<i>w</i><sub>0</sub>, <i>w</i><sub>1</sub>). Let's first subtract <i>l<sub>c</sub></i>'s coordinates (note <i>l<sub>c</sub></i> is now a point in <b>R</b><sup>2</sup> with 2 coordinates, not just a single real number) from the particle's 2D position to get the particle's displacement relative to <i>l<sub>c</sub></i>, which we'll denote as (<i>x</i>', <i>y</i>') = (<i>x</i>, <i>y</i>) - <i>l<sub>c</sub></i>. Then <i>i</i> = &lfloor;<i>x</i>'&rfloor; / &Delta;<i>x</i>. Similarly, <i>j</i> = &lfloor;<i>y</i>'&rfloor; / &Delta;<i>x</i>. As before, <i>w</i><sub>0</sub> = <i>x</i>' / &Delta;<i>x</i> - <i>i</i>. Similarly, <i>w</i><sub>1</sub> = <i>y</i>' / &Delta;<i>x</i> - <i>j</i>. This is illustrated in the figure below.</p>
      <p><img src="Grid2DIndicesWeights.png" style="border-style: none;" class="center"></img></p>
      <p>Now going all the way to three dimensions, a particle at (<i>x</i>, <i>y</i>, <i>z</i>), or relative to the lower corner of the grid, (<i>x</i>', <i>y</i>', <i>z</i>') = (<i>x</i>, <i>y</i>, <i>z</i>) - <i>l<sub>c</sub></i>, will have indices
      <ul>
        <li><i>i</i> = &lfloor;<i>x</i>'&rfloor; / &Delta;<i>x</i></li>
        <li><i>j</i> = &lfloor;<i>y</i>'&rfloor; / &Delta;<i>x</i></li>
        <li><i>k</i> = &lfloor;<i>z</i>'&rfloor; / &Delta;<i>x</i></li>
      </ul>
      and barycentric weights
      <ul>
        <li><i>w</i><sub>0</sub> = <i>x</i>' / &Delta;<i>x</i> - <i>i</i></li>
        <li><i>w</i><sub>1</sub> = <i>y</i>' / &Delta;<i>x</i> - <i>j</i></li>
        <li><i>w</i><sub>2</sub> = <i>z</i>' / &Delta;<i>x</i> - <i>k</i>.</li>
      </ul>
      </p>
      <p>This is illustrated in the figure below. This is the set of calculations we'll use for our fluid simulation algorithm since we are mostly interested in simulating fluids in 3D, not 2D or 1D.</p>
      <p><img src="Grid3DIndicesWeights.png" style="border-style: none;" class="center"></img></p>
      <p>Note that we can think of this as a breakdown of a point's position as starting from the lower corner, <i>l<sub>c</sub></i>, translating by (<i>i</i> &middot; &Delta;<i>x</i>, <i>j</i> &middot; &Delta;<i>x</i>, <i>k</i> &middot; &Delta;<i>x</i>), and then translating once more by (<i>w</i><sub>0</sub> &middot; &Delta;<i>x</i>, <i>w</i><sub>1</sub> &middot; &Delta;<i>x</i>, <i>w</i><sub>2</sub> &middot; &Delta;<i>x</i>) to get to a particle's position, (<i>x</i>, <i>y</i>, <i>z</i>). We can even think of this as follows: if we translate the entire grid so that the lower corner, <i>l<sub>c</sub></i> ends up at the origin and then scale the entire grid so that &Delta;<i>x</i> becomes 1, then the actual coordinates of the point (<i>x</i>, <i>y</i>, <i>z</i>) become (<i>i</i> + <i>w</i><sub>0</sub>, <i>j</i> + <i>w</i><sub>1</sub>, <i>k</i> + <i>w</i><sub>2</sub>)!</p>
      <p>Note that &Delta;<i>x</i> is technically just a positive real number, but sometimes when we label a vector with it like in the figure above, we're imagining it representing a vector with a length equal to what the label says, pointing in the direction of that arrow.</p>
      <p>Let's now implement two functions: one to compute <i>i</i>, <i>j</i>, and <i>k</i> for a given particle position and another to compute the barycentric weights, <i>w</i><sub>0</sub>, <i>w</i><sub>1</sub>, and <i>w</i><sub>2</sub>. Let's call the first function <code>floor</code> following Bargteil and Shinar's code. The function will take as input a point, (<i>x</i>, <i>y</i>, <i>z</i>), a lower corner point, <i>l<sub>c</sub></i> = (<i>x<sub>l<sub>c</sub></sub></i>, <i>y<sub>l<sub>c</sub></sub></i>, <i>z<sub>l<sub>c</sub></sub></i>), and a grid cell width, &Delta;<i>x</i>, and return three integers, <i>i</i>, <i>j</i>, and <i>k</i>, indicating the indices of the grid cell containing that particle, according to the calculations shown earlier. But wait! How are we going to represent all this data in C++? How will we return 3 integers from a function all at the same time?</p>
      <p>Our grid spacing (grid cell width) parameter, &Delta;<i>x</i>, can just be a <code>double</code> as in Bargteil and Shinar's code. But how will we represent the two 3D point parameters, (<i>x</i>, <i>y</i>, <i>z</i>) and (<i>x<sub>l<sub>c</sub></sub></i>, <i>y<sub>l<sub>c</sub></sub></i>, <i>z<sub>l<sub>c</sub></sub></i>)? Well, we could create our own 3D point data type, or, we could just use the Eigen library, as Bargteil and Shinar's code does. While we attempt to minimize the number of external libraries we insert into this tutorial's code, Eigen is so standard in graphics and physics-based computing that importing it is really not a burden. And it's very easy to install and use. Not to mention, it has some performance advantages, such as <a target="_blank" href="https://eigen.tuxfamily.org/dox/TopicLazyEvaluation.html">lazy evaluation</a>, where it does as much manipulation of algebraic expressions involving vectors and matrices at compile time as it can, minimizing the amount of computation done at run time.</p>
      <p>To install Eigen, if you haven't already, run this command in a terminal:</p>
      <div class="outer">
        <div class="inner">
          <pre>sudo apt install libeigen3-dev</pre>
        </div>
      </div>
      <p>Then type this command to figure out where Eigen was installed:</p>
      <div class="outer">
        <div class="inner">
          <pre>whereis eigen3</pre>
        </div>
      </div>
      <p>For me, this command returned <code>/usr/include/eigen3</code>. Remember this or write it down somewhere, since we will use this path to compile any code that uses Eigen.</p>
      <p>Let's also answer the other question from earlier: how will we return three integers from a function all at the same time? Well, we could just pass the integers in by reference and let the function modify them in order to "return" them without really returning them. However, this has some issues as we shall see soon. Here's one way to implement this function a not-so-great way, in a complete program with a <code>main()</code> function for some quick sanity-checking of our code's correctness, in a file I called <a target="_blank" href="https://github.com/unusualinsights/flip_pic_examples/blob/main/incremental0/GridIndexing_Bad.cpp"><code>GridIndexing_Bad.cpp</code></a>, still in our <code>incremental0</code> directory.</p>
      <p>Note we just used casting to integers to do the "floor" operation of finding the largest integer less than or equal to a given double-precision number. This works when the value is known to be positive, as is the case for us here (it wouldn't work that way for negative numbers, though!). Compile this code with this command, which includes the Eigen path noted above, and doesn't unnecessarily include the OpenGL library stuff since we're just doing a simple math operation using vectors:</p>
      <div class="outer">
        <div class="inner">
          <pre>g++ GridIndexing_Bad.cpp -o GridIndexing_Bad -I/usr/include/eigen3/</pre>
        </div>
      </div>
      <p>Run the code with:</p>
      <div class="outer">
        <div class="inner">
          <pre>./GridIndexing_Bad</pre>
        </div>
      </div>
      <p>Here's the output:</p>
      <div class="outer">
        <div class="inner">
          <pre>i = 2, j = 1, k = 0
i = 3, j = 8, k = 9
i = -1, j = 0, k = 0</pre>
        </div>
      </div>
      <p>There are several issues with this implementation. First, you may notice that last call to <code>floor</code> results in a negative index, which makes no sense! Also, what if <code>dx</code>, i.e., &Delta;<i>x</i>, had been zero, or negative? There's nothing in the code preventing that from happening! Also, doesn't it seem weird that we use some special data type, <code>Eigen::Vector3d</code>, to handle a 3D vector of <code>double</code>s, but we just use three separate integer variables to handle essentially a 3D vector if <code>int</code>s?</p>
      <p>The <code>floor</code> function has an issue which is often not considered a problem by many: it is stateful, meaning it takes in some variables from outside its scope and alters them. Instead, <a target="_blank" href="https://medium.com/@brooknovak/benefits-of-writing-stateless-code-with-7-essential-tips-on-how-to-write-stateless-c-ee4a26e9f356">stateless functions</a> (e.g., that simply take in parameters and return other values, acting in total isolation from all other code) are preferable to stateful ones (e.g., functions that take in references or pointers to variables and then modify them) for a variety of reasons. And in C++, we usually don't have to worry about extra copies of returned objects slowing down our code since a standard optimization C++ compilers use is <a target="_blank" href="https://en.wikipedia.org/wiki/Copy_elision">return value optimization</a>. So, let's create a simple data structure representing a triplet of nonnegative integers, (<i>i</i>, <i>j</i>, <i>k</i>), and have the value returned by our <code>floor</code> function be an instance of that data type.</p>
      <p>So, we can make some improvements to our code in a new file, <a target="_blank" href="https://github.com/unusualinsights/flip_pic_examples/blob/main/incremental0/GridIndexing.cpp"><code>GridIndexing.cpp</code></a> in our <code>incremental0</code> directory.</p>
      <p>Compile and run your code the same way, but without the <code>_Bad</code> suffix because well, now our code is not as bad, apparently. Note we're not actually compiling our code using compiler optimizations yet. We'll do that later when we get to some heavier computation. The program should output some text and then crash on an assertion failure since it, correctly, disallows negative indices:</p>
      <div class="outer">
        <div class="inner">
          <pre>Indices: 
2
1
0
Indices: 
3
8
9
GridIndexing: GridIndexing.cpp:33: GridIndices floor(const Vector3d&amp;, const Vector3d&amp;, double): Assertion `p_lc_over_dx[0] &gt;= 0.0' failed.
Aborted (core dumped)</pre>
        </div>
      </div>
      <p>Now that we've finished computing the index of the grid cell that contains any given particle position, let's work on implementing the function to compute the barycentric weights of a given point. To determine the weights of a particular particle position, as we saw above, we do need to know which cell contains it. The <code>floor</code> function we just implemented does exactly that. Let's use the indices returned by the <code>floor</code> function as inputs into our barycentric weight calculator function, which we'll call <code>weights</code>, following Bargteil and Shinar's code. Let's again make the function stateless, which is a bit different from their implementation. So, the function will have as input the particle position, the grid's lower corner point, the grid spacing, and the indices of the cell containing the particle's position. The value we return this time will be a 3D vector of <code>double</code>s, which are the barycentric weights of the particle position's in that cell.</p>
      <p>Notice here that we'll be repeating some calculations here, like the subtraction of the particle's position by the grid's lower corner position and division of all of that by the grid spacing. But we'll deal with that inefficiency later when we get to a more complete program; for now, let's implement this function with the parameters we described above, in a little test program called <a target="_blank" href="https://github.com/unusualinsights/flip_pic_examples/blob/main/incremental0/GridWeights.cpp"><code>GridWeights.cpp</code></a>, still in the <code>incremental0</code> directory.</p>
      <p>Compile and run this code the same way we did with the last two files. The output is:</p>
      <div class="outer">
        <div class="inner">
          <pre>Indices: 
0
3
4
Weights = 
0.5
  0
0.5

Indices: 
 3
 4
16
Weights = 
0.5
0.5
  0

Indices: 
0
0
0
Weights = 
0
0
0
          </pre>
        </div>
      </div>
      <p>That completes our work on the theory and implementation of the grid cell index and barycentric weight computation!</p>
      <p>Notice we declared the <code>floor</code> and <code>weights</code> functions as <code>inline</code>, as in Bargteil and Shinar's code. This isn't necessary to do for these little test programs, but does promote efficiency in larger programs by making the compiler do the work of basically replacing any call to these functions with the actual code inside the functions to avoid an extra function call being stacked onto the call stack of our running programs.</p>
      <h2 id="Splatting_Particle_Velocities_onto_Grid_in_2D">Splatting Particle Velocities onto the Grid in 2D</h2>
      <p>Now that we know how to break down a particle's position into its grid cell's indices and the barycentric weights of its location within the grid cell, let's look at one important step of the FLIP algorithm: <i>splatting</i> the particle's velocity onto nearby grid velocity components. What is splatting and why do we do it?</p>
      <p>As we mentioned earlier, in hybrid fluid simulation algorithms that use both particles and grids, we will repeatedly map from particles to the grid and from the grid back to the particles. Splatting is the process of mapping from the particles to the grid. In this case we will just focus on splatting particle velocities onto the velocity components of nearby cells in a staggered grid.</p>
      <p>Since there will be a lot of gymnastics involving indices in the splatting process, we will go through it carefully. It can get really confusing to just look at the algorithm or implementation, without much explanation, as it is full of <i>w</i>s and indices with +1s and -1s all over the place. A lot of conceptual detail is actually hidden by the implementation of splatting in code form, so we'll break it down here and then build up the implementation in C++ after completing our understanding of the algorithm mathematically.</p>
      <p>The general idea of splatting is that every particle has some influence over not only the grid cell it is currently in, but also potentially some neighboring grid cells. We get to define exactly how much influence the particle has over the velocity components of neighboring grid cells and how big that neighborhood even is. The figure below illustrates this very general idea. It's formalizing the idea of popping a water balloon and watching the water go <i>splat!</i>, making a huge mess all over the unfortunate grid cells near it.</p>
      <p><img src="ParticleRegionInfluence.png" style="width: 75%; border-style: none;" class="center"></img></p>
      <p>We'll build up the splatting algorithm used in the FLIP code provided with <a target="_blank" href="https://cal.cs.umbc.edu/Courses/PhysicsBasedAnimation/">Bargteil and Shinar's SIGGRAPH course</a>. The code defines the region of influence of a particle as follows. First, draw an imaginary grid cell around the particle's current location. Second, determine which actual grid cells' interiors overlap with that imaginary grid cell. Those are the grid cells whose velocities will be updated based on the particle's velocity. As we'll see later, the change to each velocity vector will be proportional to the amount of overlap between the imaginary grid cell of the particle and the portion of the actual grid cell that borders that velocity vector's location.</p>
      <p>Let's start by examining a one-dimensional example of one part of the splatting algorithm. To determine the grid cells that overlap an imaginary grid cell centered on a particular particle, we do a negative shift by half a grid cell width from a particle's position; this would be the lower (left) end of the imaginary grid cell centered on the particle. The figure below illustrates this.</p>
      <p><img src="HalfShift1D.gif" style="border-style: none;" class="center"></img></p>
      <p>The shift works like this: subtract &Delta;<i>x</i>/2 from the particle's location, <i>x</i>, and note in which cell you end up. You can convince yourself that if <i>x</i> is less than halfway into grid cell <i>i</i>, then <i>x</i> - &Delta;<i>x</i>/2 will be in grid cell <i>i</i> - 1. If <i>x</i> is halfway or more into grid cell <i>i</i>, then shifting it left by a half-grid-cell-width (&Delta;<i>x</i>/2) will keep it within grid cell <i>i</i>. Note that if <i>x</i> is exactly halfway into grid cell <i>i</i>, then shifting it left by half a grid cell width lands it exactly at the left end of grid cell <i>i</i>, which we still consider to be in grid cell <i>i</i> and not <i>i</i> - 1. Another way of saying this is, if the barycentric weight, <i>w</i><sub>0</sub> of <i>x</i> in grid cell <i>i</i> is less than &frac12;, then the left shift will land you in grid cell <i>i</i> - 1, while otherwise the left shift will keep you in grid cell <i>i</i>.</p>
      <p>Now, let's examine a more comprehensive version of a 2D version of the splatting algorithm (the final algorithm we'll implement is only in 3D, but some aspects are easier to visualize in 2D first), which will include not only a negative half-grid-cell-width shift, but also some contributions from a particle's velocity to velocity components of grid cells within the particle's region of influence.</p>
      <p>Let <i>p</i> be a particle at position (<i>x</i>, <i>y</i>) in a 2D staggered grid. Assume (<i>x</i>, <i>y</i>) is in the <i>bottom half</i> of cell (<i>i</i>, <i>j</i>). (Later, we'll look at the top half case.) Here is a diagram of this particle in the bottom half of its grid:</p>
      <p><img src="Particle2DBottomHalf.png" style="border-style: none;" class="center"></img></p>
      <p>The 2D simplified version of our splatting algorithm works like this. First, shift down half a grid cell width from the particle's position to get a new position, (<i>x</i>, <i>y</i> - &Delta;<i>x</i> / 2), which is located in the cell below (<i>i</i>, <i>j</i>), which is cell (<i>i</i>, <i>j</i> - 1):</p>
      <p><img src="Particle2DBottomHalfShiftDown.png" style="border-style: none;" class="center"></img></p>
      <p>Next, compute the barycentric weights, <i>w</i><sub>0</sub> and <i>w</i><sub>1</sub>, of that point in cell (<i>i</i>, <i>j</i> - 1):</p>
      <p><img src="Particle2DBottomHalfWeights.png" style="border-style: none;" class="center"></img></p>
      <p>We will use those weights to <i>splat</i>, or contribute, weighted versions of the particle's own velocity, <i>u<sub>p</sub></i>, to the horizontal velocity components on either side of grid cells (<i>i</i>, <i>j</i> - 1) and (<i>i</i>, <i>j</i>). Here are those velocity components of those two grid cells, <i>before</i> splatting:</p>
      <p><img src="Particle2DBottomHalfVelocities.png" style="border-style: none;" class="center"></img></p>
      <p>Finally, here is how the splatting works. We add (1 - <i>w</i><sub>0</sub>)(1 - <i>w</i><sub>1</sub>)<i>u<sub>p</sub></i> to the left velocity component of grid cell (<i>i</i>, <i>j</i> - 1). We add <i>w</i><sub>0</sub>(1 - <i>w</i><sub>1</sub>)<i>u<sub>p</sub></i> to the right velocity component of the same cell. For cell (<i>i</i>, <i>j</i>), we add (1 - <i>w</i><sub>0</sub>)<i>w</i><sub>1</sub><i>u<sub>p</sub></i> to the left velocity component and <i>w</i><sub>0</sub><i>w</i><sub>1</sub><i>u<sub>p</sub></i> to the right velocity component:</p>
      <p><img src="Particle2DBottomHalfSplat.png" style="border-style: none;" class="center"></img></p>
      <p>The figure above reveals how we define the "neighborhood" of the particle, i.e., the region of the grid where fluid velocities are influenced by this particle's velocity. Let's also try to get a little more intuition on what the weights are doing for us here. Notice that if the particle had been a bit more to the left (but still in the same cell), then <i>w</i><sub>0</sub> would have been smaller. That would mean (1 - <i>w</i><sub>0</sub>) would have been bigger. But that, in turn, would mean the particle's velocity would have contributed more strongly to the left velocity components of grid cells (<i>i</i>, <i>j</i> - 1) and (<i>i</i>, <i>j</i>), since those velocity component contributions are multiplied by (1 - <i>w</i><sub>0</sub>). So, if the particle is more toward the left side of a grid cell, it contributes more to the left-side velocity components of its neighboring grid cells. That seems reasonable, right?</p>
      <p>How does this work for the right-side velocity components? Well, if the particle is further to the right side of its grid cell, then <i>w</i><sub>0</sub> is bigger, which means the particle's velocity contributes more to the right-side velocity components of the same grid cells since those contributions are multiplied by <i>w</i><sub>0</sub>.</p>
      <p>What about the vertical weight, <i>w</i><sub>1</sub>? Well, the same reasoning applies. The lower the particle's position, the smaller <i>w</i><sub>1</sub> for its downward-shifted position would be. The smaller <i>w</i><sub>1</sub> is, the bigger (1 - <i>w</i><sub>1</sub>) is, so the more the particle's velocity contributes to grid cell (<i>i</i>, <i>j</i> - 1)'s left and right velocity components (since they are multiplied by (1 - <i>w</i><sub>1</sub>). On the other hand, the higher the particle is, the greater <i>w</i><sub>1</sub> is, so the more the particle's velocity contributes to grid cell (<i>i</i>, <i>j</i>)'s left and right velocity components (since they are multiplied by <i>w</i><sub>1</sub>).</p>
      <p>In fact, </p>
      <p>Here is an animated version of this whole process:</p>
      <p><img src="ShiftDownDiffCell2D.gif" style="border-style: none;" class="center"></img></p>
      <p>That's it for the case where the particle is in the bottom half of its grid cell! Now, let's examine how the same process works when the particle is in the top half of its grid cell, or, exactly in the middle vertically in its grid cell (we consider both to be the same case, just as we did with the 1D shifting example above).</p>
      <p>So, how does this process work when a particle is in the <i>top</i> half of its grid cell? Well, since we start higher up in the grid cell, ...</p>
      <p><img src="Particle2DTopHalf.png" style="border-style: none;" class="center"></img></p>
      <p>... we end up remaining in that grid cell even when we shift down by half a grid cell width:</p>
      <p><img src="Particle2DTopHalfShiftDown.png" style="border-style: none;" class="center"></img></p>
      <p>Next, we compute the barycentric weights, just like before, but relative to the cell the shifted location is in, which is the original cell (<i>i</i>, <i>j</i>), unlike in the bottom-half case above:</p>
      <p><img src="Particle2DTopHalfWeights.png" style="border-style: none;" class="center"></img></p>
      <p>We will splat the particle's velocity onto its four neighboring velocities, as before. But unlike the bottom-half case above, we will splat the particle velocity onto the horizontal velocity components of grid cells (<i>i</i>, <i>j</i>) and (<i>i</i>, <i>j</i> + 1)! Technically we're still following the same process as before; it's just that since the downward-shifted position from the particle's position remained within the particle's grid cell, the shifted point's cell and the cell above it just happen to be a different pair of cells:</p>
      <p><img src="Particle2DTopHalfVelocities.png" style="border-style: none;" class="center"></img></p>
      <p>The splatting process works identically to before, but again, just on this higher pair of grid cells:</p>
      <p><img src="Particle2DTopHalfSplat.png" style="border-style: none;" class="center"></img></p>
      <p>Finally, here's an animated version of this whole process for the case where the particle is in the top half of its grid cell:</p>
      <p><img src="ShiftDownSameCell2D.gif" style="border-style: none;" class="center"></img></p>
      <p>Note that we can think of this process as transferring velocities from particles to <i>every</i> velocity on the grid; it's just that the contribution of the particle's velocity to the grid velocity components other than these four neighboring velocity components is zero.</p>
      <p>Now, all of that gymnastics was just for splatting the horizontal velocity of the particle onto horizontal velocity components on the grid. We also have to do the same thing for the vertical components! Without going through the same level of very repetitive detail, I'll just say the process works identically in that direction; you just do a left shift by half a grid cell width instead of a downward shift, and repeat the same process.</p>
      <p>But what exactly is this all doing? Why do we use the weights in this particular way? Is there any more insight we can get into the method behind the madness?</p>
      <p>Well, it turns out that if you draw an imaginary grid cell centered on each of the four velocity components that get updated, and another imaginary grid cell centered on the particle's position, the fraction of the particle's velocity that each of the grid velocity components gets is exactly equal to the proportion of area overlap between the particle-centered grid cell and each velocity-centered grid cell. What?! Let's describe that a bit more slowly with pictures.</p>
      <p>First, recall that we start with a particle position:</p>
      <p><img src="AreaInterp1.png" style="border-style: none;" class="center"></img></p>
      <p>And then we shift downward by half a grid cell width and compute the barycentric weights of the resulting position in whatever cell you land:</p>
      <p><img src="AreaInterp2.png" style="border-style: none;" class="center"></img></p>
      <p>Recall that for this case, where the particle is in the top half of its grid cell, the four horizontal velocity components it'll influence are the ones next to that cell and the cell above it:</p>
      <p><img src="AreaInterp3.png" style="border-style: none;" class="center"></img></p>
      <p>Now, draw imaginary grid cells centered at the locations of those four velocity components:</p>
      <p><img src="AreaInterp4.png" style="border-style: none;" class="center"></img></p>
      <p>Then draw an imaginary grid cell centered on the particle's position:</p>
      <p><img src="AreaInterp5.png" style="border-style: none;" class="center"></img></p>
      <p>What is the area of overlap between the particle's imaginary grid cell and each of the velocity components' grid cells?</p>
      <p><img src="AreaInterp6.png" style="border-style: none;" class="center"></img></p>
      <p>To help us calculate these areas, let's define a few horizontal vectors:</p>
      <p><img src="AreaInterp7.png" style="border-style: none;" class="center"></img></p>
      <p>And a few vertical ones:</p>
      <p><img src="AreaInterp8.png" style="border-style: none;" class="center"></img></p>
      <p>Note that by the definition of the downward shift process, we can reach the particle's position by starting at the lower corner of the grid cell into which we shifted, going right by <i>w</i><sub>0</sub> &middot; &Delta;<i>x</i>, going up by <i>w</i><sub>1</sub> &middot; &Delta;<i>x</i>, and then going up by &frac12;&Delta;<i>x</i>:</p>
      <p><img src="AreaInterp9.png" style="border-style: none;" class="center"></img></p>
      <p>Then, you can reach the lower left corner of the particle-centered imaginary grid cell by going down by &frac12;&Delta;<i>x</i> and then left by &frac12;&Delta;<i>x</i>:
      <p><img src="AreaInterp10.png" style="border-style: none;" class="center"></img></p>
      <p>Then you can reach the other corners by going up by &Delta;<i>x</i>:</p>
      <p><img src="AreaInterp11.png" style="border-style: none;" class="center"></img></p>
      <p>Right by &Delta;<i>x</i>:</p>
      <p><img src="AreaInterp12.png" style="border-style: none;" class="center"></img></p>
      <p>And right from the lower left corner by &Delta;<i>x</i>:</p>
      <p><img src="AreaInterp13.png" style="border-style: none;" class="center"></img></p>
      <p>We can reach the point at the top of this grid cell and halfway across by starting at the lower left corner of the grid cell, going right by &frac12;&Delta;<i>x</i> and up by &Delta;<i>x</i>:</p>
      <p><img src="AreaInterp14.png" style="border-style: none;" class="center"></img></p>
      <p>Doing a little vector algebra, e.g., subtracting that last point by the top left corner of the particle-centered imaginary grid cell, we see that the rectangle whose diagonally opposite corners are those two points is a (1 - <i>w</i><sub>0</sub>) &#10005; <i>w</i><sub>1</sub> rectangle:</p>
      <p><img src="AreaInterp15.png" style="border-style: none;" class="center"></img></p>
      <p>So its area is (1 - <i>w</i><sub>0</sub>)<i>w</i><sub>1</sub>(&Delta;<i>x</i>)<sup>2</sup>:</p>
      <p><img src="AreaInterp16.png" style="border-style: none;" class="center"></img></p>
      <p>Similar vector algebra will reveal that the area of the top right rectangle of overlap is <i>w</i><sub>0</sub><i>w</i><sub>1</sub>(&Delta;<i>x</i>)<sup>2</sup>, the area of the bottom left rectangle of overlap is (1 - <i>w</i><sub>0</sub>)(1 - <i>w</i><sub>1</sub>)(&Delta;<i>x</i>)<sup>2</sup>, and the area of the bottom right rectangle of overlap is <i>w</i><sub>0</sub>(1 - <i>w</i><sub>1</sub>)(&Delta;<i>x</i>)<sup>2</sup>:</p>
      <p><img src="AreaInterp17.png" style="border-style: none;" class="center"></img></p>
      <p>The area of a grid cell is (&Delta;<i>x</i>)<sup>2</sup>, so we could say the areas of these rectangles are the fractions (1 - <i>w</i><sub>0</sub>)(1 - <i>w</i><sub>1</sub>), <i>w</i><sub>0</sub>(1 - <i>w</i><sub>1</sub>), (1 - <i>w</i><sub>0</sub>)<i>w</i><sub>1</sub>, and <i>w</i><sub>0</sub><i>w</i><sub>1</sub> of a grid cell. Remember where we've seen these before! These are the coefficients we multiply the particle's horizontal velocity by to get the particle's contributions to the four velocities it influences!</p>
      <p><img src="AreaInterp18.png" style="border-style: none;" class="center"></img></p>
      <p>So, you can think of it like this:</p>
      <p><img src="AreaInterp19.png" style="border-style: none;" class="center"></img></p>
      <p>That is, the particle exerts influence onto its neighboring velocity components. The amount of influence it exerts on each velocity component is proportional to how much its imaginary grid cell overlaps each velocity component's imaginary grid cell! This is called <i>area-weighted interpolation</i> and is used in a variety of related operations in computational fluid dynamics and computer graphics. For example, on page 15 (page 18 of the PDF) of <a target="_blank" href="https://www.osti.gov/biblio/4769185-particle-cell-method-numerical-solution-problems-fluid-dynamics">a report by Francis H. Harlow (1962)</a>, a related "velocity weighting procedure" of mapping from the grid velocities to a particle's velocity is described. Similarly, Figure 3 of a key <a target="_blank" href="https://www.cbim.rutgers.edu/dmdocuments/gmip96%20Foster.pdf">paper by Foster and Metaxas (1996)</a> that introduced computational fluid dynamics to computer graphics illustrates an area-weighted interpolation scheme for mapping the velocity of a "marker particle" (a slightly different concept than our actual fluid particles) based on grid velocities.</p>
      <p>Note that for all particles we use to model a fluid, we would repeat this process: for each particle, splat its velocities onto the grid via this process. FLIP fluid simulation algorithms use a variety of approaches for finding these neighboring grid cells for splatting, or transferring, velocities from particles to the grid. In this case, we are using our area-weighted interpolation approach for the particle-to-grid transfer. See the <a target="_blank" href="https://www.cs.ucr.edu/~shinar/papers/2019-mac-apic.pdf">paper by Ding et al. (2019)</a> for a more detailed introduction to the trade-offs around velocity transfers in PIC/FLIP algorithms.</p>
      <h2 id="Splatting_Particle_Velocities_onto_Grid_in_3D">Splatting Particle Velocities onto the Grid in 3D</h2>
      <p>The figures below show how we will illustrate the three-dimensional neighborhood of grid cells around a particle. We'll spread adjacent grid cells in a slice of cells apart for easier viewing:</p>
      <p><img src="BreakApart3DGrid.gif" style="border-style: none;" class="center"></img></p>
      <p>We'll also spread the <i>z</i> direction slices of grid cells out from each other so it's easier to see things without overlap.</p>
      <p><img src="Grid3DSlices.gif" style="border-style: none;" class="center"></img></p>
      <p>Splatting in 3D works the same as 2D, with a few small changes to account for the extra dimension. We still shift half a grid cell width from the particle's position, but we do it now in <i>two</i> coordinate directions instead of one. We also still splat the particle's velocity onto neighboring grid velocities, but now we will have eight grid velocity components to update instead of just four.</p>
      <p>Here is the whole 3D splatting procedure, in three parts. The first part is the update of the <i>x</i>-direction grid velocity components:
      <ul>
        <li>Shift from the particle's position, (<i>x</i>, <i>y</i>, <i>z</i>) by -&Delta;<i>x</i>/2 in the <i>y</i> and <i>z</i> directions to the point (<i>x</i>, <i>y</i> - &Delta;<i>x</i>/2, <i>z</i> - &Delta;<i>x</i>/2).</li>
        <li>Calculate the barycentric weights of that shifted position relative to the cell containing that point. If you shifted onto a cell boundary, assume you're in the cell with the higher index in the relevant coordinate direction(s).</li>
        <li>Splat the particle's <i>u</i> velocity (the <i>x</i> component of its velocity) onto the <i>u</i> velocity components of the grid cell containing this shifted position. Also splat the particle's <i>u</i> velocity component onto the <i>u</i> velocity components of the grid cell in front of, the grid cell above, and the grid cell diagonally in front of and above, that grid cell containing the shifted position.</li>
      </ul>
      </p>
      <p>The second part of the 3D splatting algorithm is the update of grid velocities in the <i>y</i> direction:
      <ul>
        <li>Shift from the particle's position, (<i>x</i>, <i>y</i>, <i>z</i>), by -&Delta;<i>x</i>/2 in the <i>x</i> and <i>z</i> directions to the point (<i>x</i> - &Delta;<i>x</i>/2, <i>y</i>, <i>z</i> - &Delta;<i>x</i>/2).</li>
        <li>Calculate the barycentric weights of that shifted position relative to the cell containing that point. If you shifted onto a cell boundary, assume you're in the cell with the higher index in the relevant coordinate direction(s).</li>
        <li>Splat the particle's <i>v</i> velocity (the <i>y</i> component of its velocity) onto the <i>v</i> velocity components of the grid cell containing this shifted position. Also splat the particle's <i>v</i> velocity component onto the <i>v</i> velocity components of the grid cell to the right of, in front of, and diagonally to the right and in front of, that grid cell containing the shifted position.</li>
      </ul>
      </p>
      <p>The third part of the 3D splatting algorithm is the update of grid velocities in the <i>z</i> direction:
      <ul>
        <li>Shift from the particle's position, (<i>x</i>, <i>y</i>, <i>z</i>), by -&Delta;<i>x</i>/2 in the <i>x</i> and <i>y</i> directions to the point (<i>x</i> - &Delta;<i>x</i>/2, <i>y</i> - &Delta;<i>x</i>/2, <i>z</i>).</li>
        <li>Calculate the barycentric weights of that shifted position relative to the cell containing that point. If you shifted onto a cell boundary, assume you're in the cell with the higher index in the relevant coordinate direction(s).</li>
        <li>Splat the particle's <i>w</i> velocity (the <i>z</i> component of its velocity) onto the <i>w</i> velocity components of the grid cell containing this shifted position. Also splat the particle's <i>w</i> velocity component onto the <i>w</i> velocity components of the grid cell to right of, above, and diagonally above and to the right of, that grid cell containing the shifted position.</li>
      </ul>
      </p>
      <p>As with the 2D splatting algorithm, all of these parts of the 3D splatting algorithm are done once for each particle in the entire simulation, in each time step.</p>
      <p>Now, implementing this algorithm can actually be done in a very small amount of code, but understanding how it works is complicated by the fact that, in each of the three parts of the algorithm above, the shift step can end up in different grid cells depending on where exactly the particle was located in its original cell. Let's look at this carefully.</p>
      <p>For the first part of the splatting algorithm, the negative half-grid-cell-width shift in the <i>y</i> and <i>z</i> directions will land you in one of four possible grid cells, depending on in which quadrant of its current grid cell the particle is located:</p>
      <p><img src="Splat3D_1.png" style="border-style: none;" class="center"></img></p>
      <p>Case 1: shift to the cell diagonally below and back:</p>
      <p><img src="Splat3D_2.png" style="border-style: none;" class="center"></img></p>
      <p>In that case, the velocity components we update are:</p>
      <p><img src="Splat3D_3.png" style="border-style: none;" class="center"></img></p>
      <p>And here's how we update them:</p>
      <p><img src="Splat3D_4.png" style="border-style: none;" class="center"></img></p>
      <p>Case 2: shift to the cell below:</p>
      <p><img src="Splat3D_5.png" style="border-style: none;" class="center"></img></p>
      <p>In that case, the velocity components we update are:</p>
      <p><img src="Splat3D_6.png" style="border-style: none;" class="center"></img></p>
      <p>And here's how we update them:</p>
      <p><img src="Splat3D_7.png" style="border-style: none;" class="center"></img></p>
      <p>Case 3: shift to the cell behind the particle's cell:</p>
      <p><img src="Splat3D_8.png" style="border-style: none;" class="center"></img></p>
      <p>In that case, the velocity components we update are:</p>
      <p><img src="Splat3D_9.png" style="border-style: none;" class="center"></img></p>
      <p>And here's how we update them:</p>
      <p><img src="Splat3D_10.png" style="border-style: none;" class="center"></img></p>
      <p>Case 4: stay in the same grid cell after the shift:</p>
      <p><img src="Splat3D_11.png" style="border-style: none;" class="center"></img></p>
      <p>In that case, the velocity components we update are:</p>
      <p><img src="Splat3D_12.png" style="border-style: none;" class="center"></img></p>
      <p>And here's how we update them:</p>
      <p><img src="Splat3D_13.png" style="border-style: none;" class="center"></img></p>
      <p>For the second part of the splatting algorithm, the negative shift in the <i>x</i> and <i>z</i> directions will land you in one of four possible grid cells, depending on in which quadrant of its current grid cell the particle is located:</p>
      <p><img src="Splat3D_14.png" style="border-style: none;" class="center"></img></p>
      <p>Case 1: shift to the cell diagonally left and back:</p>
      <p><img src="Splat3D_15.png" style="border-style: none;" class="center"></img></p>
      <p>In that case, the velocity components we update are:</p>
      <p><img src="Splat3D_16.png" style="border-style: none;" class="center"></img></p>
      <p>And here's how we update them:</p>
      <p><img src="Splat3D_17.png" style="border-style: none;" class="center"></img></p>
      <p>Case 2: shift to the cell to the left:</p>
      <p><img src="Splat3D_18.png" style="border-style: none;" class="center"></img></p>
      <p>In that case, the velocity components we update are:</p>
      <p><img src="Splat3D_19.png" style="border-style: none;" class="center"></img></p>
      <p>And here's how we update them:</p>
      <p><img src="Splat3D_20.png" style="border-style: none;" class="center"></img></p>
      <p>Case 3: shift to the cell behind the particle's cell:</p>
      <p><img src="Splat3D_21.png" style="border-style: none;" class="center"></img></p>
      <p>In that case, the velocity components we update are:</p>
      <p><img src="Splat3D_22.png" style="border-style: none;" class="center"></img></p>
      <p>And here's how we update them:</p>
      <p><img src="Splat3D_23.png" style="border-style: none;" class="center"></img></p>
      <p>Case 4: stay in the same grid cell after the shift:</p>
      <p><img src="Splat3D_24.png" style="border-style: none;" class="center"></img></p>
      <p>In that case, the velocity components we update are:</p>
      <p><img src="Splat3D_25.png" style="border-style: none;" class="center"></img></p>
      <p>And here's how we update them:</p>
      <p><img src="Splat3D_26.png" style="border-style: none;" class="center"></img></p>
      <p>For the third part of the splatting algorithm, the negative shift in the <i>x</i> and <i>y</i> directions will land you in one of four possible grid cells, depending on in which quadrant of its current grid cell the particle is located:</p>
      <p><img src="Splat3D_27.png" style="border-style: none;" class="center"></img></p>
      <p>Case 1: shift to the cell diagonally left and down:</p>
      <p><img src="Splat3D_28.png" style="border-style: none;" class="center"></img></p>
      <p>In that case, the velocity components we update are:</p>
      <p><img src="Splat3D_29.png" style="border-style: none;" class="center"></img></p>
      <p>And here's how we update them:</p>
      <p><img src="Splat3D_30.png" style="border-style: none;" class="center"></img></p>
      <p>Case 2: shift to the cell to the left:</p>
      <p><img src="Splat3D_31.png" style="border-style: none;" class="center"></img></p>
      <p>In that case, the velocity components we update are:</p>
      <p><img src="Splat3D_32.png" style="border-style: none;" class="center"></img></p>
      <p>And here's how we update them:</p>
      <p><img src="Splat3D_33.png" style="border-style: none;" class="center"></img></p>
      <p>Case 3: shift to the cell below the particle's cell:</p>
      <p><img src="Splat3D_34.png" style="border-style: none;" class="center"></img></p>
      <p>In that case, the velocity components we update are:</p>
      <p><img src="Splat3D_35.png" style="border-style: none;" class="center"></img></p>
      <p>And here's how we update them:</p>
      <p><img src="Splat3D_36.png" style="border-style: none;" class="center"></img></p>
      <p>Case 4: stay in the same grid cell after the shift:</p>
      <p><img src="Splat3D_37.png" style="border-style: none;" class="center"></img></p>
      <p>In that case, the velocity components we update are:</p>
      <p><img src="Splat3D_38.png" style="border-style: none;" class="center"></img></p>
      <p>And here's how we update them:</p>
      <p><img src="Splat3D_39.png" style="border-style: none;" class="center"></img></p>
      <p>Note that all this gymnastics with shifting and indexing is doing the exact same thing we did in the 2D case: the shift finds the lower corner of the imaginary grid cell centered at the particle, and then we use the weighted volumes of overlap between that cell and the imaginary grid cell centered around each of the neighboring grid velocity components.</p>
      <p>Interestingly, in the diagrams above, if we let (<i>i</i><sub>shifted</sub>, <i>j</i><sub>shifted</sub>, <i>k</i><sub>shifted</sub>) denote the grid cell you shifted <i>into</i>, then after the shift in the <i>y</i> and <i>z</i> directions, we <i>always</i> update the <i>u</i> velocities on either side of these four grid cells:
      <ul>
        <li>(<i>i</i><sub>shifted</sub>, <i>j</i><sub>shifted</sub>, <i>k</i><sub>shifted</sub>)</li>
        <li>(<i>i</i><sub>shifted</sub>, <i>j</i><sub>shifted</sub> + 1, <i>k</i><sub>shifted</sub>)</li>
        <li>(<i>i</i><sub>shifted</sub>, <i>j</i><sub>shifted</sub>, <i>k</i><sub>shifted</sub> + 1)</li>
        <li>(<i>i</i><sub>shifted</sub>, <i>j</i><sub>shifted</sub> + 1, <i>k</i><sub>shifted</sub> + 1)</li>
      </ul></p>
      <p><img src="Splat3D_X1.png" style="border-style: none;" class="center"></img></p>
      <p>Similarly, after the shift in the <i>x</i> and <i>z</i> directions, we <i>always</i> update the <i>v</i> velocities on either side of these four grid cells:
      <ul>
        <li>(<i>i</i><sub>shifted</sub>, <i>j</i><sub>shifted</sub>, <i>k</i><sub>shifted</sub>)</li>
        <li>(<i>i</i><sub>shifted</sub> + 1, <i>j</i><sub>shifted</sub>, <i>k</i><sub>shifted</sub>)</li>
        <li>(<i>i</i><sub>shifted</sub>, <i>j</i><sub>shifted</sub>, <i>k</i><sub>shifted</sub> + 1)</li>
        <li>(<i>i</i><sub>shifted</sub> + 1, <i>j</i><sub>shifted</sub>, <i>k</i><sub>shifted</sub> + 1)</li>
      </ul></p>
      <p><img src="Splat3D_Y1.png" style="border-style: none;" class="center"></img></p>
      <p>And after the shift in the <i>y</i> and <i>z</i> directions, we <i>always</i> update the <i>w</i> velocities on either side of these four grid cells:
      <ul>
        <li>(<i>i</i><sub>shifted</sub>, <i>j</i><sub>shifted</sub>, <i>k</i><sub>shifted</sub>)</li>
        <li>(<i>i</i><sub>shifted</sub> + 1, <i>j</i><sub>shifted</sub>, <i>k</i><sub>shifted</sub>)</li>
        <li>(<i>i</i><sub>shifted</sub>, <i>j</i><sub>shifted</sub> + 1, <i>k</i><sub>shifted</sub>)</li>
        <li>(<i>i</i><sub>shifted</sub> + 1, <i>j</i><sub>shifted</sub> + 1, <i>k</i><sub>shifted</sub>)</li>
      </ul></p>
      <p><img src="Splat3D_Z1.png" style="border-style: none;" class="center"></img></p>
      <p>Now recall that, our indexing scheme getting rid of the &frac12;s in our indices makes the -&frac12;s disappear and the +&frac12;s become +1s:</p>
      <p><img src="Splat3D_X2.png" style="border-style: none;" class="center"></img></p>
      <p><img src="Splat3D_Y2.png" style="border-style: none;" class="center"></img></p>
      <p><img src="Splat3D_Z2.png" style="border-style: none;" class="center"></img></p>
      <p>Let's list all the velocities we end up updating that are shown in the diagrams above with the indexing scheme we use in our code for the staggered grid's 3D arrays of velocities. The velocities we end up updating in our staggered grid's 3D arrays of velocities, based on the <i>u</i> velocity-update list above, are (note that <i>i</i><sub>shifted</sub> can be <i>i</i> or <i>i</i> - 1, <i>j</i><sub>shifted</sub> can be <i>j</i> or <i>j</i> - 1, and <i>k</i><sub>shifted</sub> can be <i>k</i> or <i>k</i> - 1 as in the diagrams above depending on where the shift lands, so <i>i</i><sub>shifted</sub> + 1 would be either <i>i</i> or <i>i</i> + 1, <i>j</i><sub>shifted</sub> + 1 would be either <i>j</i> or <i>j</i> + 1, and <i>k</i><sub>shifted</sub> + 1 would be either <i>k</i> or <i>k</i> + 1):
      <ul>
        <li><i>u</i>(<i>i</i><sub>shifted</sub>, <i>j</i><sub>shifted</sub>, <i>k</i><sub>shifted</sub>)</li>
        <li><i>u</i>(<i>i</i><sub>shifted</sub> + 1, <i>j</i><sub>shifted</sub>, <i>k</i><sub>shifted</sub>)</li>
        <li><i>u</i>(<i>i</i><sub>shifted</sub>, <i>j</i><sub>shifted</sub> + 1, <i>k</i><sub>shifted</sub>)</li>
        <li><i>u</i>(<i>i</i><sub>shifted</sub> + 1, <i>j</i><sub>shifted</sub> + 1, <i>k</i><sub>shifted</sub>)</li>
        <li><i>u</i>(<i>i</i><sub>shifted</sub>, <i>j</i><sub>shifted</sub>, <i>k</i><sub>shifted</sub> + 1)</li>
        <li><i>u</i>(<i>i</i><sub>shifted</sub> + 1, <i>j</i><sub>shifted</sub>, <i>k</i><sub>shifted</sub> + 1)</li>
        <li><i>u</i>(<i>i</i><sub>shifted</sub>, <i>j</i><sub>shifted</sub> + 1, <i>k</i><sub>shifted</sub> + 1)</li>
        <li><i>u</i>(<i>i</i><sub>shifted</sub> + 1, <i>j</i><sub>shifted</sub> + 1, <i>k</i><sub>shifted</sub> + 1)</li>
      </ul></p>
      <p>And the velocities we end up updating in the 3D array of <i>v</i> velocities are:
      <ul>
        <li><i>v</i>(<i>i</i><sub>shifted</sub>, <i>j</i><sub>shifted</sub>, <i>k</i><sub>shifted</sub>)</li>
        <li><i>v</i>(<i>i</i><sub>shifted</sub>, <i>j</i><sub>shifted</sub> + 1, <i>k</i><sub>shifted</sub>)</li>
        <li><i>v</i>(<i>i</i><sub>shifted</sub> + 1, <i>j</i><sub>shifted</sub>, <i>k</i><sub>shifted</sub>)</li>
        <li><i>v</i>(<i>i</i><sub>shifted</sub> + 1, <i>j</i><sub>shifted</sub> + 1, <i>k</i><sub>shifted</sub>)</li>
        <li><i>v</i>(<i>i</i><sub>shifted</sub>, <i>j</i><sub>shifted</sub>, <i>k</i><sub>shifted</sub> + 1)</li>
        <li><i>v</i>(<i>i</i><sub>shifted</sub>, <i>j</i><sub>shifted</sub> + 1, <i>k</i><sub>shifted</sub> + 1)</li>
        <li><i>v</i>(<i>i</i><sub>shifted</sub> + 1, <i>j</i><sub>shifted</sub>, <i>k</i><sub>shifted</sub> + 1)</li>
        <li><i>v</i>(<i>i</i><sub>shifted</sub> + 1, <i>j</i><sub>shifted</sub> + 1, <i>k</i><sub>shifted</sub> + 1)</li>
      </ul></p>
      <p>And the velocities we end up updating in the 3D array of <i>w</i> velocities are:
      <ul>
        <li><i>w</i>(<i>i</i><sub>shifted</sub>, <i>j</i><sub>shifted</sub>, <i>k</i><sub>shifted</sub>)</li>
        <li><i>w</i>(<i>i</i><sub>shifted</sub>, <i>j</i><sub>shifted</sub>, <i>k</i><sub>shifted</sub> + 1)</li>
        <li><i>w</i>(<i>i</i><sub>shifted</sub> + 1, <i>j</i><sub>shifted</sub>, <i>k</i><sub>shifted</sub>)</li>
        <li><i>w</i>(<i>i</i><sub>shifted</sub> + 1, <i>j</i><sub>shifted</sub>, <i>k</i><sub>shifted</sub> + 1)</li>
        <li><i>w</i>(<i>i</i><sub>shifted</sub>, <i>j</i><sub>shifted</sub> + 1, <i>k</i><sub>shifted</sub>)</li>
        <li><i>w</i>(<i>i</i><sub>shifted</sub>, <i>j</i><sub>shifted</sub> + 1, <i>k</i><sub>shifted</sub> + 1)</li>
        <li><i>w</i>(<i>i</i><sub>shifted</sub> + 1, <i>j</i><sub>shifted</sub> + 1, <i>k</i><sub>shifted</sub>)</li>
        <li><i>w</i>(<i>i</i><sub>shifted</sub> + 1, <i>j</i><sub>shifted</sub> + 1, <i>k</i><sub>shifted</sub> + 1)</li>
      </ul></p>
      </p>
      <p>So, we can use the same set of indices (<i>i</i>, <i>j</i>, <i>k</i> of the cell containing the shifted particle position, each plus 1 or not) to access every velocity component in every direction that we need to update! Putting it all together, the whole 3D splatting algorithm will work like this (as you can also see in Bargteil and Shinar's <code>fluid.cpp</code> file):</p>
      <p>
      <ul>
        <li>Let <i>p.pos</i> = (<i>x</i>, <i>y</i>, <i>z</i>) denote the position of the particle <i>p</i> at the current time step.</li>
        <li>Part 1: Splat horizontal velocity of particle onto grid:
          <ul>
            <li>Let <i>p</i><sub>shifted</sub> = (<i>x</i>, <i>y</i> - &Delta;<i>x</i> / 2, <i>z</i> - &Delta;<i>x</i> / 2).</li>
            <li>Let (<i>i</i>, <i>j</i>, <i>k</i>) be the indices of the grid cell containing <i>p</i><sub>shifted</sub>.</li>
            <li>Let (<i>w</i><sub>0</sub>, <i>w</i><sub>1</sub>, <i>w</i><sub>2</sub>) be the barycentric weights of <i>p</i><sub>shifted</sub> in grid cell (<i>i</i>, <i>j</i>, <i>k</i>).</li>
            <li>splat(<i>u<sub>p</sub></i>, <i>w</i><sub>0</sub>, <i>w</i><sub>1</sub>, <i>w</i><sub>2</sub>, <i>i</i>, <i>j</i>, <i>k</i>, <i>u</i><sub>grid</sub>): This splats the particle's horizontal velocity, <i>u<sub>p</sub></i>, whose shifted position lies in cell (<i>i</i>, <i>j</i>, <i>k</i>) with barycentric weights (<i>w</i><sub>0</sub>, <i>w</i><sub>1</sub>, <i>w</i><sub>2</sub>), onto the relevant velocities in the 3D array, <i>u</i><sub>grid</sub>, of horizontal velocity components on the grid.</li>
          </ul>
        </li>
        <li>Part 2: Splat vertical velocity of particle onto grid:
          <ul>
            <li>Let <i>p</i><sub>shifted</sub> = (<i>x</i> - &Delta;<i>x</i> / 2, <i>y</i>, <i>z</i> - &Delta;<i>x</i> / 2).</li>
            <li>Let (<i>i</i>, <i>j</i>, <i>k</i>) be the indices of the grid cell containing <i>p</i><sub>shifted</sub>.</li>
            <li>Let (<i>w</i><sub>0</sub>, <i>w</i><sub>1</sub>, <i>w</i><sub>2</sub>) be the barycentric weights of <i>p</i><sub>shifted</sub> in grid cell (<i>i</i>, <i>j</i>, <i>k</i>).</li>
            <li>splat(<i>v<sub>p</sub></i>, <i>w</i><sub>0</sub>, <i>w</i><sub>1</sub>, <i>w</i><sub>2</sub>, <i>i</i>, <i>j</i>, <i>k</i>, <i>v</i><sub>grid</sub>): This splats the particle's vertical velocity, <i>v<sub>p</sub></i>, whose shifted position lies in cell (<i>i</i>, <i>j</i>, <i>k</i>) with barycentric weights (<i>w</i><sub>0</sub>, <i>w</i><sub>1</sub>, <i>w</i><sub>2</sub>), onto the relevant velocities in the 3D array, <i>v</i><sub>grid</sub>, of vertical velocity components on the grid.</li>
          </ul>
        </li>
        <li>Part 3: Splat depth (<i>z</i> direction) velocity of particle onto grid:
          <ul>
            <li>Let <i>p</i><sub>shifted</sub> = (<i>x</i> - &Delta;<i>x</i> / 2, <i>y</i> - &Delta;<i>x</i> / 2, <i>z</i>).</li>
            <li>Let (<i>i</i>, <i>j</i>, <i>k</i>) be the indices of the grid cell containing <i>p</i><sub>shifted</sub>.</li>
            <li>Let (<i>w</i><sub>0</sub>, <i>w</i><sub>1</sub>, <i>w</i><sub>2</sub>) be the barycentric weights of <i>p</i><sub>shifted</sub> in grid cell (<i>i</i>, <i>j</i>, <i>k</i>).</li>
            <li>splat(<i>w<sub>p</sub></i>, <i>w</i><sub>0</sub>, <i>w</i><sub>1</sub>, <i>w</i><sub>2</sub>, <i>i</i>, <i>j</i>, <i>k</i>, <i>w</i><sub>grid</sub>): This splats the particle's depth velocity, <i>w<sub>p</sub></i>, whose shifted position lies in cell (<i>i</i>, <i>j</i>, <i>k</i>) with barycentric weights (<i>w</i><sub>0</sub>, <i>w</i><sub>1</sub>, <i>w</i><sub>2</sub>), onto the relevant velocities in the 3D array, <i>w</i><sub>grid</sub>, of depth velocity components on the grid.</li>
          </ul>
        </li>
      </ul>
      </p>
      <p>Where the splat function is:</p>
      <p>splat(vel<sub><i>p</i></sub>, <i>w</i><sub>0</sub>, <i>w</i><sub>1</sub>, <i>w</i><sub>2</sub>, <i>i</i>, <i>j</i>, <i>k</i>, vel<sub>grid</sub>):
        <ul>
          <li>vel<sub>grid</sub>(<i>i</i>, <i>j</i>, <i>k</i>) += (1 - <i>w</i><sub>0</sub>) &middot; (1 - <i>w</i><sub>1</sub>) &middot; (1 - <i>w</i><sub>2</sub>) &middot; vel<sub><i>p</i></sub></li>
          <li>vel<sub>grid</sub>(<i>i</i> + 1, <i>j</i>, <i>k</i>) += <i>w</i><sub>0</sub> &middot; (1 - <i>w</i><sub>1</sub>) &middot; (1 - <i>w</i><sub>2</sub>) &middot; vel<sub><i>p</i></sub></li>
          <li>vel<sub>grid</sub>(<i>i</i>, <i>j</i> + 1, <i>k</i>) += (1 - <i>w</i><sub>0</sub>) &middot; <i>w</i><sub>1</sub> &middot; (1 - <i>w</i><sub>2</sub>) &middot; vel<sub><i>p</i></sub></li>
          <li>vel<sub>grid</sub>(<i>i</i> + 1, <i>j</i> + 1, <i>k</i>) += <i>w</i><sub>0</sub> &middot; <i>w</i><sub>1</sub> &middot; (1 - <i>w</i><sub>2</sub>) &middot; vel<sub><i>p</i></sub></li>
          <li>vel<sub>grid</sub>(<i>i</i>, <i>j</i>, <i>k</i> + 1) += (1 - <i>w</i><sub>0</sub>) &middot; (1 - <i>w</i><sub>1</sub>) &middot; <i>w</i><sub>2</sub> &middot; vel<sub><i>p</i></sub></li>
          <li>vel<sub>grid</sub>(<i>i</i> + 1, <i>j</i>, <i>k</i> + 1) += <i>w</i><sub>0</sub> &middot; (1 - <i>w</i><sub>1</sub>) &middot; <i>w</i><sub>2</sub> &middot; vel<sub><i>p</i></sub></li>
          <li>vel<sub>grid</sub>(<i>i</i>, <i>j</i> + 1, <i>k</i> + 1) += (1 - <i>w</i><sub>0</sub>) &middot; <i>w</i><sub>1</sub> &middot; <i>w</i><sub>2</sub> &middot; vel<sub><i>p</i></sub></li>
          <li>vel<sub>grid</sub>(<i>i</i> + 1, <i>j</i> + 1, <i>k</i> + 1) += <i>w</i><sub>0</sub> &middot; <i>w</i><sub>1</sub> &middot; <i>w</i><sub>2</sub> &middot; vel<sub><i>p</i></sub></li>
      </ul></p>
      <p>Note that (<i>i</i>, <i>j</i>, <i>k</i>) here are the indices of the cell containing the <i>shifted</i> particle position, which may be different for each of the shifts we do in the three different parts of the 3D splatting algorithm.</p>
      <p>Anyway, because of our indexing scheme, all of these different cases of shifting in different coordinate directions and splatting onto neighboring grid cell velocities just works, by calling this one fixed splat function three times with different inputs!</p>
      <p>But there's a problem!</p>
      <h2 id="Normalizing_Splatted_Velocities">Normalizing Splatted Velocities</h2>
      <p>What would happen if we had a ton of particles influencing certain grid velocities?</p>
      <p><img src="SplatTooManyParticles.png" style="border-style: none;" class="center"></img></p>
      <p>Basically, we would keep adding, and adding, and adding, and adding more and more weighted particle velocities to those grid velocities. If you had a hundred million particles all moving at 6 m/s in a direction parallel to a grid velocity and having their imaginary cells overlapping half the volume of a grid velocity's imaginary cell, your fluid velocity would exceed the speed of light (which is just under 300 million m/s)! Sorry, but your fluid is <i>not</i> moving that fast! Okay that's an extreme example, but the point is, we don't want fluid velocities to be huge just because there are a lot of particles near them. So, we need to <i>normalize</i> the value of each grid velocity component after splatting, to have it be a sort of average velocity of all particle velocities splatted onto it, rather than just a sum of those splatted particle velocities.</p>
      <p>One approach, taken by the code associated with <a target="_blank" href="https://cal.cs.umbc.edu/Courses/PhysicsBasedAnimation/">Bargteil and Shinar's SIGGRAPH course</a>, is to keep adding up the volumes of overlap between the imaginary grid cell centered on each grid velocity component and the imaginary grid cell centered on each particle. That is, each time we add a particle's weighted velocity component to a grid velocity component, in parallel we sum just the weights, e.g., add up all the (1 - <i>w</i><sub>0</sub>)<i>w</i><sub>1</sub>(1 - <i>w</i><sub>2</sub>) factors for each particle's contribution to the grid velocity component <i>u</i><sub>3 + &frac12;, 1, 7</sub> and so on for each grid velocity component. Then, when we're done splatting all particle velocity components onto the relevant grid velocity components, we divide each grid velocity component by that corresponding sum of all weights (volumes of overlap) of particle velocity contributions we added to that grid velocity component.</p>
      <p>Let's modify our splatting algorithm above to add this normalization step for each velocity component in the grid. Let's also add an important detail, which is that all of the grid velocity values and all of these weight/volume sums need to be zeroed out at the beginning of our splatting algorithm (new steps are in <b>bold</b>):
      <ul>
        <li>Let <i>p.pos</i> = (<i>x</i>, <i>y</i>, <i>z</i>) denote the position of the particle <i>p</i> at the current time step.</li>
        <li><b>Set every single value in all of the 3D arrays of grid velocities, <i>u</i><sub>grid</sub>, <i>v</i><sub>grid</sub>, and <i>w</i><sub>grid</sub>, to zero.</b></li>
        <li><b>As part of the staggered grid, just as we do with the 3D arrays <i>u</i><sub>grid</sub>, <i>v</i><sub>grid</sub>, and <i>w</i><sub>grid</sub>, store three additional 3D arrays, <i>f<sub>u</sub></i>, <i>f<sub>v</sub></i>, and <i>f<sub>w</sub></i>. Set all values in these arrays to zero as well.</b></li>
        <li>Part 1: Splat horizontal velocity of particle onto grid:
          <ul>
            <li>Let <i>p</i><sub>shifted</sub> = (<i>x</i>, <i>y</i> - &Delta;<i>x</i> / 2, <i>z</i> - &Delta;<i>x</i> / 2).</li>
            <li>Let (<i>i</i>, <i>j</i>, <i>k</i>) be the indices of the grid cell containing <i>p</i><sub>shifted</sub>.</li>
            <li>Let (<i>w</i><sub>0</sub>, <i>w</i><sub>1</sub>, <i>w</i><sub>2</sub>) be the barycentric weights of <i>p</i><sub>shifted</sub> in grid cell (<i>i</i>, <i>j</i>, <i>k</i>).</li>
            <li>splat(<i>u<sub>p</sub></i>, <i>w</i><sub>0</sub>, <i>w</i><sub>1</sub>, <i>w</i><sub>2</sub>, <i>i</i>, <i>j</i>, <i>k</i>, <i>u</i><sub>grid</sub>, <b><i>f<sub>u</sub></i></b>): This splats the particle's horizontal velocity, <i>u<sub>p</sub></i>, whose shifted position lies in cell (<i>i</i>, <i>j</i>, <i>k</i>) with barycentric weights (<i>w</i><sub>0</sub>, <i>w</i><sub>1</sub>, <i>w</i><sub>2</sub>), onto the relevant velocities in the 3D array, <i>u</i><sub>grid</sub>, of horizontal velocity components on the grid. <b>Also, this function will accumulate the barycentric weight products (overlap volumes) of all particle contributions to each horizontal grid velocity.</b></li>
          <li><b>For each (<i>i</i>, <i>j</i>, <i>k</i>), divide <i>u</i>(<i>i</i>, <i>j</i>, <i>k</i>) by <i>f<sub>u</sub></i>(<i>i</i>, <i>j</i>, <i>k</i>).</b></li>
          </ul>
        </li>
        <li>Part 2: Splat vertical velocity of particle onto grid:
          <ul>
            <li>Let <i>p</i><sub>shifted</sub> = (<i>x</i> - &Delta;<i>x</i> / 2, <i>y</i>, <i>z</i> - &Delta;<i>x</i> / 2).</li>
            <li>Let (<i>i</i>, <i>j</i>, <i>k</i>) be the indices of the grid cell containing <i>p</i><sub>shifted</sub>.</li>
            <li>Let (<i>w</i><sub>0</sub>, <i>w</i><sub>1</sub>, <i>w</i><sub>2</sub>) be the barycentric weights of <i>p</i><sub>shifted</sub> in grid cell (<i>i</i>, <i>j</i>, <i>k</i>).</li>
            <li>splat(<i>v<sub>p</sub></i>, <i>w</i><sub>0</sub>, <i>w</i><sub>1</sub>, <i>w</i><sub>2</sub>, <i>i</i>, <i>j</i>, <i>k</i>, <i>v</i><sub>grid</sub>, <b><i>f<sub>v</sub></i></b>): This splats the particle's vertical velocity, <i>v<sub>p</sub></i>, whose shifted position lies in cell (<i>i</i>, <i>j</i>, <i>k</i>) with barycentric weights (<i>w</i><sub>0</sub>, <i>w</i><sub>1</sub>, <i>w</i><sub>2</sub>), onto the relevant velocities in the 3D array, <i>v</i><sub>grid</sub>, of vertical velocity components on the grid. <b>Also, this function will accumulate the barycentric weight products (overlap volumes) of all particle contributions to each vertical grid velocity.</b></li>
          <li><b>For each (<i>i</i>, <i>j</i>, <i>k</i>), divide <i>v</i>(<i>i</i>, <i>j</i>, <i>k</i>) by <i>f<sub>v</sub></i>(<i>i</i>, <i>j</i>, <i>k</i>).</b></li>
          </ul>
        </li>
        <li>Part 3: Splat depth (<i>z</i> direction) velocity of particle onto grid:
          <ul>
            <li>Let <i>p</i><sub>shifted</sub> = (<i>x</i> - &Delta;<i>x</i> / 2, <i>y</i> - &Delta;<i>x</i> / 2, <i>z</i>).</li>
            <li>Let (<i>i</i>, <i>j</i>, <i>k</i>) be the indices of the grid cell containing <i>p</i><sub>shifted</sub>.</li>
            <li>Let (<i>w</i><sub>0</sub>, <i>w</i><sub>1</sub>, <i>w</i><sub>2</sub>) be the barycentric weights of <i>p</i><sub>shifted</sub> in grid cell (<i>i</i>, <i>j</i>, <i>k</i>).</li>
            <li>splat(<i>w<sub>p</sub></i>, <i>w</i><sub>0</sub>, <i>w</i><sub>1</sub>, <i>w</i><sub>2</sub>, <i>i</i>, <i>j</i>, <i>k</i>, <i>w</i><sub>grid</sub>, <b><i>f<sub>w</sub></i></b>): This splats the particle's depth velocity, <i>w<sub>p</sub></i>, whose shifted position lies in cell (<i>i</i>, <i>j</i>, <i>k</i>) with barycentric weights (<i>w</i><sub>0</sub>, <i>w</i><sub>1</sub>, <i>w</i><sub>2</sub>), onto the relevant velocities in the 3D array, <i>w</i><sub>grid</sub>, of depth velocity components on the grid. <b>Also, this function will accumulate the barycentric weight products (overlap volumes) of all particle contributions to each depth grid velocity.</b></li>
          <li><b>For each (<i>i</i>, <i>j</i>, <i>k</i>), divide <i>w</i>(<i>i</i>, <i>j</i>, <i>k</i>) by <i>f<sub>w</sub></i>(<i>i</i>, <i>j</i>, <i>k</i>).</b></li>
          </ul>
      </ul></p>
      <p>And here's how the splatting algorithm will do the additional work of accumulating those barycentric weight products (overlap volumes):</p>
      <p>splat(vel<sub><i>p</i></sub>, <i>w</i><sub>0</sub>, <i>w</i><sub>1</sub>, <i>w</i><sub>2</sub>, <i>i</i>, <i>j</i>, <i>k</i>, vel<sub>grid</sub>, <b>f<sub>vel</sub></b>):
        <ul>
          <li>vel<sub>grid</sub>(<i>i</i>, <i>j</i>, <i>k</i>) += (1 - <i>w</i><sub>0</sub>) &middot; (1 - <i>w</i><sub>1</sub>) &middot; (1 - <i>w</i><sub>2</sub>) &middot; vel<sub><i>p</i></sub></li>
          <li><b>f<sub>vel</sub>(<i>i</i>, <i>j</i>, <i>k</i>) += (1 - <i>w</i><sub>0</sub>) &middot; (1 - <i>w</i><sub>1</sub>) &middot; (1 - <i>w</i><sub>2</sub>)</b></li>
          <li>vel<sub>grid</sub>(<i>i</i> + 1, <i>j</i>, <i>k</i>) += <i>w</i><sub>0</sub> &middot; (1 - <i>w</i><sub>1</sub>) &middot; (1 - <i>w</i><sub>2</sub>) &middot; vel<sub><i>p</i></sub></li>
          <li><b>f<sub>vel</sub>(<i>i</i> + 1, <i>j</i>, <i>k</i>) += <i>w</i><sub>0</sub> &middot; (1 - <i>w</i><sub>1</sub>) &middot; (1 - <i>w</i><sub>2</sub>)</b></li>
          <li>vel<sub>grid</sub>(<i>i</i>, <i>j</i> + 1, <i>k</i>) += (1 - <i>w</i><sub>0</sub>) &middot; <i>w</i><sub>1</sub> &middot; (1 - <i>w</i><sub>2</sub>) &middot; vel<sub><i>p</i></sub></li>
          <li><b>f<sub>vel</sub>(<i>i</i>, <i>j</i> + 1, <i>k</i>) += (1 - <i>w</i><sub>0</sub>) &middot; <i>w</i><sub>1</sub> &middot; (1 - <i>w</i><sub>2</sub>)</b></li>
          <li>vel<sub>grid</sub>(<i>i</i> + 1, <i>j</i> + 1, <i>k</i>) += <i>w</i><sub>0</sub> &middot; <i>w</i><sub>1</sub> &middot; (1 - <i>w</i><sub>2</sub>) &middot; vel<sub><i>p</i></sub></li>
          <li><b>f<sub>vel</sub>(<i>i</i> + 1, <i>j</i> + 1, <i>k</i>) += <i>w</i><sub>0</sub> &middot; <i>w</i><sub>1</sub> &middot; (1 - <i>w</i><sub>2</sub>)</b></li>
          <li>vel<sub>grid</sub>(<i>i</i>, <i>j</i>, <i>k</i> + 1) += (1 - <i>w</i><sub>0</sub>) &middot; (1 - <i>w</i><sub>1</sub>) &middot; <i>w</i><sub>2</sub> &middot; vel<sub><i>p</i></sub></li>
          <li><b>f<sub>vel</sub>(<i>i</i>, <i>j</i>, <i>k</i> + 1) += (1 - <i>w</i><sub>0</sub>) &middot; (1 - <i>w</i><sub>1</sub>) &middot; <i>w</i><sub>2</sub></b></li>
          <li>vel<sub>grid</sub>(<i>i</i> + 1, <i>j</i>, <i>k</i> + 1) += <i>w</i><sub>0</sub> &middot; (1 - <i>w</i><sub>1</sub>) &middot; <i>w</i><sub>2</sub> &middot; vel<sub><i>p</i></sub></li>
          <li><b>f<sub>vel</sub>(<i>i</i> + 1, <i>j</i>, <i>k</i> + 1) += <i>w</i><sub>0</sub> &middot; (1 - <i>w</i><sub>1</sub>) &middot; <i>w</i><sub>2</sub></b></li>
          <li>vel<sub>grid</sub>(<i>i</i>, <i>j</i> + 1, <i>k</i> + 1) += (1 - <i>w</i><sub>0</sub>) &middot; <i>w</i><sub>1</sub> &middot; <i>w</i><sub>2</sub> &middot; vel<sub><i>p</i></sub></li>
          <li><b>f<sub>vel</sub>(<i>i</i>, <i>j</i> + 1, <i>k</i> + 1) += (1 - <i>w</i><sub>0</sub>) &middot; <i>w</i><sub>1</sub> &middot; <i>w</i><sub>2</sub></b></li>
          <li>vel<sub>grid</sub>(<i>i</i> + 1, <i>j</i> + 1, <i>k</i> + 1) += <i>w</i><sub>0</sub> &middot; <i>w</i><sub>1</sub> &middot; <i>w</i><sub>2</sub> &middot; vel<sub><i>p</i></sub></li>
          <li><b>f<sub>vel</sub>(<i>i</i> + 1, <i>j</i> + 1, <i>k</i> + 1) += <i>w</i><sub>0</sub> &middot; <i>w</i><sub>1</sub> &middot; <i>w</i><sub>2</sub></b></li>
      </ul></p>
      <h2 id="Handling_Boundary_and_Cell_Labels">Handling the Boundary and Cell Labels</h2>
      <p>In addition to our 3D arrays of velocities and accumulating barycentric weight products above, we'll also store a 3D array containing a label for each cell in the staggered grid. Each element of this cell labels array can take on three possible values: SOLID, FLUID, or EMPTY. In the fluid simulation code associated with Bargteil and Shinar's course, these labels are instead OBSTACLE, LIQUID, and AIR. Often "air" and "empty" mean the same thing since, as explained in the Boundary Conditions and later Marker Particles sections of <a target="_blank" href="https://www.cs.ubc.ca/~rbridson/fluidsimulation/">Bridson and M&uuml;ller-Fischer's notes</a>, it's often most practical to just model air by not modeling it, i.e., assume it's just empty space with a pressure of zero. Our labeling convention follows that of Bridson and M&uuml;ller-Fischer's course notes, e.g., as explained in their course notes' Marker Particles section.</p>
      <p>First, we'll go through all the grid cell labels and label every cell on the boundary as SOLID. Namely, these boundary cells are those with <i>i</i> = 0, <i>i</i> = <i>n<sub>x</sub></i> - 1, <i>j</i> = 0, <i>j</i> = <i>n<sub>y</sub></i> - 1, <i>k</i> = 0, or <i>k</i> = <i>n<sub>z</sub></i> - 1. Then, as we go through each particle to splat its velocity onto the grid, we'll label the cell containing that particle as FLUID. All other cells (i.e., those not on the boundary and not containing any fluid particles) will be labeled as EMPTY, for now.</p>
      <p>There are a couple of important details we skipped in our earlier description of splatting. Namely, what happens at the boundaries? Does any part of the splatting algorithm take us outside the grid, and if so, how do we handle that? First, following the code from Bargteil and Shinar's course, we need to decide what grid velocities to assign at the boundaries of the grid. Let's do the following:
      <ul>
        <li>On any grid cell with a face on the outside of the grid, set the velocity at the center of that face, as well as the velocity at the center of the opposite face on that grid cell, to zero.</li>
        <li>On any grid cell with a face on the outside of the grid, set the outermost velocity in any direction <i>not</i> perpendicular to the outer face equal to the corresponding velocity of the grid cell one layer inward.</li>
      </ul></p>
      <p>To make this a more precise algorithm, as the code associated with Bargteil and Shinar's course shows:
      <ul>
        <li>For all <i>j</i>, <i>k</i> in the grid:
          <ul>
            <li>u(0, j, k) = u(1, j, k) = u(nx - 1, j, k) = u(nx, j, k) = 0</li>
            <li>v(0, j, k) = v(1, j, k)</li>
            <li>w(0, j, k) = w(1, j, k)</li>
            <li>v(nx - 1, j, k) = v(nx - 2, j, k)</li>
            <li>w(nx - 1, j, k) = w(nx - 2, j, k)</li>
          </ul>
        </li>
        <li>For all <i>i</i>, <i>k</i> in the grid:
          <ul>
            <li>v(i, 0, k) = v(i, 1, k) = v(i, ny - 2, k) = v(i, ny - 1, k) = 0</li>
            <li>u(i, 0, k) = u(i, 1, k)</li>
            <li>w(i, 0, k) = w(i, 1, k)</li>
            <li>u(i, ny - 1, k) = u(i, ny - 2, k)</li>
            <li>w(i, ny - 1, k) = w(i, ny - 2, k)</li>
          </ul>
        </li>
        <li>For all <i>i</i>, <i>j</i> in the grid:
          <ul>
            <li>w(i, j, 0) = w(i, j, 1) = w(i, j, nz - 2) = w(i, j, nz - 1) = 0</li>
            <li>u(i, j, 0) = u(i, j, 1)</li>
            <li>v(i, j, 0) = v(i, j, 1)</li>
            <li>u(i, j, nz - 1) = u(i, j, nz - 2)</li>
            <li>v(i, j, nz - 1) = v(i, j, nz - 2)</li>
          </ul>
        </li>
      </ul>
      </p>
      <p>Also, we could have a situation where so few (perhaps zero) particles are close to a particular grid velocity that one or more of the <i>f</i><sub>*</sub> values corresponding to that grid velocity might be very small or zero. In that case, we certainly do not want to normalize (i.e., divide) the grid velocity by it! So, in that case, we shall set the grid velocity directly to zero instead. Based on that decision, let's complete our 3D algorithm for splatting particle velocities onto grid velocities:</p>
      <ul>
        <li>Let <i>p.pos</i> = (<i>x</i>, <i>y</i>, <i>z</i>) denote the position of the particle <i>p</i> at the current time step.</li>
        <li>Set every single value in all of the 3D arrays of grid velocities, <i>u</i><sub>grid</sub>, <i>v</i><sub>grid</sub>, and <i>w</i><sub>grid</sub>, to zero.</li>
        <li>As part of the staggered grid, just as we do with the 3D arrays <i>u</i><sub>grid</sub>, <i>v</i><sub>grid</sub>, and <i>w</i><sub>grid</sub>, store three additional 3D arrays, <i>f<sub>u</sub></i>, <i>f<sub>v</sub></i>, and <i>f<sub>w</sub></i>. Set all values in these arrays to zero as well.</li>
        <li>Part 1: Splat horizontal velocity of particle onto grid:
          <ul>
            <li>Let <i>p</i><sub>shifted</sub> = (<i>x</i>, <i>y</i> - &Delta;<i>x</i> / 2, <i>z</i> - &Delta;<i>x</i> / 2).</li>
            <li>Let (<i>i</i>, <i>j</i>, <i>k</i>) be the indices of the grid cell containing <i>p</i><sub>shifted</sub>.</li>
            <li>Let (<i>w</i><sub>0</sub>, <i>w</i><sub>1</sub>, <i>w</i><sub>2</sub>) be the barycentric weights of <i>p</i><sub>shifted</sub> in grid cell (<i>i</i>, <i>j</i>, <i>k</i>).</li>
            <li>splat(<i>u<sub>p</sub></i>, <i>w</i><sub>0</sub>, <i>w</i><sub>1</sub>, <i>w</i><sub>2</sub>, <i>i</i>, <i>j</i>, <i>k</i>, <i>u</i><sub>grid</sub>, <b><i>f<sub>u</sub></i></b>): This splats the particle's horizontal velocity, <i>u<sub>p</sub></i>, whose shifted position lies in cell (<i>i</i>, <i>j</i>, <i>k</i>) with barycentric weights (<i>w</i><sub>0</sub>, <i>w</i><sub>1</sub>, <i>w</i><sub>2</sub>), onto the relevant velocities in the 3D array, <i>u</i><sub>grid</sub>, of horizontal velocity components on the grid. Also, this function will accumulate the barycentric weight products (overlap volumes) of all particle contributions to each horizontal grid velocity.</li>
          <li>For each (<i>i</i>, <i>j</i>, <i>k</i>), divide <i>u</i>(<i>i</i>, <i>j</i>, <i>k</i>) by <i>f<sub>u</sub></i>(<i>i</i>, <i>j</i>, <i>k</i>), <b>except when <i>i</i> is 0, 1, <i>n<sub>x</sub></i> - 1, or <i>n<sub>x</sub></i>, as long as <i>f<sub>u</sub></i>(<i>i</i>, <i>j</i>, <i>k</i>) is not close to zero.</b></li>
          </ul>
        </li>
        <li>Part 2: Splat vertical velocity of particle onto grid:
          <ul>
            <li>Let <i>p</i><sub>shifted</sub> = (<i>x</i> - &Delta;<i>x</i> / 2, <i>y</i>, <i>z</i> - &Delta;<i>x</i> / 2).</li>
            <li>Let (<i>i</i>, <i>j</i>, <i>k</i>) be the indices of the grid cell containing <i>p</i><sub>shifted</sub>.</li>
            <li>Let (<i>w</i><sub>0</sub>, <i>w</i><sub>1</sub>, <i>w</i><sub>2</sub>) be the barycentric weights of <i>p</i><sub>shifted</sub> in grid cell (<i>i</i>, <i>j</i>, <i>k</i>).</li>
            <li>splat(<i>v<sub>p</sub></i>, <i>w</i><sub>0</sub>, <i>w</i><sub>1</sub>, <i>w</i><sub>2</sub>, <i>i</i>, <i>j</i>, <i>k</i>, <i>v</i><sub>grid</sub>, <b><i>f<sub>v</sub></i></b>): This splats the particle's vertical velocity, <i>v<sub>p</sub></i>, whose shifted position lies in cell (<i>i</i>, <i>j</i>, <i>k</i>) with barycentric weights (<i>w</i><sub>0</sub>, <i>w</i><sub>1</sub>, <i>w</i><sub>2</sub>), onto the relevant velocities in the 3D array, <i>v</i><sub>grid</sub>, of vertical velocity components on the grid. Also, this function will accumulate the barycentric weight products (overlap volumes) of all particle contributions to each vertical grid velocity.</li>
          <li>For each (<i>i</i>, <i>j</i>, <i>k</i>), divide <i>v</i>(<i>i</i>, <i>j</i>, <i>k</i>) by <i>f<sub>v</sub></i>(<i>i</i>, <i>j</i>, <i>k</i>), <b>except when <i>j</i> is 0, 1, <i>n<sub>y</sub></i> - 1, or <i>n<sub>y</sub></i>, as long as <i>f<sub>v</sub></i>(<i>i</i>, <i>j</i>, <i>k</i>) is not close to zero.</b></li>
          </ul>
        </li>
        <li>Part 3: Splat depth (<i>z</i> direction) velocity of particle onto grid:
          <ul>
            <li>Let <i>p</i><sub>shifted</sub> = (<i>x</i> - &Delta;<i>x</i> / 2, <i>y</i> - &Delta;<i>x</i> / 2, <i>z</i>).</li>
            <li>Let (<i>i</i>, <i>j</i>, <i>k</i>) be the indices of the grid cell containing <i>p</i><sub>shifted</sub>.</li>
            <li>Let (<i>w</i><sub>0</sub>, <i>w</i><sub>1</sub>, <i>w</i><sub>2</sub>) be the barycentric weights of <i>p</i><sub>shifted</sub> in grid cell (<i>i</i>, <i>j</i>, <i>k</i>).</li>
            <li>splat(<i>w<sub>p</sub></i>, <i>w</i><sub>0</sub>, <i>w</i><sub>1</sub>, <i>w</i><sub>2</sub>, <i>i</i>, <i>j</i>, <i>k</i>, <i>w</i><sub>grid</sub>, <b><i>f<sub>w</sub></i></b>): This splats the particle's depth velocity, <i>w<sub>p</sub></i>, whose shifted position lies in cell (<i>i</i>, <i>j</i>, <i>k</i>) with barycentric weights (<i>w</i><sub>0</sub>, <i>w</i><sub>1</sub>, <i>w</i><sub>2</sub>), onto the relevant velocities in the 3D array, <i>w</i><sub>grid</sub>, of depth velocity components on the grid. Also, this function will accumulate the barycentric weight products (overlap volumes) of all particle contributions to each depth grid velocity.</li>
            <li>For each (<i>i</i>, <i>j</i>, <i>k</i>), divide <i>w</i>(<i>i</i>, <i>j</i>, <i>k</i>) by <i>f<sub>w</sub></i>(<i>i</i>, <i>j</i>, <i>k</i>), <b>except when <i>k</i> is 0, 1, <i>n<sub>z</sub></i> - 1, or <i>n<sub>z</sub></i>, as long as <i>f<sub>w</sub></i>(<i>i</i>, <i>j</i>, <i>k</i>) is not close to zero.</b></li>
          </ul>
      </ul></p>
      <p>Finally, we've finished it! We've completed our description of the algorithm for splatting 3D particle velocities onto the staggered grid! Now, let's proceed to writing the C++ code for the complete particle-to-grid update!</p>
      <h2 id="Implementing_3D_Splatting_of_Particle_Velocities">Implementing 3D Splatting of Particle Velocities</h2>
      <p>We already implemented and tested our <code>floor</code> and <code>weights</code> functions. Now, we need to use these functions, together with our <code>StaggeredGrid</code> class, to implement the zeroing out of the velocity and velocity-weight arrays, cell label updating, splatting particle velocities onto the grid, normalizing those summed weighted velocities, and applying the boundary conditions on the velocity arrays. The code that ships with Bargteil and Shinar's course already shows how to implement this, but let's build it up in steps and ensure we do some error checking since it is very easy to introduce bugs, such as off-by-one errors, into computations like this.</p>
      <p>Well, hold on a second. If we're going to transfer velocities from particles to the grid... from where on Earth do we get the particles? We never had any particles in our StaggeredGrid code! Oh, maybe we need to <i>initialize</i> our code with some initial number of particles with some initial positions and velocities. Oh! And we also need to decide how big to make our grid, what its grid cell width should be, how long our simulation should run, and more. Let's follow the general approach taken in <code>fluid.cpp</code> from Bargteil and Shinar's course. However, we'll modify their exact approach to separate the responsibilities of different data structures more strictly to reduce the risk of side-effect bugs and make it easier to test parts of our code.</p>
      <p>This step of defining one-time starting parameters, or settings, for our code, is called <i>configuration</i>. These parameters, like the size of our grid, are fixed once the program starts running. We can ensure our code is never allowed to change these parameters once it starts by declaring the appropriate variables <code>const</code> and setting them upon construction of whatever data structure stores them.</p>
      <p>Let's list the parameters we need to set, based on Bargteil and Shinar's course's code:
      <ul>
        <li>&Delta;<i>t</i>: the time step size for the simulation</li>
        <li>Duration: the number of seconds for which our simulation shall run</li>
        <li><i>&rho;</i>: the density of our fluid, which will come into play later</li>
        <li>(<i>n<sub>x</sub></i>, <i>n<sub>y</sub></i>, <i>n<sub>z</sub></i>): the dimensions (number of grid cells in each coordinate direction) of our staggered grid</li>
        <li>&Delta;<i>x</i>: the width (side length) of a single grid cell (we assume all cells are cubes)</li>
        <li><i>l<sub>c</sub></i>: the 3D position of the lower corner of the staggered grid</li>
        <li>FLIP ratio: will come into play later</li>
        <li>Naming pattern for files we will output containing particle positions at each time step of the simulation</li>
      </ul></p>
      <p>The last parameter is included so that instead of just running and animating the simulation at the same time, we can instead first run the simulation and determine where all particles should be at each time step, and then separately animate the simulation. This allows us to view the simulation results without the lag resulting from trying to run the simulation in between animation frames. We'll implement that part of the code later, though. There are also a couple other parameters above that haven't come into play yet; we'll just include them for now so they'll be available when we need them, but we won't actually use them just yet.</p>
      <p>We'll need to store these configuration parameters, or settings, for our simulation somewhere in our code. Bargteil and Shinar's course's code uses a <code>struct</code> for this, but it's safer to use a <code>class</code> with <code>private</code> instance variables instead, so they cannot be accidentally altered by the rest of our code.</p>
      <p>Here is some isolated code just for reading and storing these simulation configuration parameters and reading initial particle positions and velocities, along with a test program to help with debugging. Let's create and move into a new directory, <code>incremental1</code>. In that directory, place the header file, <a target="_blank" href="https://github.com/unusualinsights/flip_pic_examples/blob/main/incremental1/SimulationParameters.h"><code>SimulationParameters.h</code></a>. Notice <code>SimulationParameters</code> can only have its instance variables assigned at construction since they are all declared <code>const</code>: this ensures those variables will never accidentally be changed during our simulation. The implementation file is <a target="_blank" href="https://github.com/unusualinsights/flip_pic_examples/blob/main/incremental1/SimulationParameters.cpp"><code>SimulationParameters.cpp</code></a>, which should also be in the new <code>incremental1</code> directory. Notice that the <code>SimulationParameters</code> class has a copy constructor declared, but in its implementation, it simply copies values and then causes the program to crash via an assertion failure. The comment in the header file for the copy constructor explains why we include this. In short, this allows us to double check that the C++ compiler is applying return value optimization and never actually creating a copy of a <code>SimulationParameters</code> object when we run our code.</p>
      <p>We could test just this part now, but I went ahead and also created the particle reading code. For the <code>Particle</code> data structure, I followed the structure of the code that ships with Bargteil and Shinar's course, just making a <code>struct</code> that could accidentally be changed, but I stick with this structure since it is actually quite convenient for our simulation code where we'll be changing these values frequently. The header file is <a target="_blank" href="https://github.com/unusualinsights/flip_pic_examples/blob/main/incremental1/Particle.h"><code>Particle.h</code></a> and the implementation file is <a target="_blank" href="https://github.com/unusualinsights/flip_pic_examples/blob/main/incremental1/Particle.cpp"><code>Particle.cpp</code></a>. Here is a test program, <a target="_blank" href="https://github.com/unusualinsights/flip_pic_examples/blob/main/incremental1/FluidSimulator.cpp"><code>FluidSimulator.cpp</code></a>, which will eventually become our fluid simulation driver program, but for now is just a quick test program for reading inputs. All of these files should also be in the <code>incremental1</code> directory.</p>
      <p>In addition, within the <code>incremental1</code> directory, we need the files <code>json/json.h</code> and <code>json/json-forwards.h</code>, which are open-source JSON reading code that ships with Bargteil and Shinar's course. I recommend getting those files directly from their course since the newer versions of the JSON reader online are far more complex now and probably overkill for our needs here. Also, within the <code>incremental1</code> directory, create an <code>inputs</code> directory, and in there you should add two files. First, <a target="_blank" href="https://github.com/unusualinsights/flip_pic_examples/blob/main/incremental1/inputs/fluid.json"><code>inputs/fluid.json</code></a>, which is virtually identical to the input file that ships with Bargteil and Shinar's course. Second, create a small test file of initial positions and velocities for the particles called <a target="_blank" href="https://github.com/unusualinsights/flip_pic_examples/blob/main/incremental1/inputs/test_particles.in"><code>inputs/test_particles.in</code></a>.</p>
      <p>Compile this code with this command:</p>
      <div class="outer"><div class="inner"><pre>g++ *.cpp -o FluidSimulator -I/usr/include/eigen3/</pre></div></div>
      <p>And run it using this command:</p>
      <div class="outer"><div class="inner"><pre>./FluidSimulator inputs/fluid.json</pre></div></div>
      <p>Here is the output I got:</p>
      <div class="outer"><div class="inner"><pre>

dt = 0.00111111 seconds
duration = 5 seconds
density = 1000
Grid has 25 x 50 x 25 grid cells.
lower corner is -0.125  -0.25 -0.125
dx = 0.01
flip ratio = 1
output file name pattern = fluid.%03d.part
Read 8 particles.

8 particles:
pos = -0.095  -0.03 -0.005, vel = 0 0 0
pos =      -0.095       -0.03 1.56125e-17, vel = 0 0 0
pos = -0.095  -0.03  0.005, vel = 0 0 0
pos = -0.095 -0.025 -0.015, vel = 0 0 0
pos = -0.095 -0.025  -0.01, vel = 0 0 0
pos = -0.095 -0.025 -0.005, vel = 0 0 0
pos =      -0.095      -0.025 1.56125e-17, vel = 0 0 0
pos = -0.095 -0.025  0.005, vel = 0 0 0

          </pre></div></div>
          <p>This seems to match wth the input files above, so we think our code is working so far! Now, we can use the <code>SimulationParameters</code> object to initialize our <code>StaggeredGrid</code> object. We can also make the <code>StaggeredGrid</code> store a <code>const</code> copy of the lower corner position and grid cell width parameters, which will allow us to put functions like <code>floor</code> into the <code>StaggeredGrid</code> class, which can handle the subtraction of the lower corner position from a point's position all by itself, to simplify the computation of the indices of the grid cell that contains a particular point, for example. Plus, we need to add a data type for the grid cell labels (SOLID, FLUID, EMPTY), the 3D array of cell labels, and the 3D arrays of accumulated velocity-weights (<i>f<sub>u</sub></i>, <i>f<sub>v</sub></i>, and <i>f<sub>w</sub></i>).</p>
          <p>Let's create a new directory, <code>incremental2</code>. Copy into <code>incremental2</code> the following files from <code>incremental1</code>: <code>Particle.cpp</code>, <code>Particle.h</code>, <code>SimulationParameters.cpp</code>, <code>SimulationParameters.h</code>, the entire <code>inputs</code> directory, the entire <code>json</code> directory, and <code>jsoncpp.cpp</code>. From <code>incremental0</code>, copy into <code>incremental2</code> the files <code>Array3D.h</code> and <code>Array3DTest.cpp</code>. Also copy over the <code>StaggeredGrid*</code> files.
          <p>Note that we will now modify a few of these files. In our new <a target="_blank" href="https://github.com/unusualinsights/flip_pic_examples/blob/main/incremental2/Array3D.h"><code>Array3D.h</code></a>, we add a new <code>operator=</code> method that we'll use to assign every value of a 3D array to a fixed value--zero, in particular. We also add testing for this new method into <a target="_blank" href="https://github.com/unusualinsights/flip_pic_examples/blob/main/incremental2/Array3DTest.cpp"><code>Array3DTest.cpp</code></a>. Compile it with <code>g++ Array3DTest.cpp</code> to make sure the code is working correctly. Here is our modified <code>StaggeredGrid</code> class with the two additional parameters: the header file, <a target="_blank" href="https://github.com/unusualinsights/flip_pic_examples/blob/main/incremental2/StaggeredGrid.h"><code>StaggeredGrid.h</code></a> and the implementation file, <a target="_blank" href="https://github.com/unusualinsights/flip_pic_examples/blob/main/incremental2/StaggeredGrid.cpp"><code>StaggeredGrid.cpp</code></a>. We also modify our test code for this class in <a target="_blank" href="https://github.com/unusualinsights/flip_pic_examples/blob/main/incremental2/StaggeredGridTest.cpp"><code>StaggeredGridTest.cpp</code></a>. All of this should go into the <code>incremental2</code> directory. I recommend running <code>clang-format</code> on all files if you haven't been doing so already. To run this last test, which exercises the entire <code>StaggeredGrid</code> class' public interface we've built so far including the particle-to-grid transfer, compile the code with:</p>
          <div class="outer">
            <div class="inner">
              <pre>g++ jsoncpp.cpp Particle.cpp SimulationParameters.cpp StaggeredGrid.cpp StaggeredGridTest.cpp -I/usr/include/eigen3/</pre>
            </div>
          </div>
          <p>Then run it with:</p>
          <div class="outer">
            <div class="inner">
              <pre>./a.out inputs/fluid.json</pre>
            </div>
          </div>
          <p>You should see a message printed out saying that all assertion tests passed, if everything worked correctly! Don't forget to clean up with <code>rm a.out</code>. We are really at the point where creating a makefile to automatically list the correct files to compile for each test program, and to clean up afterward, would be very convenient, but we'll hold off on this until or unless it gets a bit more unwieldy.</p>
          <p>We have now completed the particle-to-grid velocity transfer code in C++ and tested it to give us confidence it's implemented correctly! You can compare our code to the particle-to-grid portion of the fluid code in <a target="_blank" href="https://cal.cs.umbc.edu/Courses/PhysicsBasedAnimation/">Bargteil and Shinar's SIGGRAPH course</a>. What remains for us to implement here is the advection (updating position) of particles based on velocity and pressure projection, where we calculate pressure values for the fluid that keep it divergence-free. To understand the theoretical underpinnings of these concepts along with how they lead to the algorithms and implementation strategies we're exploring, I highly recommend reading <a target="_blank" href="https://www.cs.ubc.ca/~rbridson/fluidsimulation/">Robert Bridson's excellent book on fluid simulation</a> as well as <a target="_blank" href="https://www.cs.ubc.ca/~rbridson/fluidsimulation/fluids_notes.pdf">Bridson and M&uuml;ller-Fischer's course notes</a>.</p>
          <h1 id="Advecting_Particle_Velocities">Advecting Particle Velocities</h1>
          <p>In this section, we will model and then implement the movement of each particle based on its velocity, which we estimate by averaging nearby grid velocities. We'll start by describing velocity advection in 1D. The concept is exactly the same in 2D and 3D, but with, you guessed it, more dimensions!</p>
          <h2 id="Advection_in_1D">Advection in 1D</h2>
          <p>Pretend we have a grid cell <i>i</i> in one dimension, which has a point <i>x<sub>i</sub></i> &isin; <b>R</b> as its left boundary and <i>x</i><sub><i>i</i> + 1</sub> &isin; <b>R</b> as its right boundary. Recall that <i>linear interpolation</i> just means that a point <i>x</i><sub>shifted</sub> &isin; [<i>x<sub>i</sub></i>, <i>x</i><sub><i>i</i> + 1</sub>] is equal to a weighted average of those two cell boundary points. That is, if <i>x</i><sub>shifted</sub> is halfway between <i>x<sub>i</sub></i> and <i>x</i><sub><i>i</i> + 1</sub>, then <i>x</i><sub>shifted</sub> = &frac12;<i>x<sub>i</sub></i> + &frac12;<i>x</i><sub><i>i</i> + 1</sub>. If <i>x</i><sub>shifted</sub> is three times farther away from <i>x</i><sub><i>i</i> + 1</sub> than it is from <i>x<sub>i</sub></i>, that is, it's one-fourth of the way over from <i>x<sub>i</sub></i> to <i>x</i><sub><i>i</i> + 1</sub>, then <i>x</i><sub>shifted</sub> = &frac34;<i>x<sub>i</sub></i> + &frac14;<i>x</i><sub><i>i</i> + 1</sub>. In general, if <i>w</i><sub>0</sub> is any real number between 0 and 1, inclusive, then if <i>x</i><sub>shifted</sub> is <i>w</i><sub>0</sub> of the way over to <i>x</i><sub><i>i</i> + 1</sub> from <i>x<sub>i</sub></i>, then <i>x</i><sub>shifted</sub> = (1 - <i>w</i><sub>0</sub>)<i>x<sub>i</sub></i> + <i>w</i><sub>0</sub><i>x</i><sub><i>i</i> + 1</sub>:</p>
          <p><img src="LinearInterp.png" style="border-style: none;" class="center"></img></p>
          <p>Now assume, like we did in the past, that there is a one-dimensional fluid flowing along this one-dimensional line. We would represent this fluid's velocity with a velocity vector at each grid cell boundary. So, suppose the fluid velocity at <i>x<sub>i</sub></i> is <i>u<sub>i</sub></i> and the fluid velocity at <i>x</i><sub><i>i</i> + 1</sub> is <i>u</i><sub><i>i</i> + 1</sub>. What is the fluid velocity at <i>x</i><sub>shifted</sub>?</p>
          <p>Well, in real life, who knows? We'll assume in this tutorial that grid cells are small enough that no complicated variations in fluid flow happen within a single grid cell. (This is certainly <i>not</i> a universal assumption in fluid dynamics; for example, look up <a target="_blank" href="https://en.wikipedia.org/wiki/Large_eddy_simulation">large-eddy simulation</a> where you actually include a model of what happens at scales smaller than a grid cell!) So, let's just assume that within this grid cell, the fluid velocity varies linearly. In other words, just like the position of <i>x</i><sub>shifted</sub> is a linear combination of the positions of <i>x<sub>i</sub></i> and <i>x</i><sub><i>i</i> + 1</sub>, let's assume the velocity of the fluid at <i>x</i><sub>shifted</sub>, which we shall denote by <i>u</i><sub>shifted</sub>, is also a linear combination of the fluid velocities at <i>x<sub>i</sub></i> and <i>x</i><sub><i>i</i> + 1</sub>, which we shall denote by <i>u<sub>i</sub></i> and <i>u</i><sub><i>i</i> + 1</sub>, respectively, with the same weights:
          <p><img src="AdvectVelInterp1D.png" style="border-style: none;" class="center"></img></p>
          <p>We explained the concept of advection earlier when introducing the Navier-Stokes momentum equation. So, how do we "advect" fluid velocity in 1D? We'll just draw imaginary grid cells around <i>x<sub>i</sub></i>, <i>x</i><sub><i>i</i> + 1</sub>, and the particle's location, which we denote by <i>x</i>. A grid cell in 1D is just a closed interval of the real line of length &Delta;<i>x</i>:</p>
          <p><img src="GridCellI.png" style="border-style: none;" class="center"></img></p>
          <p>We'll assume the particle's velocity is just the fluid velocity at the particle's location, <i>x</i>, assuming velocity varies linearly between grid points. In other words, we'll look at what fraction of the particle-centered grid cell overlaps with the imaginary grid cell centered at <i>x<sub>i</sub></i> and what fraction of the particle-centered grid cell overlaps with the imaginary grid cell centered at <i>x</i><sub><i>i</i> + 1</sub>:</p>
          <p><img src="ImaginaryGridCells1D.png" style="border-style: none;" class="center"></img></p>
          <p>We'll assume the particle's velocity is just a weighted average of the velocities <i>u<sub>i</sub></i> and <i>u</i><sub><i>i</i> + 1</sub> at the grid points around the particle, with the weights being these ratios of overlap. Once we have calculated the particle's velocity like that, we'll just multiply it by &Delta;<i>t</i> and add it to the particle's current position, so that at time <i>t</i> + &Delta;<i>t</i>, the particle will be located at <i>x</i> plus &Delta;<i>t</i> times that velocity we just calculated. But okay that all sounds very fancy; exactly what are these weights, how do we figure them out, and what does the whole computation actually look like? Let's look at the same figure again but with the cells made thicker and with labels for the ends of the particle-centered cell and for the meeting point of the grid-point-centered cells:</p>
          <p><img src="Advect1DOverlap.png" style="border-style: none;" class="center"></img></p>
          <p>If we let <i>w</i><sub>0</sub> be the ratio of distance of <i>x</i> from <i>x<sub>i</sub></i> versus distance of <i>x</i><sub><i>i</i> + 1</sub> from <i>x<sub>i</sub></i> as in the earlier description of linear interpolation, then <i>x</i> - <i>x<sub>i</sub></i> = <i>w</i><sub>0</sub>&Delta;<i>x</i>. That is, if <i>w</i><sub>0</sub> = (<i>x</i> - <i>x<sub>i</sub></i>) / (<i>x</i><sub><i>i</i> + 1</sub> - <i>x<sub>i</sub></i>), then noting that <i>x</i><sub><i>i</i> + 1</sub> - <i>x<sub>i</sub></i> = &Delta;<i>x</i>, then <i>w</i><sub>0</sub> = (<i>x</i> - <i>x<sub>i</sub></i>) / &Delta;<i>x</i>, so <i>x</i> - <i>x<sub>i</sub></i> = <i>w</i><sub>0</sub>&Delta;<i>x</i>. See the earlier diagrams if you're confused about which points are separated by a distance of &Delta;<i>x</i>, the width of a grid cell. Then the amount of overlap between the <i>x</i>-centered imaginary grid cell and the <i>x<sub>i</sub></i>-centered imaginary grid cell is (<i>x<sub>i</sub></i> + &Delta;<i>x</i>/2) - (<i>x</i> - &Delta;<i>x</i>/2) = <i>x<sub>i</sub></i> - <i>x</i> + &Delta;<i>x</i> = -<i>w</i><sub>0</sub>&Delta;<i>x</i> + &Delta;<i>x</i> = (1 - <i>w</i><sub>0</sub>)&Delta;<i>x</i>. Similarly, the length of overlap between the <i>x</i>-centered imaginary grid cell and the <i>x</i><sub><i>i</i> + 1</sub>-centered imaginary grid cell is (<i>x</i> + &Delta;<i>x</i>/2) - (<i>x<sub>i</sub></i> + &Delta;<i>x</i>/2) = <i>x</i> - <i>x<sub>i</sub></i> = <i>w</i><sub>0</sub>&Delta;<i>x</i>. This explains how the labels in the figure above are derived.</p>
          <p><img src="Advect1DVelAvg.png" style="border-style: none;" class="center"></img></p>
          <p>We assume the velocity of a particle located at <i>x</i> is the weighted average of the two grid velocities around it, with the weights being the fraction of overlap between the particle-centered imaginary grid cell and each velocity's imaginary grid cell. In this case, the fraction of the <i>x<sub>i</sub></i>-centered imaginary grid cell overlapped by the <i>x</i>-centered imaginary grid cell is 1 - <i>w</i><sub>0</sub>. So, we multiply 1 - <i>w</i><sub>0</sub> by <i>u<sub>i</sub></i> and say that is the contribution of the fluid velocity, <i>u<sub>i</sub></i>, at grid point <i>x<sub>i</sub></i>, to the estimated velocity of the particle. The fraction of the <i>x</i><sub><i>i</i> + 1</sub>-centered imaginary grid cell overlapped by the <i>x</i>-centered imaginary grid cell is <i>w</i><sub>0</sub>. So, we multiply <i>w</i><sub>0</sub> by <i>u</i><sub><i>i</i> + 1</sub> and say that is the contribution of the fluid velocity, <i>u</i><sub><i>i</i> + 1</sub>, at grid point <i>x</i><sub><i>i</i> + 1</sub>, to the estimated velocity of the particle. So, the total estimated velocity of the particle is <i>u</i> = (1 - <i>w</i><sub>0</sub>)<i>u<sub>i</sub></i> + <i>w</i><sub>0</sub><i>u</i><sub><i>i</i> + 1</sub>. In many ways this is the same logic as splatting, but in the opposite direction: going from grid velocities to a particle velocity based on the amount of overlap between a particle-centered cell and grid point-centered cells where velocities are located.</p>
          <p>Once we have determined this velocity, <i>u</i>, for the particle, then advection would simply be updating the particle's position from <i>x</i> at time <i>t</i> to <i>x</i> + <i>u</i>&Delta;<i>t</i> at time <i>t</i> + &Delta;<i>t</i>. We used linear interpolation to calculate the particle's estimated velocity, <i>u</i> from the fluid velocity at neighboring grid points.</p>
          <p>Note that the calculation of the grid cell overlap fractions above involves shifting half a grid cell width back from the particle's position to find the left end of the imaginary particle-centered grid cell, landing in either the particle's current cell or the cell to the left, just like we did with splatting. In this section I could have described the computation that way again, but I chose to just forget about which cell the left end of the particle-centered imaginary cell lies since the end result is still just the fraction of overlap between the particle-centered imaginary cell and the velocity-/grid-point-centered imaginary cells around it.</p>
          <h2 id="Advection_in_2D">Advection in 2D</h2>
          <p>This works very similarly in 2D. We'll estimate the velocity of a particle first just for the horizontal grid velocities using bilinear interpolation, i.e., areas of overlap instead of lengths of overlap, and then once again for the vertical grid velocities.</p>
          <p>Recall that when we did splatting in 2D we shifted downward by a half grid cell width to find the lowest <i>y</i> value of the imaginary particle-centered grid cell. We do the same thing here, but as with the 1D case above, I'll ignore which grid cell we end up in after that shift and just jump to the end result, which again is just the fraction of the imaginary particle-centered grid cell's overlap with its nearby grid-point-/velocity-centered grid cells.</p>
          <p>For horizontal grid velocities, this is:</p>
          <p><img src="Advect2DHorizVelInterpHalves.png" style="border-style: none;" class="center"></img></p>
          <p>Changing the indices to integers as they would be in the code:</p>
          <p><img src="Advect2DHorizVelInterpInts.png" style="border-style: none;" class="center"></img></p>
          <p><b><i>u<sub>p</sub></i></b> in these figures is the horizontal component of the velocity we estimate for the particle based on the horizontal grid velocities. This calculation of overlap areas between these imaginary grid cells is identical to the calculation we did for splatting velocities in 2D. This computation where we essentially do linear interpolation in 2D instead of 1D to get the overlap areas is called <i>bilinear interpolation</i>.</p>
          <p>Let's go a bit more step-by-step for the vertical velocities since we never illustrated them during the splatting section earlier. First, we shift leftward (the negative <i>x</i> direction) from the particle's location by half a grid cell width and compute the barycentric weights of the resulting position:</p>
          <p><img src="Advect2DVerticalVel1.png" style="border-style: none;" class="center"></img></p>
          <p>The vertical grid velocities are located at the horizontal boundaries between grid cells. The vertical grid velocities of interest are the ones around the particle's location:</p>
          <p><img src="Advect2DVerticalVel2.png" style="border-style: none;" class="center"></img></p>
          <p>Now, let's draw imaginary grid cells around the points where each of those vertical velocities are defined:</p>
          <p><img src="Advect2DVerticalVel3.png" style="border-style: none;" class="center"></img></p>
          <p>Then just like in the horizontal velocity case, the vertical component of the particle's velocity will be estimated, via bilinear interpolation of the barycentric weights of the shifted particle position, based on those vertical grid velocities:</p>
          <p><img src="Advect2DVerticalVel4.png" style="border-style: none;" class="center"></img></p>
          <p>Or, removing the &frac12;s and converting to the integer indices we'll use in our C++ code:</p>
          <p><img src="Advect2DVerticalVel5.png" style="border-style: none;" class="center"></img></p>
          <p>So, the resulting velocity of the particle that we'll use for advection is just (<i>u<sub>p</sub></i>, <i>v<sub>p</sub></i>). Our advection step is completed when we update the particle's position from its current position, <i>x</i>, to <i>x</i> + (<i>u<sub>p</sub></i>, <i>v<sub>p</sub></i>)&Delta;<i>t</i>.</p>
          <p>Notice something convenient above: the formula for <i>u<sub>p</sub></i> is exactly the same as the formula for <i>v<sub>p</sub></i>, but just with '<i>u</i>'s instead of '<i>v</i>'s! This is a consequence of our integer indexing scheme. We'll apply this same pattern in 3D in the next section.</p>
          <h2 id="Advection_in_3D">Advection in 3D</h2>
          <p>I went through advection in 1D and 2D in great detail because I am absolutely <i>not</i> going to try to draw the 3D volumes of overlap for 3D advection. Instead, we'll just present the formulas and procedure without any illustrations. In 1D, we did linear interpolation using a barycentric weight to determine the particle's velocity for advection. In 2D, we used bilinear interpolation of a point's two barycentric weights. So, in 3D, we use <i>trilinear interpolation</i> using <i>three</i> barycentric weights to compute a velocity for each particle based on grid velocities.</p>
          <p>The velocity we'll assign to a particle <i>p</i>, using the integer indices we'll use in our C++ code, will be (<i>u<sub>p</sub></i>, <i>v<sub>p</sub></i>, <i>w<sub>p</sub></i>) where <i>u<sub>p</sub></i> is
          <ul>
            <li>&nbsp;&nbsp;&nbsp;(1 - <i>w</i><sub>0</sub>) &middot; (1 - <i>w</i><sub>1</sub>) &middot; (1 - <i>w</i><sub>2</sub>) &middot; <i>u</i><sub><i>i</i>, <i>j</i>, <i>k</i></sub></li>
            <li> + (1 - <i>w</i><sub>0</sub>) &middot; (1 - <i>w</i><sub>1</sub>) &middot; <i>w</i><sub>2</sub> &middot; <i>u</i><sub><i>i</i>, <i>j</i>, <i>k</i> + 1</sub></li>
            <li> + (1 - <i>w</i><sub>0</sub>) &middot; <i>w</i><sub>1</sub> &middot; (1 - <i>w</i><sub>2</sub>) &middot; <i>u</i><sub><i>i</i>, <i>j</i> + 1, <i>k</i></sub></li>
            <li> + (1 - <i>w</i><sub>0</sub>) &middot; <i>w</i><sub>1</sub> &middot; <i>w</i><sub>2</sub> &middot; <i>u</i><sub><i>i</i>, <i>j</i> + 1, <i>k</i> + 1</sub></li>
            <li>+ <i>w</i><sub>0</sub> &middot; (1 - <i>w</i><sub>1</sub>) &middot; (1 - <i>w</i><sub>2</sub>) &middot; <i>u</i><sub><i>i</i> + 1, <i>j</i>, <i>k</i></sub></li>
            <li> + <i>w</i><sub>0</sub> &middot; (1 - <i>w</i><sub>1</sub>) &middot; <i>w</i><sub>2</sub> &middot; <i>u</i><sub><i>i</i> + 1, <i>j</i>, <i>k</i> + 1</sub></li>
            <li> + <i>w</i><sub>0</sub> &middot; <i>w</i><sub>1</sub> &middot; (1 - <i>w</i><sub>2</sub>) &middot; <i>u</i><sub><i>i</i> + 1, <i>j</i> + 1, <i>k</i></sub></li>
            <li> + <i>w</i><sub>0</sub> &middot; <i>w</i><sub>1</sub> &middot; <i>w</i><sub>2</sub> &middot; <i>u</i><sub><i>i</i> + 1, <i>j</i> + 1, <i>k</i> + 1</sub>,</li>
          </ul>
          </p>
          <p><i>v<sub>p</sub></i> is
          <ul>
            <li>&nbsp;&nbsp;&nbsp;(1 - <i>w</i><sub>0</sub>) &middot; (1 - <i>w</i><sub>1</sub>) &middot; (1 - <i>w</i><sub>2</sub>) &middot; <i>v</i><sub><i>i</i>, <i>j</i>, <i>k</i></sub></li>
            <li> + (1 - <i>w</i><sub>0</sub>) &middot; (1 - <i>w</i><sub>1</sub>) &middot; <i>w</i><sub>2</sub> &middot; <i>v</i><sub><i>i</i>, <i>j</i>, <i>k</i> + 1</sub></li>
            <li> + (1 - <i>w</i><sub>0</sub>) &middot; <i>w</i><sub>1</sub> &middot; (1 - <i>w</i><sub>2</sub>) &middot; <i>v</i><sub><i>i</i>, <i>j</i> + 1, <i>k</i></sub></li>
            <li> + (1 - <i>w</i><sub>0</sub>) &middot; <i>w</i><sub>1</sub> &middot; <i>w</i><sub>2</sub> &middot; <i>v</i><sub><i>i</i>, <i>j</i> + 1, <i>k</i> + 1</sub></li>
            <li>+ <i>w</i><sub>0</sub> &middot; (1 - <i>w</i><sub>1</sub>) &middot; (1 - <i>w</i><sub>2</sub>) &middot; <i>v</i><sub><i>i</i> + 1, <i>j</i>, <i>k</i></sub></li>
            <li> + <i>w</i><sub>0</sub> &middot; (1 - <i>w</i><sub>1</sub>) &middot; <i>w</i><sub>2</sub> &middot; <i>v</i><sub><i>i</i> + 1, <i>j</i>, <i>k</i> + 1</sub></li>
            <li> + <i>w</i><sub>0</sub> &middot; <i>w</i><sub>1</sub> &middot; (1 - <i>w</i><sub>2</sub>) &middot; <i>v</i><sub><i>i</i> + 1, <i>j</i> + 1, <i>k</i></sub></li>
            <li> + <i>w</i><sub>0</sub> &middot; <i>w</i><sub>1</sub> &middot; <i>w</i><sub>2</sub> &middot; <i>v</i><sub><i>i</i> + 1, <i>j</i> + 1, <i>k</i> + 1</sub>,</li>
          </ul>
          </p>
          <p>and <i>w<sub>p</sub></i> is
          <ul>
            <li>&nbsp;&nbsp;&nbsp;(1 - <i>w</i><sub>0</sub>) &middot; (1 - <i>w</i><sub>1</sub>) &middot; (1 - <i>w</i><sub>2</sub>) &middot; <i>w</i><sub><i>i</i>, <i>j</i>, <i>k</i></sub></li>
            <li> + (1 - <i>w</i><sub>0</sub>) &middot; (1 - <i>w</i><sub>1</sub>) &middot; <i>w</i><sub>2</sub> &middot; <i>w</i><sub><i>i</i>, <i>j</i>, <i>k</i> + 1</sub></li>
            <li> + (1 - <i>w</i><sub>0</sub>) &middot; <i>w</i><sub>1</sub> &middot; (1 - <i>w</i><sub>2</sub>) &middot; <i>w</i><sub><i>i</i>, <i>j</i> + 1, <i>k</i></sub></li>
            <li> + (1 - <i>w</i><sub>0</sub>) &middot; <i>w</i><sub>1</sub> &middot; <i>w</i><sub>2</sub> &middot; <i>w</i><sub><i>i</i>, <i>j</i> + 1, <i>k</i> + 1</sub></li>
            <li>+ <i>w</i><sub>0</sub> &middot; (1 - <i>w</i><sub>1</sub>) &middot; (1 - <i>w</i><sub>2</sub>) &middot; <i>w</i><sub><i>i</i> + 1, <i>j</i>, <i>k</i></sub></li>
            <li> + <i>w</i><sub>0</sub> &middot; (1 - <i>w</i><sub>1</sub>) &middot; <i>w</i><sub>2</sub> &middot; <i>w</i><sub><i>i</i> + 1, <i>j</i>, <i>k</i> + 1</sub></li>
            <li> + <i>w</i><sub>0</sub> &middot; <i>w</i><sub>1</sub> &middot; (1 - <i>w</i><sub>2</sub>) &middot; <i>w</i><sub><i>i</i> + 1, <i>j</i> + 1, <i>k</i></sub></li>
            <li> + <i>w</i><sub>0</sub> &middot; <i>w</i><sub>1</sub> &middot; <i>w</i><sub>2</sub> &middot; <i>w</i><sub><i>i</i> + 1, <i>j</i> + 1, <i>k</i> + 1</sub>.</li>
          </ul>
          </p>
          <p>Notice how the indices and interpolation calculations are identical for <i>u</i>, <i>v</i>, and <i>w</i>. In other words, if we had a single function to calculate this trilinear interpolation of velocity values for a given grid cell index, (<i>i</i>, <i>j</i>, <i>k</i>), then we could simply pass the appropriate 3D array, <i>u</i>, <i>v</i>, or <i>w</i>, into that function to get the trilinearly interpolated velocity component we want. Once we have done this trilinear interpolation for <i>u</i>, <i>v</i>, and <i>w</i> for each particle's position, <i>x</i> &isin; <b>R</b><sup>3</sup>, we then compute the particle's position at the next time step as <i>x</i> + (<i>u<sub>p</sub></i>, <i>v<sub>p</sub></i>, <i>w<sub>p</sub></i>)&Delta;<i>t</i>.</p>
          <p>Recall that we <a target="_blank" href="#Handling_Boundary_and_Cell_Labels">labeled grid cells on the boundary of the grid as SOLID</a>. That means fluid particles should never move into the solid grid cells. So, let's also add a step to our advection algorithm here: if the computed particle position at the next time step, <i>x</i> + (<i>u<sub>p</sub></i>, <i>v<sub>p</sub></i>, <i>w<sub>p</sub></i>)&Delta;<i>t</i>, goes beyond the outermost non-SOLID grid cells, then let's set the particle to the farthest out coordinate values it can possibly have, with a tiny extra buffer room to deal with the precision errors that can occur with floating-point numbers.</p>
          <h2 id="Implementing_3D_Advection">Implementing 3D Advection</h2>
          <p>Copy the code from the <code>incremental2</code> folder to a new <code>incremental3</code> folder. Based on the algorithm description above, we add an <code>Advect</code> function to the <code>StaggeredGrid</code> class that takes a single <code>Particle</code>'s position and returns the position at the next time step that results from advection of the fluid velocity at that particle's location, which itself is computed via trilinear interpolation as above. The new <code>Advect</code> function is added to <a target="_blank" href="https://github.com/unusualinsights/flip_pic_examples/blob/main/incremental3/StaggeredGrid.h">StaggeredGrid.h</a> and <a target="_blank" href="https://github.com/unusualinsights/flip_pic_examples/blob/main/incremental3/StaggeredGrid.cpp">StaggeredGrid.cpp</a>. A test of the advection code is added to <a target="_blank" href="https://github.com/unusualinsights/flip_pic_examples/blob/main/incremental3/StaggeredGridTest.cpp">StaggeredGridTest.cpp</a>. Note that our test does not check whether the code correctly clamped the particle positions to the non-solid cells after advection. I simply neglected to add this earlier and decided to leave it untested for now.</p>
          <p>Compile and run this code just like you did for the code in the <code>incremental2</code> folder earlier. Clean it up by deleting <code>a.out</code> when you're done running it.</p>
          <h1 id="Applying_Body_Forces">Applying Body Forces</h1>
          <p>The forces resulting from internal pressure and viscosity of a fluid are two of the terms in the Navier-Stokes momentum equation governing our fluid flow model. Another term is the body forces term, which is often just a gravity term. In our fluid simulation, we'll simply apply a gravitational acceleration throughout our fluid by subtracting &Delta;<i>t</i> &middot; 9.80665 m/s<sup>2</sup> from all vertical velocities in our staggered grid. Accordingly, we make a copy of our directory, <code>incremental3</code>, called <code>incremental4</code>, in which we update <a target="_blank" href="https://github.com/unusualinsights/flip_pic_examples/blob/main/incremental4/StaggeredGrid.h">StaggeredGrid.h</a>, <a target="_blank" href="https://github.com/unusualinsights/flip_pic_examples/blob/main/incremental4/StaggeredGrid.cpp">StaggeredGrid.cpp</a>, and <a target="_blank" href="https://github.com/unusualinsights/flip_pic_examples/blob/main/incremental4/StaggeredGridTest.cpp">StaggeredGridTest.cpp</a> to include and test a new function, <code>ApplyGravity</code>, which applies exactly this subtraction to the grid's vertical velocities.</p>
          <p>Compile and run this code just like you did for the code in the <code>incremental2</code> and <code>incremental3</code> folders earlier. Clean it up by deleting <code>a.out</code> when you're done running it.</p>
          <p>Note that our changes to the grid velocities will likely not meet our boundary conditions we described earlier during splatting. So, we call the same function to fix the boundary velocities that we did during splatting, after applying gravitational acceleration to our vertical velocities!</p>
          <h1 id="Pressure_Projection">Pressure Projection</h1>
          <p>So far we have added the effects of the advection term and the body forces (gravity) term. We will now incorporate the pressure term and the incompressibility constraint. Recall that the pressure projection step is intended to compute a pressure function for our fluid that causes its velocity field to be divergence-free, or volume-conserving. Conceptually, <i>the purpose of pressure is to conserve volume</i>, and recalling that the incompressibility a.k.a. zero-divergence a.k.a. volume-conserving constraint was just a simplication of mass conservation, we can say the purpose of pressure is to conserve the mass of the fluid.</p>
          <h2 id="Velocity_Update_via_Discrete_Pressure_Gradient">Velocity Update via the Discrete Pressure Gradient</h2>
          <p>As explained in Chapter 4 of <a target="_blank" href="https://www.cs.ubc.ca/~rbridson/fluidsimulation/fluids_notes.pdf">Bridson and M&uuml;ller-Fischer's course notes</a>, we split our Euler equations so that we started with an initial velocity field, then found a velocity field that incorporates the advection term, and then found a velocity field that incorporates the gravity term. Now, we want to solve the equation <i>&part;</i><b>u</b>/<i>&part;t</i> = -(1/<i>&rho;</i>)&nabla;<i>p</i> by discretizing it to (<b>u</b><sub>next</sub> - <b>u</b>) / &Delta;<i>t</i> = -(1/<i>&rho;</i>)(<i>p</i><sub>next</sub> - <i>p</i>) / &Delta;<i>x</i>, and find a pressure field <i>p</i> such that solving for the next time step's velocity field <b>u</b><sub>next</sub> satisfies the incompressibility constraint &nabla; &middot; <b>u</b><sub>next</sub> = 0 and the solid wall boundary conditions. The idea here is that the "current" velocity field <b>u</b> already incorporated the advection and gravity terms from the Euler momentum equation, so we pretend the only term we have left to add is the pressure gradient term subject to the incompressibility constraint. Notice in that discretized version of the remaining terms in the Euler momentum equation, <b>u</b><sub>next</sub> refers to the next velocity <i>temporally</i>, i.e., at the next time step while <i>p</i><sub>next</sub> refers to the next pressure <i>spatially</i>, e.g., in an adjacent grid cell. That is, <b>u</b> really means <b>u</b>(<i>x</i>, <i>y</i>, <i>z</i>, <i>t</i>) and <b>u</b><sub>next</sub> is really shorthand for <b>u</b>(<i>x</i>, <i>y</i>, <i>z</i>, <i>t</i> + &Delta;<i>t</i>), <i>p</i> is <i>p</i>(<i>x</i>, <i>y</i>, <i>z</i>, <i>t</i>), and <i>p</i><sub>next</sub> is shorthand for <i>p</i>(<i>x</i> + &Delta;<i>x</i>, <i>y</i> + &Delta;<i>x</i>, <i>z</i> + &Delta;<i>x</i>, <i>t</i>). Solving for <b>u</b><sub>next</sub> in the discretized differential equation yields <b>u</b><sub>next</sub> = <b>u</b> - (&Delta;<i>t</i>/<i>&rho;</i>)(<i>p</i><sub>next</sub> - <i>p</i>) / &Delta;<i>x</i>. But in the staggered grid we break this all up by dimension. First, let's examine a cell (<i>i</i>, <i>j</i>, <i>k</i>) and its neighbors to the right, top, and front and recall that the pressure value for each grid cell represents the fluid pressure at the cell's center:</p>
          <p><img src="PressureNeighbors.png" style="border-style: none;" class="center"></img></p>
          <p>Then, assuming we have already found a pressure function that makes the velocity field divergence-free, the fluid velocities at the next time step in the grid, for any fluid velocity bordering a grid cell marked as containing fluid, are:</p>
          <p><img src="PressureUpdate.png" style="border-style: none;" class="center"></img></p>
          <h2 id="Discrete_Divergence_of_Velocity_Field">Discrete Divergence of the Velocity Field</h2>
          <p>The velocity field's divergence is &nabla; &middot; <b>u</b> = <i>&part;</i><b>u</b>/<i>&part;x</i> + <i>&part;</i><b>u</b>/<i>&part;y</i> + <i>&part;</i><b>u</b>/<i>&part;z</i>. Discretizing the three spatial derivatives on the right-hand side of that equation, across any grid cell marked as a fluid gives us the <i>discrete divergence</i> of the velocity field for cell (<i>i</i>, <i>j</i>, <i>k</i>) shown in the figure below. This is where the staggered grid becomes very useful. Notice how the discrete divergence of the fluid velocity is just computed by subtracting stored grid velocities, dividing by the grid cell width, and adding these values together for each dimension!</p>
          <p><img src="DiscreteDivergence.png" style="border-style: none;" class="center"></img></p>
          <p>Since the incompressibility constraint states that the divergence of the velocity field should be zero, we can substitute the pressure-based velocity update equations in the previous section into the next time step's velocity variables (the variables labeled with "next"):</p>
          <p><img src="PressureUpdateEqns1.png" style="border-style: none;" class="center"></img></p>
          <p><img src="PressureUpdateEqns2.png" style="border-style: none;" class="center"></img></p>
          <p><img src="PressureUpdateEqns3.png" style="border-style: none;" class="center"></img></p>
          <p>This derivation is explained in <a target="_blank" href="https://www.cs.ubc.ca/~rbridson/fluidsimulation/fluids_notes.pdf">Bridson and M&uuml;ller-Fischer's course notes</a> in Section 4.3. The observation that the last term above contains a discretization of the Laplacian of pressure is justified following the standard seven-point stencil central difference approximation of the Laplacian as a derivative of derivatives. The central differencing scheme for second derivatives is described for one and two dimensions in <a target="_blank" href="https://cal.cs.umbc.edu/Courses/PhysicsBasedAnimation/PhysicsBasedAnimationCourseNotes2019.pdf">Bargteil and Shinar's course notes on pages 31-32</a>. Here is how we can derive the seven-point stencil-based central difference approximation of the Laplacian of our fluid's pressure:</p>
          <p><img src="Laplacian7PointStencil.png" style="border-style: none;" class="center"></img></p>
          <p>Let's move velocity terms to one side of the pressure-based zero-divergence equation we derived above. That leaves us with:</p>
          <p><img src="PressureUpdateEqns4.png" style="border-style: none;" class="center"></img></p>
          <p>We can divide through by &Delta;<i>t</i>/(<i>&rho;</i>(&Delta;<i>x</i>)<sup>2</sup>) and distribute the negative sign through the pressure terms to get:</p>
          <p><img src="PressureUpdateEqns5.png" style="border-style: none;" class="center"></img></p>
          <p>Since this equation applies to all cells (<i>i</i>, <i>j</i>, <i>k</i>) labeled as fluid, this actually is a whole system of linear equations with all the pressure values being the unknown values stacked into a single vector, <b>p</b>, and all other values being known. The scaled divergences on the right-hand side can be stacked into a single vector, <b>d</b>:</p>
          <p><img src="PressureUpdateEqns6.png" style="border-style: none;" class="center"></img></p>
          <p>We can write this as a linear equation <i>A</i><b>p</b> = <b>d</b>, where <i>A</i> is a matrix containing six -1s and one 6 in each row corresponding to a fluid grid cell. This is a large, <i>sparse</i> matrix since other than those -1s and 6s in each row corresponding to a fluid cell, the entire matrix is full of zeros.</p>
          <p>As described in <a target="_blank" href="https://www.cs.ubc.ca/~rbridson/fluidsimulation/fluids_notes.pdf">Bridson and M&uuml;ller-Fischer's course notes</a>, in case of an empty neighboring cell, we simply set that neighbor's entry in matrix <i>A</i> to zero instead of -1. In case of neighboring cells being solid, we reduce the 6 by however many solid neighboring cells are present. So, in general, the "6" is actually just the number of non-solid grid cell neighbors of cell (<i>i</i>, <i>j</i>, <i>k</i>).</p>
          <h2 id="Conjugate_Gradient_Algorithm">Conjugate Gradient Algorithm</h2>
          <p>Our goal is to solve the equation above, <i>A</i><b>p</b> = <b>d</b>, for <b>p</b>. We already know <b>d</b>: those are just the scaled negated divergences from the current (old) time. The matrix <i>A</i> is also known, big, and sparse. Wouldn't it be nice if we could just invert <i>A</i> and get <b>p</b> = <i>A</i><sup>-1</sup><b>d</b> in one step, and be done? Unfortunately, <i>A</i> is not always invertible, and being large and sparse, storing the matrix and directly inverting it requires storing a lot of unnecessary information. Fortunately, <i>A</i> is also <a target="_blank" href="https://en.wikipedia.org/wiki/Definite_matrix">symmetric and positive-semi-definite</a>, so there's another easy-to-implement algorithm we can use to solve this problem: the <i>Conjugate Gradient Algorithm</i>, without even requiring us to store the actual <i>A</i> matrix anywhere in computer memory during our program's execution!</p>
          <p>This <a target="_blank" href="https://www.cs.cmu.edu/~quake-papers/painless-conjugate-gradient.pdf">very approachable, yet detailed introduction to the Conjugate Gradient Algorithm</a> by Dr. Jonathan Shewchuk lists the steps of the algorithm on page 32, while the rest of the document explains the algorithm, variations on it, its derivation, and its properties. Here we will describe and illustrate a summary of what is described in Dr. Shewchuk's document. Page 34 of <a target="_blank" href="https://www.cs.ubc.ca/~rbridson/fluidsimulation/fluids_notes.pdf">Bridson and M&uuml;ller-Fischer's course notes</a> also lists a similar algorithm called the Preconditioned Conjugate Gradient Algorithm, which is <i>not</i> what we're using in this tutorial (we're just doing the regular, vanilla Conjugate Gradient Algorithm), but shows the criteria for when to stop the algorithm from repeating iterations of its calculations.</p>
          <p>The Conjugate Gradient Algorithm takes advantage of the fact that you can write a function called a <i>quadratic form</i> using <i>A</i>, <b>p</b>, and <b>d</b>, whose graph is a giant bowl if <i>A</i> is positive-definite, where <i>c</i> is some real number:</p>
          <p><img src="CG_01_QuadFormBowl.png" style="border-style: none;" class="center"></img></p>
          <p>(If <i>A</i> is positive semi-definite, we can still use the same algorithm.) The idea is to pick some initial guess at a solution, <b>p</b><sub>0</sub>:</p>
          <p><img src="CG_02_InitialGuess.png" style="border-style: none;" class="center"></img></p>
          <p>As Bridson and M&uuml;ller-Fischer describe, we can just start with a guess of all zeros, <b>p</b><sub>0</sub> = <b>0</b> since, for example, some more "intelligent" approach like using a previous time steps' pressures may not work since some grid cells may have switched to or from even being fluid. Then, figure out how far you are from the bottom of the bowl. Well, we don't know what <b>p</b> vector will actually get us to the bottom of the bowl, but we do know that whatever that correct <b>p</b> is, left-multiplying it by <i>A</i> gives us <b>d</b> since that was the equation we started with: <i>A</i><b>p</b> = <b>d</b>! So, how far we are from the correct solution to <i>A</i><b>p</b> = <b>d</b> can be measured using the <i>residual</i> vector, <b>r</b><sub>0</sub> = <b>d</b> - <i>A</i><b>p</b><sub>0</sub>, based on our initial guess, <b>p</b><sub>0</sub>:</p>
          <p><img src="CG_03_InitialResidual.png" style="border-style: none;" class="center"></img></p>
          <p>Well, now that we know how far we are from the correct solution, let's figure out how to get closer to the solution! We're going to take a step toward that solution. But how big a step, and in what direction? It turns out, the step direction, <b>d</b><sub>0</sub>, can just be the residual, <b>r</b><sub>0</sub>, which takes us in a direction closing the gap between our current guess, <b>p</b><sub>0</sub>, and the final solution, <b>p</b>. The step size is calculated in terms of the matrix, residual, and step direction as <i>&alpha;</i><sub>0</sub> = <b>r</b><sub>0</sub> &middot; <b>r</b><sub>0</sub> / (<b>d</b><sub>0</sub> &middot; <i>A</i><b>d</b><sub>0</sub>). That takes us to a new guess at the solution, <b>p</b><sub>1</sub> = <b>p</b><sub>0</sub> + <i>&alpha;</i><sub>0</sub><b>d</b><sub>0</sub>:</p>
          <p><img src="CG_04_FirstStep.png" style="border-style: none;" class="center"></img></p>
          <p>The new residual, or how "off" we are from the solution's scaled, flipped divergence values, is updated to <b>r</b><sub>1</sub> = <b>r</b><sub>0</sub> - <i>&alpha;</i><sub>0</sub><i>A</i><b>d</b><sub>0</sub>:</p>
          <p><img src="CG_05_2ndResidual.png" style="border-style: none;" class="center"></img></p>
          <p>We then compute how small our new residual's magnitude is relative to the previous residual, <i>&beta;</i><sub>1</sub> = (<b>r</b><sub>1</sub> &middot; <b>r</b><sub>1</sub>) / (<b>r</b><sub>0</sub> &middot; <b>r</b><sub>0</sub>). From this, we determine the next direction in which to step: <b>d</b><sub>1</sub> = <b>r</b><sub>1</sub> + <i>&beta;</i><sub>1</sub><b>d</b><sub>0</sub>:</p>
          <p><img src="CG_06_2ndDirection.png" style="border-style: none;" class="center"></img></p>
          <p>This process repeats with computing the next step size, <i>&alpha;</i><sub>1</sub>, the new solution guess, <b>p</b><sub>2</sub>, etc.</p>
          <p>But when does this process end? How many steps should we end up taking? Well, as Bridson and M&uuml;ller-Fischer describe, we can arbitrarily stop when we either get close enough to the solution (we'll say if the sum of squared scaled, flipped divergences of our current solution guess is no more than 10<sup>-6</sup> times the sum of squared <i>original</i> scaled, flipped divergences) to declare that we're done, or when we're taken a certain number of steps toward the solution (we'll say a thousand), we're done. This entire process of taking up to a thousand steps to end within one time step of our simulation, so we don't want it taking forever!</p>
          <p>Thus, we end up with the algorithm described in Shewchuk's document, which is also how the algorithm is implemented in Bargteil and Shinar's code (note all equals signs are assignment statements, not statements of truth!):
          <ul>
            <li>Start with <b>p</b> = <b>0</b>.
            <li>Start with <b>r</b> = <b>d</b>, i.e., the starting residual should equal the starting step direction.</li>
            <li>Compute the squared magnitude of the residual: <i>&sigma;</i> = <b>r</b> &middot; <b>r</b>.</li>
            <li>Set the threshold for how close we want to get to the ideal solution, <i>tolerance</i> = 10<sup>-6</sup> &middot; <i>&sigma;</i>.</li>
            <li>Repeat until 1000 steps are taken or <i>&sigma;</i> &leq; <i>tolerance</i>:
              <ul>
                <li>Set the matrix-mapped step direction to be <b>q</b> = <i>A</i><b>d</b>.</li>
                <li>Set the step size, <i>&alpha;</i> = <i>&sigma;</i> / <b>d</b> &middot; <b>q</b>.</li>
                <li>Move to the new solution guess, <b>p</b> += <i>&alpha;</i><b>d</b>.</li>
                <li>Compute the new residual, <b>r</b> -= <i>&alpha;</i><b>q</b>.</li>
                <li>Save a copy of the old residual's magnitude, <i>&sigma;</i><sub>old</sub> = <i>&sigma;</i>.</li>
                <li>Compute the squared magnitude of the new residual, <i>&sigma;</i> = <b>r</b> &middot; <b>r</b>.</li>
                <li>Compute how small the new residual is relative to the old one, <i>&beta;</i> = <i>&sigma;</i> / <i>&sigma;</i><sub>old</sub>.</li>
                <li>Set the new step direction based on the old step direction: <b>d</b> = <b>r</b> + <i>&beta;</i><b>d</b>.</li>
              </ul>
            </li>
          </ul>
          </p>
          <h2 id="Implementing_Pressure_Projection">Implementing Pressure Projection</h2>
          <p>Now we have all the steps in place for handling the pressure gradient term of the Euler momentum equation: compute the scaled, flipped divergences of our fluid's grid velocities, use the Conjugate Gradient Algorithm to compute pressure values that minimize the divergence of an updated grid velocities, and then subtract the resulting pressure gradient (for all non-SOLID grid cells) to obtain the new grid velocities.</p>
          <p>Before we apply the Conjugate Gradient Algorithm though, we need a way to compute the effect of multiplying pressures by the matrix <i>A</i> without actually storing that matrix: it's sparse and huge, so we can compute it more efficiently if we just compute and store information on neighbors of fluid grid cells so we know what numbers to use for each row of the matrix.</p>
          <p>Exactly what do we need to know about grid cells' neighbors? First, since we're only interested in fluid grid cells, we can skip all the cells on the outer boundary of our grid on all sides, since those are all cells marked as SOLID. So, we can restrict ourselves to the grid cells with indices (<i>i</i>, <i>j</i>, <i>k</i>) where 1 &leq; <i>i</i> &leq; <i>n<sub>x</sub></i> - 1, 1 &leq; <i>j</i> &leq; <i>n<sub>y</sub></i> - 1, and 1 &leq; <i>k</i> &leq; <i>n<sub>z</sub></i> - 1. We can also skip any grid cell that is not labeled as FLUID. For each remaining cell, look at its six neighbors above, below, left, right, behind, and in front of the cell. First, count how many of those six neighbors are either marked as FLUID or EMPTY themselves. Second, we want to remember which of these six neighbors is actually FLUID, and not EMPTY. Why do we need this information? Because we will use it to "multiply a vector by the matrix <i>A</i>" without actually storing <i>A</i> itself or doing any actual matrix multiplication: for each cell (<i>i</i>, <i>j</i>, <i>k</i>), if the cell has no fluid or empty neighbors, we'll skip it entirely; otherwise, we'll multiply the (not-stored-anywhere) matrix <i>A</i> times a vector <b>d</b> by first multiplying by the entry for cell (<i>i</i>, <i>j</i>, <i>k</i>) in the vector <b>d</b> by the number of the cell's non-SOLID neighbors (this corresponds to the number 6 we showed in the <i>A</i> matrix example earlier for any cell that has all 6 neighbor cells being non-SOLID) and then subtracting the entry for each FLUID neighbor cell in the vector <b>d</b> (this corresponds to each -1 entry in a row of the matrix <i>A</i>).</p>
          <p>Okay, but how shall we store all this data? Keeping count of the neighbors of each cell as well as keeping track of up to 6 neighbors of each cell in the entire grid seems like a lot of data to store! Well, we can use bit manipulation to minimize storage. Since we can have up to six non-SOLID neighbors of any given grid cell, well, the number 6 is 110 in binary, so we need three bits to store the number of non-SOLID neighbors of a grid cell. Then, for each of those six neighbors, we want to store a single bit that is 1 if that neighbor cell is FLUID, and 0 otherwise. So that's one bit for each of the six neighbors, so six more bits we need to store. So, we need to store a total of three bits for the number of non-SOLID neighbors of a cell and six bits for the number of FLUID neighbors, so that's 3 + 6 = 9 bits total that we need to store. Now, we could store all of this information for all grid cells in our entire grid by creating a 3D array of a 9-bit <code>std::bitset</code> object, but to keep things simple and avoid possible overhead from using another data structure just for this, let's just store this as a 3D array of integers that can store at least 9 bits. There is no built-in 9-bit integer data type in C++, so we use the smallest built-in integer type that contains 9 bits, which is the 16-bit unsigned integer type, <code>uint16_t</code>:</p>
          <p><img src="NeighborsBits1.png" style="border-style: none;" class="center"></img></p>
          <p>Here is a diagram of where those neighbor cells are relative to the cell (<i>i</i>, <i>j</i>, <i>k</i>), which is the unlabeled cell in the middle:</p>
          <p><img src="NeighborsBits2.png" style="border-style: none;" class="center"></img></p>
          <p>As an example, if the fluid cell at index (3, 5, 2) has six fluid cell neighbors, the entry in this 3D array <code>neighbors</code> at index (3, 5, 2) will look like this:</p>
          <p><img src="NeighborsBits3.png" style="border-style: none;" class="center"></img></p>
          <p>On the other hand, if the fluid cell at index (5, 0, 18) has three fluid neighbors on its right, above it, and to its left, two empty neighbors below it and in front of it, and a solid neighbor behind it, the entry in this 3D array <code>neighbors</code> at index (5, 0, 18) will look like this:</p>
          <p><img src="NeighborsBits4.png" style="border-style: none;" class="center"></img></p>
          <p>And that's it! So, just storing and updating these 9 bits of information for each grid cell in each time step allows us to multiply the giant, sparse matrix <i>A</i> by any vector without ever storing the array anywhere or doing any fancy matrix multiplications! We just iterate through all the grid cells, count neighbors, and multiply and subtract some stuff, and we're done!</p>
          <p>Here is our implementation of pressure projection! The entire implementation is in the <a target="_blank" href="https://github.com/unusualinsights/flip_pic_examples/tree/main/incremental5">incremental5</a> directory. We updated <a target="_blank" href="https://github.com/unusualinsights/flip_pic_examples/blob/main/incremental5/Array3D.h">Array3D.h</a> to include functions <code>SetEqualTo</code>, <code>PlusEquals</code>, <code>EqualsPlusTimes</code>, and <code>Dot</code> to allow doing arithmetic using whole 3D arrays. In the <code>StaggeredGrid</code> class, we added the <code>ProjectPressure</code> function that generates the <code>neighbors</code> array we described above based on the material type of each grid cell, applies the Conjugate Gradient Algorithm to compute pressure values that lead to a sufficiently divergence-free fluid velocity in the grid, and then updates the velocity based on the resulting pressure gradient, just as we described above. A separate class, <code>PressureSolver</code>, is introduced to implement the Conjugate Gradient Algorithm to solve for pressure. The logic behind the introduction of this class is that the main <code>StaggeredGrid</code> class will never need access to the objects used for the Conjugate Gradient Algorithm such as the residual vector (stored as a 3D array in the code since the "vector" would contain exactly one value per grid cell, and our per-grid-cell values in general are already stored using 3D arrays), so it makes sense to encapsulate those objects into the <code>PressureSolver</code> class, which is the only class that will ever access or modify those objects. Note we do <i>not</i> use return value optimization in the <code>PressureSolver</code> code even though we have functions whose sole job is to return a 3D array of values, since we will not be creating and destroying the 3D arrays that receive the 3D arrays that would be "created" and returned by those functions--they are relatively large objects so we choose to keep them in memory throughout the fluid simulation and simply update their values in each time step (e.g., the 3D arrays for residuals and pressures) rather than creating and destroying them on the stack repeatedly.</p>
          <p>To compile the code in the <code>incremental5</code> directory, <code>cd</code> to that directory in a terminal window and execute this command:</p>
          <div class="outer">
            <div class="inner">
              <pre>g++ jsoncpp.cpp Particle.cpp PressureSolver.cpp SimulationParameters.cpp StaggeredGrid.cpp StaggeredGridTest.cpp -I/usr/include/eigen3/</pre>
            </div>
          </div>
          <p>Run the <code>StaggeredGridTest.cpp</code> code with the same command as earlier:</p>
          <div class="outer">
            <div class="inner">
              <pre>./a.out inputs/fluid.json</pre>
            </div>
          </div>
          <p>Then clean up as usual:</p>
          <div class="outer">
            <div class="inner">
              <pre>rm a.out</pre>
            </div>
          </div>
          <h1 id="Mapping_from_Grid_to_Particles">Mapping from the Grid to the Particles</h1>
          <p></p>
          <h1 id="Visualizing_Fluid_Animation">Visualizing the Fluid Animation</h1>
          <p>COMING SOON</p>
          <h1 id="The_End_Result">The End Result</h1>
          <p><img src="BasicFluidAnimation.gif" class="centeropengl"></img></p>
      <p style="font-size: 10px;">Video made using the FLIP solver and visualizer in the <a target="_blank" href="https://cal.cs.umbc.edu/Courses/PhysicsBasedAnimation/">SIGGRAPH physics-based animation course</a> on which this tutorial is based.</p>
    </div>
  </body>
</html>
