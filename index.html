<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" type="text/css" href="physsim.css">
    <title>Fluid Simulation</title>
  </head>
  <body>
    <div class="sidenav">
      <a href="#home">Top</a><br>
      <a href="#Background">Background</a><br>
      <a href="#What_to_Install">What to Install</a><br>
      <a href="#Viewing_Geometry_Using_OpenGL">Viewing Geometry Using OpenGL</a><br>
      <ul>
        <li><a href="#Hello_Sphere">Hello, Sphere!</a></li>
        <li><a href="#Hello_Shaded_Sphere">Hello, Shaded Sphere!</a></li>
        <li><a href="#Positioning_the_Sphere">Positioning the Sphere</a></li>
        <li><a href="#How_OpenGL_Maps_from_3D_to_2D">How OpenGL Maps from 3D to 2D</a></li>
      </ul>
      <a href="#A_Massless_Sizeless_Particle">A Massless, Sizeless Particle</a><br>
      <ul>
        <li><a href="#Mathematical_Model_of_a_Massless_Sizeless_Particle">Mathematical Model of a Massless, Sizeless Particle</a></li>
        <li><a href="#Simulating_a_Massless_Sizeless_Particle">Simulating a Massless, Sizeless Particle</a></li>
        <li><a href="#Model_of_Massless_Sizeless_Particle_In_Velocity_Field">Mathematical Model of a Massless, Sizeless Particle in a Velocity Field</a></li>
        <li><a href="#Simulating_Massless_Sizeless_Particle_in_Velocity_Field">Simulating a Massless, Sizeless Particle in a Velocity Field</a></li>
      </ul>
      <a href="#A_Particle_with_Mass">A Particle with Mass</a><br>
      <ul>
        <li><a href="#Mathematical_Model_of_Particle_with_Mass">Mathematical Model of a Particle with Mass</a></li>
        <li><a href="#Simulating_Particle_with_Mass">Simulating a Particle with Mass</a></li>
        <li><a href="#Mathematical_Model_of_Particles_with_Mass_Size_and_Multiple_Forces">Mathematical Model of Particles with Mass, Size, and Multiple Forces</a></li>
        <li><a href="#Simulating_Colliding_Particles_with_Mass_and_Size">Simulating Colliding Particles with Mass and Size</a></li>
      </ul>
      <br>
      <br>
      <br>
      <br>
      <br>
    </div>
    <div class="thetext">
      <h1 id="home">Physics-Based Simulation &amp; Animation of Fluids</h1>
      <p>Do you ever wonder how special effects using fluids like water are animated for movies? In this tutorial, we'll show you how to simulate fluids using the popular Fluid-Implicit-Particle / Particle-in-Cell (FLIP/PIC) method.</p>
      <h1 id="Background">Background</h1>
      <p>This tutorial is designed assuming a year or two of experience in or exposure to:
      <ul>
        <li>Computer programming in C++</li>
        <li>Using a command-line terminal on a computer running Linux, e.g., the Ubuntu operating system</li>
        <li>Newtonian mechanics, e.g., <i>F</i> = <i>ma</i>, momentum, position, velocity, acceleration</li>
        <li>Calculus: differential, integral, and vector calculus</li>
      </ul></p>
      <p>Some exposure to computer graphics helps but is certainly not required. If you're a second- or third-year computer science college student, you have more than enough background! If you haven't gone to college, haven't studied computer science, don't remember much math or physics, or this list just feels overwhelming in general, that's okay! Feel free to follow along and look up and/or skip lots of things! You don't have to understand everything, by any means, to gain something from this tutorial. Other than access to a computer (yes, this can be a challenge) and at least an occasional Internet connection, everything else this tutorial is freely available!</p>
      <h1 id="What_to_Install">What to Install</h1>
      <p>This tutorial will use the C++ programming language. We will use the Open Graphics Library (OpenGL) and the associated OpenGL Utility Toolkit (GLUT) to display graphics on the computer screen. This is freely available software widely used for displaying graphics on computer screens.</p>
      <p>From this point onward, I'll assume you're using a computer running Ubuntu 16.04 or 18.04. I'll also assume your computer account has permission to install new software on that computer, or if not, that someone else can do it for you. If you're running another operating system, such as Windows or macOS, you should be able to follow along but with some small changes to commands and the code.</p>
      <p>Open a Terminal (CTRL+ALT+T on Ubuntu). Type this command and press Enter:</p>
      <div class="outer">
        <div class="inner">
          <pre>g++ --version</pre>
        </div>
      </div>
      <p>You should see some text showing the version of <code>g++</code>, the program we'll use to compile our code, that is installed on your computer. If not, look up how to install it. For our purposes, which version of the compiler you install should matter much.</p>
      <p>Next, in a Terminal (the same one as before is fine!), type this command and then press Enter to run it:</p>
      <div class="outer">
        <div class="inner">
          <pre>sudo apt install freeglut3-dev</pre>
        </div>
      </div>
      <p>If you're asked to, enter your password and press Enter. Once the computer finishes installing OpenGL and GLUT, figure out <i>where</i> it was installed. I found this out by typing something like <code>ls /usr/lib/x86_64-linux-gnu/libgl*</code> and pressing the [TAB] key twice, causing the Terminal to list a whole bunch of files with names starting with <code>libgl</code>something including <code>libglut.</code>something. So, my OpenGL and GLUT libraries were installed in <code>/usr/lib/x86_64-linux-gnu/</code>. Feel free to search online for how to find where OpenGL and GLUT were installed on your computer if you're not sure.</p>
      <p>This is not required but I highly recommend installing <code>clang-format</code>, a program used by many software developers in industry to format their code in a consistent style. We'll use this program to format our code in Google's style. To install it, run this command in a Terminal and press Enter:</p>
      <div class="outer">
        <div class="inner">
          <pre>sudo apt install clang-format-10</pre>
        </div>
      </div>
      <p>It's okay to use another version of this program; I just happen to be using version 10 at the moment.</p>
      <p>Now, create a directory (folder) somewhere on your computer where you want to store all the code you write as part of this tutorial. You can and will make multiple subdirectories in there as the tutorial proceeds, but it's good to have one parent directory that holds everything. <code>cd</code> to that parent directory in a Terminal window. Then type this command and press Enter:</p>
      <div class="outer">
        <div class="inner">
          <pre>clang-format-10 -style=Google -dump-config &gt; .clang-format</pre>
        </div>
      </div>
      <p>This creates a "hidden" file (meaning you can see it by running the <code>ls -a</code> command, but not the plain <code>ls</code> command) in this directory that contains your default settings consistent with the Google style for the <code>clang-format</code> program. Here is my <a href="https://github.com/unusualinsights/phys_sim_examples/blob/main/.clang-format">.clang-format file</a>. If for some reason you want to keep your code in multiple disparate places on your computer, you can just re-run this command in each of those directories.</p>
      <h1 id="Viewing_Geometry_Using_OpenGL">Viewing Geometry Using OpenGL</h1>
      <p>OpenGL is a general framework that allows us to do graphics programming. To use it to display geometry effectively, we need to set up some initial working code and understand a bit about how OpenGL code manages what we see on the screen.</p>
      <h2 id="Hello_Sphere">Hello, Sphere!</h2>
      <p>Our first program will be a single file containing code in the C++ programming language. When we run this program, if everything is working, a window will pop up on the computer screen displaying a single, red, boring sphere. It's so boring, in fact, that it won't even look three-dimensional: it'll just look like a filled-in red circle.</p>
      <p>Make a directory called <code>basic</code> inside the directory that'll house all your code for this tutorial. Okay, you can put this directory anywhere, but this will just make it less work for you to run <code>clang-format</code> on your code and keep it organized the same way as this tutorial's code. In that directory, create a file called <code>HelloSphere.cpp</code>. You can copy the code from my <a href="https://github.com/unusualinsights/phys_sim_examples/blob/main/basic/HelloSphere.cpp">HelloSphere.cpp</a> file and save it. Or you can just download the file by clicking on this link and then clicking the "Raw" button on that page. I put a lot of comments in the file explaining what the code does. If you want to learn more details about how OpenGL and GLUT work, you can find plenty of documentation via online search.</p>
      <p>In a Terminal, <code>cd</code> to the directory containing this <code>HelloSphere.cpp</code> file. Then run this command:</p>
      <div class="outer">
        <div class="inner">
          <pre>clang-format-10 -style=file -i HelloSphere.cpp</pre>
        </div>
      </div>
      <p>Congratulations! Your C++ code is now formatted according to Google's standards! Well, at least it's formatted to the standards a computer can follow automatically. Now, let's compile your code with this command:</p>
      <div class="outer">
        <div class="inner">
          <pre>g++ HelloSphere.cpp -o HelloSphere -L/usr/lib/x86_64-linux-gnu/ -lGL -lglut -lGLU</pre>
        </div>
      </div>
      <p>If it compiled with no errors or warnings, let's run the program! Run it with this command:</p>
      <div class="outer">
        <div class="inner">
          <pre>./HelloSphere</pre>
        </div>
      </div>
      <p>You should see a window pop up on your screen that looks something like this:</p>
      <p><img src="HelloSphere.png" class="centeropengl"></img></p>
      <p>You can close the window to stop the program.</p>
      <p>Here are a couple sources that I think illustrate nicely how to create simple OpenGL programs from scratch:</p>
      <ul>
        <li><a href="https://stackoverflow.com/questions/23092055/how-to-display-a-sphere-correctly-in-opengl">StackOverflow example on displaying a sphere in OpenGL</a></li>
        <li><a href="https://ogldev.org/www/tutorial01/tutorial01.html">First tutorial from the OpenGL Step by Step series</a></li>
      </ul>
      <p>It's exciting to get our first program working. But the geometry I claimed was 3D just looks like a boring red disc (filled-in circle). How can we make it <i>look</i> 3D?</p>
      <h2 id="Hello_Shaded_Sphere">Hello, Shaded Sphere!</h2>
      <p>The 3D nature of shapes becomes more apparent when we add shading to our scene. In OpenGL, this is done by modeling the effects of light on the color of each vertex of any shape, assuming some material properties of the shape. By turning on a light, we can make our sphere "look" three-dimensional. In the same directory as the previous program (just for convenience, e.g., access to the same <code>.clang-format</code> file), create a new file called <code>HelloSphereShaded.cpp</code>. Here is my version, which you can copy or download: <a href="https://github.com/unusualinsights/phys_sim_examples/blob/main/basic/HelloSphereShaded.cpp">HelloSphereShaded.cpp</a>.</p>
      <p>Compile the program:</p>
      <div class="outer">
        <div class="inner">
          <pre>g++ HelloSphereShaded.cpp -o HelloSphereShaded -L/usr/lib/x86_64-linux-gnu/ -lGL -lglut -lGLU</pre>
        </div>
      </div>
      <p>Run it:</p>
      <div class="outer">
        <div class="inner">
          <pre>./HelloSphereShaded</pre>
        </div>
      </div>
      <p>View the result:</p>
      <p><img src="HelloSphereShaded.png" class="centeropengl"></img></p>
      <p>And there you have it! Now there's some shading, revealing the 3D shape of our sphere!</p>
      <p>To clarify exactly how the 3D coordinates of our shapes map to the 2D locations of shapes we see on the computer screen, let's do some experiments.</p>
      <h2 id="Positioning_the_Sphere">Positioning the Sphere</h2>
      <p>Make a new program called <code>PositionSphere.cpp</code> in the same directory (for convenience, you could put it in another directory if you really want). Here's my code: <a href="https://github.com/unusualinsights/phys_sim_examples/blob/main/basic/PositionSphere.cpp">PositionSphere.cpp</a>.</p>
      <p>Compile this program:</p>
      <div class="outer">
        <div class="inner">
          <pre>g++ PositionSphere.cpp -o PositionSphere -L/usr/lib/x86_64-linux-gnu/ -lGL -lglut -lGLU</pre>
        </div>
      </div>
      <p>Run it:</p>
      <div class="outer">
        <div class="inner">
          <pre>./PositionSphere</pre>
        </div>
      </div>
      <p>The window that pops up should look exactly the same as before! Now let's change the call to <code>putSphereCenteredAt</code> to <code>putSphereCenteredAt(1.0, 0.0, 0.0);</code> and then compile and run the program using the same commands as before. Here's the result:</p>
      <p><img src="PositionSphereX1.png" class="centeropengl"></img></p>
      <p>Hmm. It looks like the sphere is halfway out of our viewing window! Let's push the boundaries a bit further by changing that function call to <code>putSphereCenteredAt(1.2, 0.0, 0.0);</code>, compiling, and running again. Here's the result:</p>
      <p><img src="PositionSphereX1_2.png" class="centeropengl"></img></p>
      <p>The sphere is almost gone--just a little sliver left! Now, you might notice from the code above that the radius of this sphere is 0.25. We have just moved the sphere to the right by 1.2. <i>If</i> the viewing window is showing us <i>x</i>-coordinate values ranging up to <i>x</i> = 1, and <i>if</i> the positive <i>x</i>-axis direction points to the right of our window, then we would expect the sphere to disappear completely when we shift it to the right (positive <i>x</i> direction) by 1.25 or more. Let's try <code>putSphereCenteredAt(1.245, 0.0, 0.0);</code>:</p>
      <p><img src="PositionSphereX1_245.png" class="centeropengl"></img></p>
      <p>Sure enough, we only see a tiny sliver of the sphere remaining in our viewing window! If you're having trouble seeing it, it's just a few red pixels on the right middle end of the image above. Finally, let's try <code>putSphereCenteredAt(1.25, 0.0, 0.0);</code>. Sure enough, the resulting image, which I won't bother to show you here due to its extremely boring pitch black appearance, displays absolutely no part of the sphere. So, it seems like a reasonable guess, that perhaps our viewing window extends up to <i>x</i> = 1 on the right side.</p>
      <p>Similar experiments will reveal that the left end of our viewing window extends to <i>x</i> = -1, the top end goes to <i>y</i> = 1, and the bottom goes to <i>y</i> = -1. To verify this yourself, try putting 1.245 or -1.245 into the <i>x</i> or <i>y</i> coordinates of the <code>putSphereCenteredAt</code> function call one at a time and observe where the little sliver of the sphere appears.</p>
      <p>The <i>z</i>-coordinate is a bit odd in comparison. Let's try the same experiment, first with <code>putSphereCenteredAt(0.0, 0.0, 0.75);</code>:</p>
      <p><img src="PositionSphereZ0_75.png" class="centeropengl"></img></p>
      <p>If you compare this image to the original one from the first time we ran this program with no translation, or equivalently, the picture we got when we ran <code>HelloSphereShaded.cpp</code>, you may notice that the spheres look exactly the same size; the only difference between them seems to be the lighting and shading. This may seem a bit strange since the <i>z</i>-axis is presumably oriented somehow toward/away from us, i.e., perpendicular to the computer screen (since the <i>x</i>- and <i>y</i>-axes are both parallel to the computer screen), yet, unlike real life, bringing the sphere closer to us doesn't seem to be changing its size!</p>
      <p>Let's continue experimenting. Let's now move the sphere to <code>putSphereCenteredAt(0.0, 0.0, 1.0);</code>. If you run this, you'll notice a totally blank, black window again! What happened to the sphere? Why did it disappear? If <i>z</i> is clamped to [-1, 1] like <i>x</i> and <i>y</i> are, should we still see half of the sphere in our viewing window when we move it to be centered at <i>z</i> = 1?</p>
      <p>Let's make one other change to the code, temporarily. Let's comment out these two lines in the <code>drawBackground()</code> function:</p>
      <div class="outer">
        <div class="inner">
          <pre>  // glEnable(GL_CULL_FACE);
  // glCullFace(GL_BACK);</pre>
        </div>
      </div>
      <p>Then, try running the program:</p>
      <p><img src="PositionSphereZ1_0NoCull.png" class="centeropengl"></img></p>
      <p>Now, we seem to see the sphere again--the lighting looks different than what we just saw earlier. Let's not analyze the lighting too much and let's keep moving the sphere further along the <i>z</i>-axis. Let's move it now to <code>putSphereCenteredAt(0.0, 0.0, 1.24);</code>:</p>
      <p><img src="PositionSphereZ1_24NoCull.png" class="centeropengl"></img></p>
      <p>Hmm. Looks like the sphere is starting to disappear! Let's try <code>putSphereCenteredAt(0.0, 0.0, 1.2499);</code>:</p>
      <p><img src="PositionSphereZ1_2499NoCull.png" class="centeropengl"></img></p>
      <p>Just a tiny dot of the sphere left in our viewing window! Change the <i>z</i>-coordinate to 1.25 to verify that the sphere does indeed completely disappear from the viewing window at that location. This suggests pretty strongly that the <i>z</i>-coordinate does indeed extend up to <i>z</i> = 1 on the positive side of the <i>z</i>-axis (since the sphere has radius 0.25, so if it's centered at <i>z</i> = 1.25, the points on its surface will have <i>z</i> values that go as low as 1.25 - 0.25 = 1, which we can't see, and if it's centered at <i>z</i> = 1.2499, its points will go as low as <i>z</i> = 1.2499 - 0.25 = 0.9999, of which we do see a tiny bit). But is the positive <i>z</i> direction pointing toward us, or away from us?</p>
      <p>If you do the exact same experiments but with negative <i>z</i> values (and now you can uncomment those lines of code that mentioned something about culling), you'll notice the exact same pattern. When the sphere is centered at (0.0, 0.0, -1.0), it appears to have exactly the same size as it did at <i>z</i> = 0.75 and at <i>z</i> = 0, but with just a bit of a change in its lighting and shading:</p>
      <p><img src="PositionSphereZ_1_0.png" class="centeropengl"></img></p>
      <p>If you continue the experiment to move the sphere's center to (0.0, 0.0, -1.2499), you'll notice an identical image to when we put the sphere center at (0.0, 0.0, 1.2499), i.e., just a tiny dot in the middle of the screen is visible, and if you move the sphere center to (0.0, 0.0, -1.25), you'll see a totally blank black screen like you did when you moved the sphere center to (0.0, 0.0, 1.25). So, it appears that the negative <i>z</i>-coordinate also extends up to <i>z</i> = -1.</p>
      <h2 id="How_OpenGL_Maps_from_3D_to_2D">How OpenGL Maps from 3D to 2D</h2>
      <p>It still seems bizarre that with all this experimenting, we can't tell whether <i>z</i> increases toward us, or decreases toward us! But at least we did discover that we seem to be able to view any points that are within (-1, 1)<sup>3</sup> &sub; <b>R</b><sup>3</sup>, i.e., a box where -1 &lt; <i>x</i>, <i>y</i>, <i>z</i> &lt; 1. This is called OpenGL's default <b>viewing frustum</b>. We also figured out that <i>x</i> increases to the right and <i>y</i> increases upward. Based on this, it might be a reasonable guess that <i>z</i> by the right-hand rule increases toward us. But how can we know for sure?</p>
      <p>Instead of experimenting indefinitely, let's now get a more detailed understanding of exactly what OpenGL does to go from what appears to be 3D geometry, to a 2D image on our two-dimensional computer screen.</p>
      <p>The <code>glutSolidSphere</code> function always generates a set of triangles that approximate the surface of a sphere that is centered at (0, 0, 0). To "move" a sphere to be centered at a location other than (0, 0, 0), we must adjust the coordinates of the vertices of the triangles approximating the sphere to be located in appropriate places such that the resulting sphere would be centered at the desired location. To handle this shifting, or <b>translation</b>, of the coordinates, our code calls the <code>glTranslated</code> function. But notice some other code around that function call: there is some pushing and popping of a matrix, and something called <code>GL_MODELVIEW</code>. What is all that?</p>
      <p>OpenGL actually transforms the coordinates of any points it draws in the following way. Let (<i>x</i>, <i>y</i>, <i>z</i>) be an arbitrary point, e.g., a vertex on one of the triangles making up the sphere created by a call to <code>glutSolidSphere</code>. OpenGL represents each point in <b>homogenous coordinates</b>, so the point is represented with the coordinates <i>p</i> = (<i>x</i>, <i>y</i>, <i>z</i>, 1). These original coordinates for the point <i>p</i> are said to be in the <b>object coordinate system</b> or <b>local coordinate system</b>. The terms "local" and "object" here are referring to coordinate system whose origin is at the center of the sphere itself, regardless of where we're trying to center it. So, this is the coordinate system that is "local" to the "object," i.e., the sphere we want to draw. OpenGL represents this 4D point as a column vector (4x1 matrix) and then left-multiplies it by a 4x4 <b>model matrix</b>. The resulting 4x1 column vector represents the same point in the <b>world coordinate system</b> of OpenGL. This is the default, universal coordinate system OpenGL uses. All other coordinate systems are defined relative to this coordinate system. Note that this coordinate system isn't explicitly defined anywhere; a universal coordinate system just exists theoretically, and the only way for us to "see" it is to define at least one other coordinate system from which to view the universal/world coordinate system. Next, OpenGL left-multiplies that world-coordinate-system 4x1 column vector by a 4x4 <b>view matrix</b>. The resulting 4x1 column vector represents the point <i>p</i>'s coordinates in what we call the <b>view coordinate system</b>. Next, OpenGL left-multiplies this 4x1 vector by yet another 4x4 matrix called the <b>projection matrix</b>, yielding a 4x1 vector of coordinates for the point <i>p</i> in the <b>clip coordinate system</b>. At this point, OpenGL "clips" or removes all points that lie outside of the viewing frustum. In this case, we're using OpenGL's default viewing frustum where the <i>x</i>, <i>y</i>, and <i>z</i> coordinates must lie within (-1, 1). After clipping, OpenGL <i>normalizes</i> the coordinates of all remaining points so that <i>x</i>, <i>y</i>, and <i>z</i> lie within (-1, 1). By default, the clip coordinates are already in that range as we just said, but OpenGL does allow you to change the clip coordinates to be in a different range. But when OpenGL normalizes the clip coordinates into the <b>normalized device coordinate (NDC) system</b>, the coordinates must all lie within (-1, 1) regardless of what range the clip coordinates cover. Finally, the NDC coordinates are transformed so that -1 &lt; <i>x</i><sub>ndc</sub> &lt; 1 covers 0 &lt; <i>x</i><sub>window</sub> &lt; <i>w</i>, where <i>w</i> is the width of the viewing window specified in the code above, -1 &lt; <i>y</i><sub>ndc</sub> &lt; 1 covers 0 &lt; <i>y</i><sub>window</sub> &lt; <i>h</i>, where <i>h</i> is the height of the viewing window, and -1 &lt; <i>z</i><sub>ndc</sub> &lt; 1 covers 0 &lt; <i>z</i><sub>window</sub> &lt; 1. It is possible to change these ranges in OpenGL, but what we described here is the default behavior of OpenGL.</p>
      <p>Let's denote the model matrix by <i>M</i><sub>model</sub>, the view matrix by <i>M</i><sub>view</sub>, and the projection matrix by <i>M</i><sub>proj</sub>. Then the clip coordinates, <i>p</i><sub>clip</sub>, of the point <i>p</i> in object coordinates is <i>p</i><sub>clip</sub> = <i>M</i><sub>proj</sub> &middot; <i>M</i><sub>view</sub> &middot; <i>M</i><sub>model</sub> &middot; <i>p</i>. Let <i>w</i> = <i>h</i> = 500 pixels, as specified in our code above for the window size.</p>
      <p>In our <code>HelloShadedSphere.cpp</code> and original <code>PositionSphere.cpp</code> programs, when we left the sphere centered at the origin of the world coordinate system, our model matrix, <i>M</i><sub>model</sub>, was the 4x4 identity matrix. Later when we started translating the sphere away from being centered at the origin, that translation amount, (<i>t<sub>x</sub></i>, <i>t<sub>y</sub></i>, <i>t<sub>z</sub></i>) (e.g., once we did <i>t<sub>x</sub></i> = <i>t<sub>y</sub></i> = 0 and <i>t<sub>z</sub></i> = 1.2499), was included in the model matrix. That is:</p>
      <p><img src="ModelMatrix.png" class="center" style="width: 50%; border-style: none;"></img></p>
      <p>The view matrix is what represents the position and orientaton of the "camera" of OpenGL. By default, this is the identity matrix. This effectively makes us view all the objects in our OpenGL scene, by default, by having our camera eye located at (0, 0, +&infin;), while looking in the negative <i>z</i> direction. You'll see other sources saying the camera eye is effectively at the origin, (0, 0, 0), but the projection we describe below actually makes the concept of the eye being anywhere near the scene seem nonsensical. So, by default,</p>
      <p><img src="ViewMatrix.png" class="center" style="width: 50%; border-style: none;"></img>,</p>
      <p>but if you look at our code above, you'll notice that the model matrix and any view matrix are all combined into a single stack of matrices OpenGL calls the <code>GL_MODELVIEW</code> matrix mode. So, OpenGL actually combines, at any point in the code, model and view matrices into a single matrix that gets applied to all object-space vertex coordinates to obtain view coordinates. In our case,</p>
      <p><img src="ModelviewMatrix.png" class="center" style="width: 75%; border-style: none;"></img>.</p>
      <p>By default, in OpenGL, <i>M</i><sub>proj</sub> is the 4x4 identity matrix, which represents what is called an <b>orthographic projection</b>: it's like having a camera located infinitely far away from the origin, which lacks any notion of perspective; everything looks just as close to us as everything else since everything is, basically, infinitely far away from us. It's kind of like how we can't tell which stars in the sky are closer or farther away from us just by looking at them, even though we can judge how close a basketball might be to us if it's 1 meter vs. 10 meters away. With the default orthographic projection in OpenGL, it's like everything is a star that's infinitely far away. OpenGL applies the projection matrix typically on another matrix stack called <code>GL_PROJECTION</code>, which is not mentioned in our code since we just used the default projection matrix. If we wanted to change the camera's behavior, we could do so explicitly on the <code>GL_PROJECTION</code> matrix stack in our code. So:</p>
      <p><img src="OrthographicProjectionMatrix.png" class="center" style="width: 50%; border-style: none;"></img></p>
      <p>Combining all of this, we see that <i>p</i><sub>clip</sub> = <i>M</i><sub>proj</sub> &middot; <i>M</i><sub>view</sub> &middot; <i>M</i><sub>model</sub> &middot; <i>p</i> = (<i>x</i> + <i>t<sub>x</sub></i>, <i>y</i> + <i>t<sub>y</sub></i>, <i>z</i> + <i>t<sub>z</sub></i>), i.e., the result of the projection and modelview matrices, together, is just to translate all object-space coordinates of all points by (<i>t<sub>x</sub></i>, <i>t<sub>y</sub></i>, <i>t<sub>z</sub></i>). After applying all of these transformations, OpenGL will clip any points that are outside of the viewing frustum, like we saw earlier in all the examples where parts of the sphere were cut off from appearing in the viewing window.</p>
      <p>Since our clip coordinates are already normalized by default, <i>p</i><sub>clip</sub> also represents the normalized device coordinates (NDC) of all points: <i>p</i><sub>ndc</sub> = <i>p</i><sub>clip</sub>. Finally, the NDC coordinates are transformed to window coordinates by scaling and shifting the NDC values to get the <i>x</i>-coordinates to be within 0 to <i>w</i>, the <i>y</i>-coordinates to be within 0 to <i>h</i>, and the <i>z</i>-coordinates to be within 0 to 1. This is accomplished by setting <i>x</i><sub>window</sub> = (<i>w</i>/2)(<i>x</i><sub>ndc</sub> + 1) pixels, <i>y</i><sub>window</sub> = (<i>h</i>/2)(<i>y</i><sub>ndc</sub> + 1) pixels, and <i>z</i><sub>window</sub> = (1/2)(<i>z</i><sub>ndc</sub> + 1). You can verify that <i>x</i><sub>ndc</sub> = -1 gets mapped by this transformation to <i>x</i><sub>window</sub> = 0 and <i>x</i><sub>ndc</sub> = 1 gets mapped to <i>x</i><sub>window</sub> = <i>w</i> = 500, so this is how the 3D object coordinates end up getting mapped to 3D window coordinates.</p>
      <p>Finally, what we see on our 2D screen is the result of taking the 3D window coordinates and doing a depth test, as we asked OpenGL to do with in our code with the function call <code>glEnable(GL_DEPTH_TEST);</code>. So, this is how OpenGL makes sure whatever we see on our 2D screen is whatever is closest to us in the 3D scene we defined, much like a real-life camera's 2D image displays what the camera can see in a 3D real-world scene.</p>
      <p>All of these coordinate system shenanigans were to help us understand exactly what we see on the screen, and how what we see in pixels maps to the original 3D coordinates of the objects we constructed. This insight will come in handy as we start moving objects around on the screen during animations of physics-based simulations! Here is a diagram summarizing the overall default transformation from world coordinates to window coordinates in OpenGL:</p>
      <p><img src="WorldToWindow.png" class="center" style="width: 100%; border-style: none;"></img></p>
      <p>For more details and insights on how OpenGL handles coordinate transformations read these sources:
      <ul>
        <li><a href="https://www.khronos.org/opengl/wiki/Viewing_and_Transformations">Official OpenGL documentation on viewing and transformations</a></li>
        <li><a href="https://learnopengl.com/Getting-started/Coordinate-Systems">LearnOpenGL article on coordinate transformations</a></li>
        <li><a href="https://www.songho.ca/opengl/gl_transform.html">Detailed description and derivation of OpenGL transformations</a></li>
        <li><a href="https://stackoverflow.com/questions/37495019/opengl-how-to-make-projection-when-camera-is-within-viewing-frustum">Stack Overflow post and answer on orthographic projections</a></li>
        <li><a href="https://www.cs.uaf.edu/2007/spring/cs481/lecture/01_23_matrices.html">OpenGL matrix modes and order of projection and modelview matrix multiplications</a></li>
      </ul></p>
      <p>Now that we understand, in detail, how our 3D world scene maps to our 2D window, we can proceed to implementing animations of physics-based simulations using OpenGL. Note that with our current setup, the 2D location of the center of a sphere in the window on our computer screen accurately shows the location of the sphere's center in the <i>xy</i>-plane in the world coordinate system, since the orthographic projection does not distort this 2D location in any way.</p>
      <h1 id="A_Massless_Sizeless_Particle">A Massless, Sizeless Particle</h1>
      <p>We'll go through a few steps to describe each physics-based simulation in each tutorial:
      <ol>
        <li>Describe a mathematical model of the physical system we want to simulate.</li>
        <li>Design and implement that mathematical model in a computer program.</li>
        <li>Run the program and view the results.</li>
      </ol></p>
      <h2 id="Mathematical_Model_of_a_Massless_Sizeless_Particle">Mathematical Model of a Massless, Sizeless Particle</h2>
      <p>Like Dr. Adam Bargteil and Dr. Tamar Shinar's <a href="https://cal.cs.umbc.edu/Courses/PhysicsBasedAnimation/">course on physics-based animation</a> from SIGGRAPH 2018 and 2019, we begin by considering a very simple object to simulate: a theoretical particle that is infinitely small and has no mass. You can't see it. You can't feel it. It's almost as if it isn't there at all. Oh, but it is there, if we define it to be: an infinitely small dot, moving around in space, or sitting still in space, that defies all of our senses. In a nutshell, a particle, <b>p</b>, <i>is</i> nothing but a vector function <b>x<sub>p</sub></b>(<i>t</i>) of time <i>t</i> representing the position of the particle at any given time. We can think of a <i>simulation</i> of a massless, sizeless particle as just us sitting there staring at a sequence of (<i>x</i>, <i>y</i>, <i>z</i>) coordinates changing over a period of time, scrolling by on our computer screens before our eyes. Here is a more formal definition.</p>
      <p id="rounded"><b>Definition.</b> Let <b>T</b> be a closed interval in the set of real numbers, <b>R</b>. Each element of <b>T</b> is called a <b>time</b> or <b>instant of time</b>. A <b>particle</b>, <b>p</b>, is a function <b>x<sub>p</sub></b>: <b>T</b> &rarr; <b>R</b><sup>3</sup> that assigns to every time <i>t</i> &isin; <b>T</b> a <b>position</b>, <b>x<sub>p</sub></b>(<i>t</i>) = (<i>x</i>(<i>t</i>), <i>y</i>(<i>t</i>), <i>z</i>(<i>t</i>)), in 3D space, where <i>x</i>, <i>y</i>, <i>z</i>: <b>T</b> &rarr; <b>R</b> are functions representing the coordinates in 3D space of the particle <b>p</b> at each time, <i>t</i>.</p>
      <p>We'll refrain from formally defining what a <i>simulation</i> of a massless, sizeless particle is (even though we will basically do it here, but note the details of this "definition" will change as we deal with different systems in this tutorial), but you can think of it simply as a discrete sampling of the position function <b>x<sub>p</sub></b>(<i>t</i>) at specific instants in time. That is, if we pick a strictly increasing sequence of times <i>t</i><sub>0</sub>, <i>t</i><sub>1</sub>, ..., <i>t</i><sub><i>N</i></sub> from our time interval <b>T</b>, then a simulation stepping through those values of time is just a sequence of positions in 3D space: <b>x<sub>p</sub></b>(<i>t</i><sub>0</sub>) = (<i>x</i>(<i>t</i><sub>0</sub>), <i>y</i>(<i>t</i><sub>0</sub>), <i>z</i>(<i>t</i><sub>0</sub>)), <b>x<sub>p</sub></b>(<i>t</i><sub>1</sub>) = (<i>x</i>(<i>t</i><sub>1</sub>), <i>y</i>(<i>t</i><sub>1</sub>), <i>z</i>(<i>t</i><sub>1</sub>)), ..., <b>x<sub>p</sub></b>(<i>t</i><sub><i>N</i></sub>) = (<i>x</i>(<i>t</i><sub><i>N</i></sub>), <i>y</i>(<i>t</i><sub><i>N</i></sub>), <i>z</i>(<i>t</i><sub><i>N</i></sub>)), representing the position of the particle at each of the time instants in the sequence <i>t</i><sub>0</sub>, <i>t</i><sub>1</sub>, ..., <i>t</i><sub><i>N</i></sub>. For other systems that are not just a single practically-nonexistent particle, a simulation could be defined in the same way, but the <i>state</i> of the system may not just be a sequence of positions. The state could also include velocities and other values. A simulation could thus generally be defined as a sequence of states, where the state would have to be defined explicitly for any given system we simulate.</p>
      <h2 id="Simulating_a_Massless_Sizeless_Particle">Simulating a Massless, Sizeless Particle</h2>
      <p>Despite a massless, sizeless particle essentially being an invisible object, we will represent such a particle conceptually as a sphere with a nonzero radius so we can, well, actually see it as it moves around on the screen. Yes, the sphere is just a visual aid for us to see where the particle is located in space as it moves. The particle itself, according to our theoretical model here, is infinitely small. We don't really need to assume the particle is infinitely small, but I just do it anyway since we haven't yet defined a particle to be anything other than a point moving around in space over time. It'll make more sense to talk about particle-like objects that have some nonzero size when we start looking at objects interacting with other things in the scene.</p>
      <p>Let's start by making a sphere move around the window. The infinitely small point at the center of the sphere will represent a theoretical massless, sizeless particle's position as it moves around the window. Let's make a particle whose <i>x</i> and <i>y</i> coordinates change as a function of time. Let's have the particle's position (i.e., the position of the center of the sphere representing the particle) be at <b>x</b>(<i>t</i>) = (<i>x</i>(<i>t</i>), <i>y</i>(<i>t</i>), 0) where <i>x</i>(<i>t</i>) = 0.5 cos <i>t</i> and <i>y</i>(<i>t</i>) = 0.5 sin <i>t</i>, where <i>t</i> is the amount of time, measured in seconds, that the program has been running. Basically, this will cause the particle to move counterclockwise along a circle of radius 0.5 about the origin of the coordinate system shown above. Here is the code, in a new file called <a href="https://github.com/unusualinsights/phys_sim_examples/blob/main/basic/MovingParticle.cpp"><code>MovingParticle.cpp</code></a>.</p>
      <p>Compile the program:</p>
      <div class="outer">
        <div class="inner">
          <pre>g++ MovingParticle.cpp -o MovingParticle -L/usr/lib/x86_64-linux-gnu/ -lGL -lglut -lGLU</pre>
        </div>
      </div>
      <p>And run it:</p>
      <div class="outer">
        <div class="inner">
          <pre>./MovingParticle</pre>
        </div>
      </div>
      <p>Observe the resulting animation. You will see a red sphere moving around the window in a circle! Here is my animation. Ignore the slight jump in the animation as it loops. My animated gif recording program only allows integer amounts of seconds as the duration of the recording, leading to the jump:</p>
      <p><img src="MovingParticle.gif" class="centeropengl"></img></p>
      <p>We just completed our first simulation! We specified a way for the particle to move as time passes and then implemented a program that animates a sphere following that movement!</p>
      <h2 id="Model_of_Massless_Sizeless_Particle_In_Velocity_Field">Mathematical Model of a Massless, Sizeless Particle in a Velocity Field</h2>
      <p>But okay, this doesn't seem very "physics-based," does it? Let's step slightly further into physics by defining a simple concept.</p>
      <p id="rounded"><b>Definition.</b> If a particle's position function <b>x</b>(<i>t</i>) is differentiable with respect to time on an open interval of <b>R</b> that contains <b>T</b>, then the <b>velocity</b> of the particle is the time-derivative, <b>x</b>'(<i>t</i>), of the position function.</p>
      <p>To step toward something more physically-driven, let's now imagine our particle is actually floating around in the air, pushed around by a very simplistic mathematical model of wind. Specifically, let's imagine the wind is described by a velocity field, meaning there's a specific wind velocity vector given to us for any given point in space, at any given time instant. In this case, let's imagine our wind velocity vector is defined by the function <b>u</b>(<b>x</b>, <i>t</i>) = <b>u</b>(<i>x</i>, <i>y</i>, <i>z</i>, <i>t</i>) = (<i>u</i>(<i>x</i>, <i>y</i>, <i>z</i>, <i>t</i>), <i>v</i>(<i>x</i>, <i>y</i>, <i>z</i>, <i>t</i>), <i>w</i>(<i>x</i>, <i>y</i>, <i>z</i>, <i>t</i>)), where <i>u</i>(<i>x</i>, <i>y</i>, <i>z</i>, <i>t</i>) = -(<i>x</i> - 0.5 cos (<i>t</i><sup>2</sup>) cos <i>t</i>), <i>v</i>(<i>x</i>, <i>y</i>, <i>z</i>, <i>t</i>) = -(<i>y</i> - 0.5 cos (<i>t</i><sup>2</sup>) sin <i>t</i>), and <i>w</i>(<i>x</i>, <i>y</i>, <i>z</i>, <i>t</i>) = 0. Following the lead of the Bargteil and Shinar <a href="https://cal.cs.umbc.edu/Courses/PhysicsBasedAnimation/PhysicsBasedAnimationCourseNotes2019.pdf">course notes</a>, we will have our particle start at a specified initial position <b>x</b>(<i>t</i>) when <i>t</i> = 0, in this case <b>x</b>(0) = (0, 0, 0), and then keep updating the position of the particle by Forward Euler integration: <b>x</b>(<i>t</i> + &Delta;<i>t</i>) = <b>x</b>(<i>t</i>) + &Delta;t &middot; <b>u</b>(<b>x</b>(<i>t</i>), <i>t</i>). That is, the new position of the particle after stepping forward in time by an amount &Delta;<i>t</i> (the time from one call to <code>RenderScene()</code> to the next) will be the particle's current position plus the time increment amount, &Delta;t, times the velocity vector at the particle's current position at the current time. Note that this time stepping scheme is slightly more sophisticated than the simplest Forward Euler integration scheme, since we let the computer calculate &Delta;t each time it calls <code>RenderScene()</code>, and since the computer may take slightly different amounts of time between each call to <code>RenderScene()</code>, &Delta;t could vary when the program is running. And sorry for mentioning the name of a function from the code in the mathematical modeling section of the text here; I just wanted to clarify how the concept of the time step, also known as the time increment, relates to the code we've seen so far.</p>
      <h2 id="Simulating_Massless_Sizeless_Particle_in_Velocity_Field">Simulating a Massless, Sizeless Particle in a Velocity Field</h2>
      <p>Here is the code, in a file I called <a href="https://github.com/unusualinsights/phys_sim_examples/blob/main/basic/VelocityParticle.cpp"><code>VelocityParticle.cpp</code></a>.</p>
      <p>Compile:</p>
      <div class="outer">
        <div class="inner">
          <pre>g++ VelocityParticle.cpp -o VelocityParticle -L/usr/lib/x86_64-linux-gnu/ -lGL -lglut -lGLU</pre>
        </div>
      </div>
      <p>Run:</p>
      <div class="outer">
        <div class="inner">
          <pre>./VelocityParticle</pre>
        </div>
      </div>
      <p>Observe the resulting animation. It's a rather interesting animation since it looks like something "physics-based" is going on, though it's hard to tell exactly what. Rather than a particle "floating" in the wind, the animation looks more like a particle attached to a few rubber bands being pulled in various directions, eventually oscillating faster and faster as it is pulled toward the center of the window. Here is a looping animation of roughly the first 15 seconds of the animation, minus a little bit at the very beginning:</p>
      <p><img src="VelocityParticle.gif" class="centeropengl"></img></p>
      <p>This draws our attention to the fact that it's pretty challenging and unintuitive to try to manually specify velocity fields, even with some cleverly crafted formulas, that actually produce a realistic, physics-based effect that matches our vision for the system we want to model and simulate. As Bargteil and Shinar do in their <a href="https://cal.cs.umbc.edu/Courses/PhysicsBasedAnimation/PhysicsBasedAnimationCourseNotes2019.pdf">course notes</a>, we shall now proceed to the next level of physical realism in our mathematical modeling of a particle.</p>
      <p>Notice how the code above has the keyword <code>static</code> thrown around in a few places. This is not great programming style or structure! It suggests we're hacking our way through an important responsibility: keeping track of the state of our program, namely, the particle's position and the elapsed time. We need to delegate this responsibility to an object that will stay stored in memory between subsequent calls to <code>RenderScene()</code>. Let's make an improved version of this program in a file called <a href="https://github.com/unusualinsights/phys_sim_examples/blob/main/basic/VelocityParticleBetter.cpp"><code>VelocityParticleBetter.cpp</code></a>.</p>
      <p>While we got rid of the use of the <code>static</code> keyword, this code does still have a global <code>ParticleSimulator*</code> variable. To ensure it is used properly, I made a global <code>RenderScene()</code> function that checks that this variable has been initialized. Since GLUT requires that we use some static or global function as the display and idle functions, we have limited simple options for fully encapsulating all of our simulation and rendering into the classes. In this improved solution, we have better defined the jobs the program does by delegating them to different classes: the <code>Particle</code> encapsulates the storing and updating of a particle's position while the <code>ParticleSimulator</code> class does the job of advancing the simulation through time and directing its <code>Particle</code> to update and redraw itself as time elapses.</p>
      <h1 id="A_Particle_with_Mass">A Particle with Mass</h1>
      <p>We will now step into Newtonian mechanics, where we add the concepts of mass, force, and acceleration to create more physically realistic particle simulations.</p>
      <h2 id="Mathematical_Model_of_Particle_with_Mass">Mathematical Model of a Particle with Mass</h2>
			<p id="rounded"><b>Definition.</b> A <b>particle with mass</b> is a particle together with a strictly positive real number, <i>m</i>, called its <b>mass</b>.</p>
			<p>This defintiion may seem meaningless since we didn't really define what "mass" means. In fact, we won't define mass directly other than that it is a positive real number. We will make it useful though, by describing the governing axioms (assumptions or postulates) of Newtonian mechanics: namely, Newton's Laws of Motion. We will start with just Newton's Second Law. Later we'll add the Third Law. The First Law is actually a theorem that follows directly from the Second Law. Before stating Newton's Second Law, we need to define a concept and then make an assumption.</p>
			<p id="rounded"><b>Definition.</b> A nonempty set of vectors in <b>R</b><sup>3</sup> called <b>forces acting on a particle</b> can be summed to produce a <b>net force acting on the particle</b>.</p>
			<p>And now the assumption.</p>
			<p id="rounded"><b>Axiom.</b> The position function of a particle, <b>x</b>(<i>t</i>), is assumed to be twice differentiable with respect to time at all times <i>t</i> in some open interval of <b>R</b> that contains <b>T</b>.</p>
			<p>Now we can define the concept of acceleration.</p>
			<p id="rounded"><b>Definition.</b> The <b>acceleration</b> of a particle is the second time derivative of the particle's position. That is, if <b>x</b>(<i>t</i>) is the position of the particle at time <i>t</i>, then the acceleration of the particle at time <i>t</i> is <b>x</b>''(<i>t</i>).</p>
			<p>Now that we assumed we can calculate an acceleration for any time value we encounter during a simulation, we can safely state Newton's Second Law.</p>
			<p id="rounded"><b>Axiom (Newton's Second Law of Motion).</b> The net force, <b>f</b> &isin; <b>R</b><sup>3</sup>, acting on a particle is equal to the particle's mass, <i>m</i>, times the particle's <b>acceleration</b>. That is, <b>f</b> = <i>m</i><b>x</b>''(<i>t</i>).</p>
			<p>Newton's Second Law is based on a couple of particularly powerful realizations about nature:</p>
			<ul>
				<li>The motion of objects is governed by a concept called "force," and these <i>forces are additive</i> in nature; that is, any set of forces acting on an object, such as its weight and how hard we push it, can just be added together into a <i>net force</i>, which then governs how the object accelerates.</li>
				<li>The constant of proportionality relating the net force acting on an object to the object's acceleration, i.e., the object's mass, is itself a description of <i>how much matter</i> the object contains.</li>
			</ul>
			<p>Newton's Second Law is the magic that makes physics what it is: it gives us the recipe for <i>dynamics</i>: relating forces acting on objects (<i>kinetics</i>) to motion of those objects (<i>kinematics</i>).</p>
			<p>Newton's First Law, while commonly stated as another axiom of Newtonian mechanics, is actually a consequence of the Second Law.</p>
			<p id="rounded"><b>Theorem (Newton's First Law of Motion).</b> A particle with a net force of zero (<b>0</b> &isin; <b>R</b><sup>3</sup>) acting on it maintains a constant velocity at all times.</p>
			<p><b>Proof:</b> Since the net force <b>f</b> acting on the particle is zero, we know by Newton's Second Law that <b>0</b> = <b>f</b> = <i>m</i><b>x</b>''(<i>t</i>). Since we defined the mass of a particle as being strictly positive, <i>m</i><b>x</b>''(<i>t</i>) = <b>0</b> means that <b>x</b>''(<i>t</i>) = <b>0</b> for all times <i>t</i> &isin; <b>T</b>. Taking the antiderivative of this equation with respect to time yields <b>x</b>'(<i>t</i>) = <i>C</i> for some constant <i>C</i> &isin; <b>R</b> that doesn't vary with time, for all <i>t</i> &isin; <b>R</b>. Since <b>x</b>'(<i>t</i>) is the velocity of the particle, we have proved that the particle's velocity stays constant with time. This completes the proof. &#9632;</p>
			<p>Notably, if the initial velocity of a particle experiencing zero net force was zero, the particle will remain at velocity zero. Otherwise it will continue moving at the same constant velocity at all times. This explains a commonly stated version of Newton's First Law, that a particle at rest will remain at rest and a particle in motion will remain in motion at a constant velocity unless acted on by an outside force (which must result in a net nonzero force acting on the particle).</p>
			<h2 id="Simulating_Particle_with_Mass">Simulating a Particle with Mass</h2>
      <p>Here is an implementation of the model described above, in a file I called <a href="https://github.com/unusualinsights/phys_sim_examples/blob/main/basic/MassParticleGravity.cpp"><code>MassParticleGravity.cpp</code></a>.</p>

    </div>
  </body>
</html>
